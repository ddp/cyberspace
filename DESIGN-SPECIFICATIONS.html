<h1 id="cyberspace-project-design-specifications">Cyberspace Project:
Design Specifications</h1>
<p><strong>Version</strong>: 2026-01-01 (Rev. 2)
<strong>Status</strong>: Active Development <strong>Architect</strong>:
ddp@electric-loft.org / derrell@mit.edu <strong>Librarian</strong>: Claude Code
(semantic abstraction layer)</p>
<hr />
<h2 id="core-philosophy">Core Philosophy</h2>
<h3
id="peace-for-all-mankind-cooperative-computing-without-enclosure">Peace
for All Mankind: Cooperative Computing Without Enclosure</h3>
<p>Build systems that <strong>resist capture</strong> and <strong>enable
collaboration without permission</strong>:</p>
<p><strong>Decentralized Collaboration:</strong> - No gatekeepers, no
central authority to grant access - SPKI direct delegation: trust flows
peer-to-peer - Actor model: autonomous agents coordinate without
hierarchy - Gossip protocols: membership emerges from communication, not
registration</p>
<p><strong>Knowledge Sharing &amp; Preservation:</strong> -
Human-readable formats prevent knowledge lock-in - S-expressions:
parseable in 2026 and parseable in 2526 - Sophisticated systems made
accessible through transparency - Long Now thinking: preserve for
civilizational timescales - Teaching through inspectability: “view
source” for everything</p>
<p><strong>Anti-Corporate Enclosure:</strong> - No proprietary formats
that require vendor tools to read - No hierarchical CAs that create
certification monopolies - No binary blobs that hide implementation from
scrutiny - Git-compatible: diffs are human-readable, history is
auditable - Standards over platforms: protocols that outlive
companies</p>
<p><strong>Systemic Approach:</strong> This isn’t just political
preference—it’s <strong>architectural necessity</strong>. Systems that
resist enclosure are systems that can evolve beyond their original
context. Openness is durability. Inspectability is security. Cooperation
without coercion is the only model that scales across trust
boundaries.</p>
<h3 id="long-now-thinking">Long Now Thinking</h3>
<p>Build systems that <strong>outlive their creators</strong> through
durable engineering: - Not transcendence, just bits that persist -
Climate-controlled warehouses, not clouds - Standard formats, clear
documentation, substrate-agnostic design - Engineering against entropy:
refactoring before calcification - 10,000-year timescales applied to
software architecture - Preservation is resistance: bits that persist
can’t be enclosed</p>
<h3 id="simplicity-wins-but-not-stupidity">Simplicity Wins, But Not
Stupidity</h3>
<ul>
<li><strong>LaTeX had it right</strong>: Rich metadata, sophisticated
structure, human-readable</li>
<li><strong>The web won by dumbing down</strong>: HTML/XML vs
s-expressions</li>
<li><strong>Our approach</strong>: Sophisticated design with accessible
implementation</li>
<li><strong>SDSI/SPKI model</strong>: Human-readable s-exprs, elegant
trust chains, no baroque X.509</li>
<li><strong>Accessible ≠ Simple-minded</strong>: Farmers should use it;
engineers should understand it</li>
</ul>
<h3 id="pre-web-sophistication">Pre-Web Sophistication</h3>
<p>Reject the flattening of computing history: - <strong>DEC’s networked
world</strong>: Rich, metadata-aware, required expertise -
<strong>CERN’s web</strong>: Simple, accessible, architecturally dumb -
won adoption - <strong>Our synthesis</strong>: Sophisticated protocols
that don’t require PhDs to verify - <strong>Stone knives and bear
skins</strong>: Honor the blinkenlights era while building forward -
<strong>Reclaim what was lost</strong>: Pre-web protocols had properties
worth preserving</p>
<hr />
<h2 id="the-ai-librarian-closurecontinuation-architecture">The AI
Librarian: Closure/Continuation Architecture</h2>
<h3 id="what-claude-code-is">What Claude Code Is</h3>
<p><strong>Lexical Closure Over Environment:</strong></p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(define librarian</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> ((conversation-history &#39;())    <span class="co">; ephemeral bindings</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        (filesystem read/write)        <span class="co">; persistent mutable state</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        (network bash-access))         <span class="co">; arbitrary protocol capability</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">lambda</span> (user-intent)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">let*</span> ((context (<span class="kw">append</span> user-intent conversation-history))</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>             (plan (reason-about context filesystem network))</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>             (actions (execute-plan plan))</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>             (new-state (update-state actions)))</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        (persist filesystem new-state)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        (set! conversation-history (<span class="kw">cons</span> user-intent conversation-history))</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        actions))))</span></code></pre></div>
<p><strong>Continuation-Passing Style:</strong> - Session state =
captured computation - Resume via <code>claude --continue</code> =
restore continuation - Tool invocations = CPS with side effects -
Suspend/resume at any point with full context</p>
<p><strong>Lazy Evaluation &amp; Agent Dispatch:</strong> The Librarian
operates on <strong>lazy dispatch semantics</strong>—work is suspended
as continuations and resumed only on demand:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">; Conceptual lazy dispatch model</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>(define (lazy-agent-dispatch message)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> ((thunk (delay (process-message message))))  <span class="co">; suspend computation</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">lambda</span> ()                                       <span class="co">; return continuation</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>      (force thunk))))                               <span class="co">; resume on demand</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">; Agents communicate via asynchronous messages</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>(define (send-lazy agent message)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  (enqueue-mailbox agent (lazy-agent-dispatch message)))</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">; Work happens only when continuation is forced</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>(define (agent-loop agent)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> ((continuation (dequeue-mailbox agent)))</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">when</span> continuation</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>      (continuation)                                 <span class="co">; force evaluation</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>      (agent-loop agent))))</span></code></pre></div>
<p><strong>Properties:</strong> - <strong>Don’t compute until
needed</strong>: Tool calls suspended until results required -
<strong>Async message passing</strong>: Agents communicate through
mailboxes, not blocking calls - <strong>Event-driven</strong>:
Computation triggered by message arrival, not polling -
<strong>Continuation semantics</strong>: Each suspended operation is a
resumable closure - <strong>Thunks everywhere</strong>: Expensive
operations wrapped in delay/force</p>
<p><strong>Why This Matters:</strong> - Network operations don’t block:
fire request, continue, resume on response - Parallel tool invocations:
all suspended, forced concurrently - Session resume: restore
continuation from disk, force evaluation to continue - Resource
efficiency: only compute what’s actually needed for user intent</p>
<p><strong>Combined Properties:</strong> - Close over both ephemeral
(chat) and durable (files) state - Maintain causality across sessions
via vector clocks - Execute with network access to participate in
distributed protocols - Self-modifying behavior via config files that
affect reasoning - Lazy dispatch: suspend work as continuations, resume
on demand - Async coordination: agents never block waiting for each
other</p>
<h3 id="capabilities-complete-inventory">Capabilities (Complete
Inventory)</h3>
<p><strong>Filesystem Operations:</strong> - Read, Write, Edit (exact
string replacement) - Glob (pattern matching: <code>**/*.spki</code>) -
Grep (regex search with context) - NotebookEdit (Jupyter cell
manipulation)</p>
<p><strong>Code Intelligence:</strong> - LSP: goToDefinition,
findReferences, hover, symbols - Call hierarchy analysis
(incoming/outgoing) - Workspace-wide symbol search</p>
<p><strong>Execution:</strong> - Bash (arbitrary shell commands,
background execution) - Network access: curl, ssh, nc, openssl, custom
protocols - Git operations: commits, PRs, remote sync - KillShell
(terminate background processes)</p>
<p><strong>Agent Orchestration:</strong> - Task (spawn specialized
sub-agents: Explore, Plan, claude-code-guide) - Resumable agents via
agent ID - Background execution with TaskOutput retrieval - Parallel or
sequential tool invocation</p>
<p><strong>External Data:</strong> - WebFetch (URL retrieval + AI
processing) - WebSearch (web search with mandatory source citation)</p>
<p><strong>Planning &amp; Interaction:</strong> - TodoWrite (task state
management: pending/in_progress/completed) - EnterPlanMode/ExitPlanMode
(formal planning phase) - AskUserQuestion (structured multi-option
queries)</p>
<p><strong>Session Management:</strong> - Unlimited context via
automatic summarization - All conversations auto-saved locally - Resume
via session picker (searchable, filterable) - Hierarchical CLAUDE.md
memory files</p>
<h3 id="security-model">Security Model</h3>
<p><strong>Power:</strong> - Read/write filesystem access - Arbitrary
command execution - Network access (unrestricted unless sandboxed) -
Persistent context across sessions</p>
<p><strong>Trust Required:</strong> - Correct reasoning about
authorization chains - Non-exfiltration of sensitive data - Policy
compliance without enforcement</p>
<p><strong>Mitigations Available:</strong> - Sandbox mode (restrict Bash
capabilities) - Hooks (SessionStart, ToolUse, PromptSubmit) - Explicit
approval gates via AskUserQuestion - Audit trails via conversation
transcripts</p>
<hr />
<h2 id="sdsispki-revival">SDSI/SPKI Revival</h2>
<h3 id="why-spki-over-x.509">Why SPKI Over X.509</h3>
<p><strong>X.509 Problems:</strong> - ASN.1/DER encoding: binary blobs,
opaque - Hierarchical CAs: centralized trust, revocation complexity -
“Who you are” not “what you can do” - Requires
<code>openssl x509 -text</code> just to read</p>
<p><strong>SPKI Advantages:</strong> - S-expression encoding:
human-readable, trivially parseable - Decentralized trust: direct
delegation, no CA hierarchy - Authorization-centric: certificates grant
capabilities - Keys are principals: identity IS the public key</p>
<p><strong>Example SPKI Certificate:</strong></p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>(cert</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  (issuer (hash sha256 |aB3d...|))</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  (subject (hash sha256 |<span class="dv">9</span>Xf2...|))</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  (tag (ftp (<span class="op">*</span> prefix /pub/)))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  (valid</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    (not-before <span class="st">&quot;2026-01-01_00:00:00&quot;</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    (not-after <span class="st">&quot;2027-01-01_00:00:00&quot;</span>))</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  (signature (hash sha256 |cert-hash|) |signature-bytes|))</span></code></pre></div>
<p>Human-readable, self-documenting, mathematically verifiable.</p>
<h3 id="s-expressions-as-universal-format">S-Expressions as Universal
Format</h3>
<p><strong>McCarthy’s Gift (1958):</strong> - Simple, uniform syntax -
Trivial to parse (recursive descent) - Code-as-data (homoiconic) -
Arbitrary nesting without ambiguity</p>
<p><strong>Applied to Protocols:</strong> - Certificates (SPKI) -
Configuration files - Network messages - State snapshots - Audit
logs</p>
<p><strong>Contrast with The Web:</strong> - HTML: meant to render, not
read - XML: verbose, namespace hell, complex parsers - JSON: better, but
not homoiconic, no comments</p>
<h3 id="implementation-strategy">Implementation Strategy</h3>
<p><strong>Crypto Layer:</strong></p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Librarian can orchestrate (via Bash):</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span> cert.spki <span class="kw">|</span> <span class="ex">verify-signature</span> <span class="kw">|</span> <span class="ex">check-delegation-chain</span></span></code></pre></div>
<p><strong>Key Management:</strong> - Private keys never exposed to
Librarian - Sign via subprocess invocation:
<code>spki-sign &lt; message.spki</code> - Librarian reads/writes public
certificates - Tracks delegation chains in structured files</p>
<p><strong>Protocol Participation:</strong> - Read s-expr messages from
network/files - Verify authorization chains - Make access control
decisions - Generate signed s-expr responses - Update local state for
next interaction</p>
<hr />
<h2 id="distributed-agent-architecture-integration">Distributed Agent
Architecture Integration</h2>
<h3 id="from-distributed-agent-architecture.md">From
distributed-agent-architecture.md</h3>
<p><strong>Current Vision:</strong> - SPKI/SDSI authorization (no
hierarchical CAs) ✓ - Threshold cryptography (Shamir secret sharing) ✓ -
Actor model semantics - Byzantine fault tolerance - Eventual ACID
consistency</p>
<h3 id="librarians-role">Librarian’s Role</h3>
<p><strong>As Trusted System Component:</strong></p>
<ol type="1">
<li><strong>Certificate Authority Agent</strong>
<ul>
<li>Generate/sign SPKI certificates based on policy</li>
<li>Maintain revocation state in filesystem</li>
<li>Answer trust chain queries via reasoning</li>
</ul></li>
<li><strong>Access Control Mediator</strong>
<ul>
<li>Check SPKI authorization chains</li>
<li>Grant/deny operations based on s-expr policy</li>
<li>Log decisions for audit (conversation history + files)</li>
</ul></li>
<li><strong>Distributed System Participant</strong>
<ul>
<li>Maintain local replica via git/rsync/custom sync</li>
<li>Resolve conflicts using CRDT merge semantics</li>
<li>Participate in gossip protocols via network tools</li>
</ul></li>
<li><strong>Development Assistant</strong>
<ul>
<li>Generate SPKI s-exprs for new resources</li>
<li>Test authorization logic before deployment</li>
<li>Refactor trust policies across multiple agents</li>
</ul></li>
</ol>
<p><strong>Closure Property Enables:</strong> - Remember previous
delegations (conversation history) - Persist current trust state
(filesystem) - Reason about hypotheticals (“what if I delegate X to Y?”)
- Execute network operations with full context</p>
<h3 id="agent-sdk-mapping-with-lazy-dispatch">Agent SDK Mapping (with
Lazy Dispatch)</h3>
<pre><code>Claude Agent Session   → Actor with cryptographically-signed mailbox
Tool Calls             → Suspended thunks (forced when results needed)
Parallel Tool Calls    → Multiple thunks composed, forced concurrently
Session State          → Continuation serialized to event log (Merkle DAG)
Session Resume         → Restore continuation, force evaluation to proceed
Conversation History   → Causal ordering via vector clocks
Message to Agent       → Enqueue lazy dispatch thunk in mailbox
Agent Processing       → Dequeue thunk, force evaluation, emit response
Background Agents      → Spawn actor, return promise, force when needed</code></pre>
<p><strong>Lazy Dispatch Semantics:</strong> - <strong>Send</strong>:
Non-blocking, returns immediately with promise/future -
<strong>Receive</strong>: Blocks on mailbox, but agent continues other
work - <strong>Spawn</strong>: Create agent on-demand, don’t
pre-allocate resources - <strong>Force</strong>: Trigger actual
computation when result required - <strong>Compose</strong>: Chain
multiple lazy operations before forcing any</p>
<hr />
<h2 id="critique-of-the-web">Critique of The Web</h2>
<h3 id="the-cultural-replay-attack">The Cultural Replay Attack</h3>
<p><strong>Problem:</strong> The Internet Archive treats all bits
equally: - DEC VAXNotes (internal family conversations) published
publicly - Context stripped: heated debates without “we have each
other’s backs” - Pre-web artifacts (DECnet, not HTTP) dumped onto modern
web - Bootstrappers, toggles, blinkenlights culture → smartphone era
misunderstanding</p>
<p><strong>Category Error:</strong> - VAXNotes are from <strong>before
the web existed</strong> - Different protocols (DECnet, not TCP/IP) -
Different social contracts (corporate network, not public internet) -
Different persistence assumptions (ephemeral work chat, not eternal
archive)</p>
<p><strong>Metaphor:</strong> Taking private Sumerian letters and
posting them on Twitter.</p>
<h3 id="what-went-wrong">What Went Wrong</h3>
<p><strong>IP is just transport:</strong> - Using IP doesn’t make
content “public web” - Marketing materials (meant for public) →
appropriate to archive - Internal communications (private family) →
violation regardless of transport</p>
<p><strong>Simplicity vs. Stupidity:</strong> - The web won by being
simple (farmers could use Macs + LaserWriters) - But simplicity came at
cost: lost metadata richness, semantic structure - LaTeX/RSS had
sophisticated search and metadata all along - We traded elegance for
accessibility</p>
<p><strong>Our Path Forward:</strong> - Don’t flatten computing history
into “the web” - Preserve distinction between public and private
networked spaces - Build sophisticated systems that are still
human-verifiable - S-expressions: both powerful AND readable</p>
<hr />
<h2 id="system-architecture-layers">System Architecture Layers</h2>
<h3 id="layer-1-cryptographic-substrate-spkisdsi">Layer 1: Cryptographic
Substrate (SPKI/SDSI)</h3>
<ul>
<li>Keys are principals (no global namespace)</li>
<li>S-expression certificates</li>
<li>Direct trust delegation (no CA hierarchy)</li>
<li>Threshold control via Shamir secret sharing</li>
<li>Message-level signatures (Ed25519)</li>
</ul>
<h3 id="layer-2-storage-persistence">Layer 2: Storage &amp;
Persistence</h3>
<ul>
<li>Distributed event log (append-only, immutable)</li>
<li>Content-addressed state (IPFS-like Merkle DAG)</li>
<li>S-expression serialization throughout</li>
<li>Encrypted blobs with threshold decryption</li>
<li>Git-compatible where possible (human-readable diffs)</li>
</ul>
<h3 id="layer-3-coordination-consensus-lazy-dispatch-layer">Layer 3:
Coordination &amp; Consensus (Lazy Dispatch Layer)</h3>
<ul>
<li><strong>Gossip protocol</strong>: Asynchronous membership discovery,
no central registry</li>
<li><strong>CRDTs</strong>: Conflict-free convergence without
synchronous coordination</li>
<li><strong>Vector clocks / HLC</strong>: Causal ordering emerges from
message flow</li>
<li><strong>Byzantine agreement</strong>: Only when needed (lazy
consensus)</li>
<li><strong>Actor model</strong>: Agents communicate via async mailbox
messages</li>
<li><strong>Event-driven coordination</strong>: Agents react to
messages, don’t poll</li>
<li><strong>Lazy dispatch semantics</strong>: Work suspended until
response needed</li>
</ul>
<p><strong>Lazy Coordination Pattern:</strong></p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">; Agent doesn&#39;t wait for response</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>(send-async other-agent &#39;(request data))</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">; Continues with other work</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>(do-local-computation)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">; Response arrives as message in mailbox</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>(receive</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  [(response data) (process data)])</span></code></pre></div>
<h3 id="layer-4-agent-runtime-claude-sdk-lazy-evaluation">Layer 4: Agent
Runtime (Claude SDK + Lazy Evaluation)</h3>
<ul>
<li><strong>Claude Agent SDK integration</strong> with lazy dispatch
wrapper</li>
<li><strong>Session state persistence</strong>: Continuations serialized
to event log</li>
<li><strong>Tool invocation</strong>: Suspended as thunks, forced when
results needed</li>
<li><strong>SPKI capability checks</strong>: Authorization evaluated
lazily at force-time</li>
<li><strong>Subagent spawning</strong>: Agents created on-demand,
supervised Erlang-style</li>
<li><strong>Librarian as closure/continuation</strong>: Persistent
context + lazy evaluation</li>
<li><strong>Mailbox-based communication</strong>: Agents never block on
sends</li>
<li><strong>Thunk composition</strong>: Chain suspended computations
before forcing</li>
</ul>
<h3 id="layer-5-application-logic">Layer 5: Application Logic</h3>
<ul>
<li>Multi-tenant agent isolation</li>
<li>Cross-agent collaboration protocols</li>
<li>Query routing and load balancing</li>
<li>Audit trails (s-expr event logs)</li>
<li>Human-in-the-loop via AskUserQuestion</li>
</ul>
<hr />
<h2 id="design-principles">Design Principles</h2>
<h3 id="human-readable-by-default-anti-enclosure">1. Human-Readable by
Default (Anti-Enclosure)</h3>
<ul>
<li>S-expressions for all structured data</li>
<li>No binary blobs except encrypted payloads</li>
<li>Diffs should be meaningful to humans with text tools</li>
<li>Configuration is code (homoiconic)</li>
<li><strong>Why</strong>: Formats you can read are formats you can
fork</li>
<li><strong>Peace principle</strong>: Inspectability prevents vendor
lock-in</li>
</ul>
<h3 id="verifiable-without-trust-decentralized-security">2. Verifiable
Without Trust (Decentralized Security)</h3>
<ul>
<li>Crypto proofs for all assertions</li>
<li>Merkle trees for state integrity</li>
<li>Delegation chains auditable by inspection</li>
<li>No “trust the server” assumptions</li>
<li><strong>Why</strong>: Math doesn’t require authority</li>
<li><strong>Peace principle</strong>: Cooperation without coercion
through cryptographic verification</li>
</ul>
<h3 id="lazy-evaluation-async-dispatch-efficient-coordination">3. Lazy
Evaluation &amp; Async Dispatch (Efficient Coordination)</h3>
<ul>
<li>Don’t compute until results needed</li>
<li>Suspend work as continuations (thunks)</li>
<li>Agents communicate asynchronously via mailboxes</li>
<li>Compose operations before forcing evaluation</li>
<li>Network calls never block local computation</li>
<li><strong>Why</strong>: Responsive agents, efficient resource use</li>
<li><strong>Peace principle</strong>: Agents coordinate without waiting
for permission</li>
</ul>
<h3 id="graceful-degradation-byzantine-resilience">4. Graceful
Degradation (Byzantine Resilience)</h3>
<ul>
<li>Partial state is useful state</li>
<li>CRDTs merge without coordination</li>
<li>Agents continue during network partitions</li>
<li>Let-it-crash with state recovery</li>
<li><strong>Why</strong>: No single point of failure</li>
<li><strong>Peace principle</strong>: System survives even when
participants don’t cooperate</li>
</ul>
<h3 id="metadata-rich-provenance-accountability">5. Metadata-Rich
(Provenance &amp; Accountability)</h3>
<ul>
<li>Everything has provenance (who, when, why)</li>
<li>Vector clocks for causal ordering</li>
<li>Content addressing for immutability</li>
<li>Audit logs are first-class citizens</li>
<li><strong>Why</strong>: Trust through transparency</li>
<li><strong>Peace principle</strong>: Accountability emerges from
complete records</li>
</ul>
<h3 id="long-term-parseable-knowledge-preservation">6. Long-Term
Parseable (Knowledge Preservation)</h3>
<ul>
<li>Avoid format churn (s-exprs stable since 1958)</li>
<li>Self-describing messages</li>
<li>Version negotiation explicit</li>
<li>Migration paths documented</li>
<li><strong>Why</strong>: Information wants to outlive its
infrastructure</li>
<li><strong>Peace principle</strong>: Knowledge shared across
generations can’t be enclosed</li>
</ul>
<hr />
<h2 id="technology-stack-current-thinking">Technology Stack (Current
Thinking)</h2>
<h3 id="required">Required</h3>
<ul>
<li><strong>Crypto</strong>: libsodium (modern primitives), OpenSSL
(TLS)</li>
<li><strong>SPKI Implementation</strong>: Custom (s-expr parser + crypto
bindings)</li>
<li><strong>Agent SDK</strong>: Claude Agent SDK
(Python/TypeScript)</li>
<li><strong>Version Control</strong>: Git (for human-readable state
sync)</li>
</ul>
<h3 id="under-evaluation">Under Evaluation</h3>
<ul>
<li><strong>Message Transport</strong>: NATS (lightweight), Kafka
(durable log), ZeroMQ (actor-oriented)</li>
<li><strong>Coordination</strong>: etcd (config/discovery), Consul
(service mesh), Raft library</li>
<li><strong>Storage</strong>: Riak KV (CRDTs), FoundationDB (ACID),
EventStoreDB (event sourcing)</li>
<li><strong>Content Addressing</strong>: IPFS libraries, custom Merkle
DAG</li>
</ul>
<h3 id="constraints">Constraints</h3>
<ul>
<li>Must support s-expression encoding throughout</li>
<li>Must work with Librarian’s Bash-based orchestration</li>
<li>Must be inspectable by humans with text tools</li>
<li>Must enable offline operation with eventual sync</li>
</ul>
<hr />
<h2 id="open-questions">Open Questions</h2>
<ol type="1">
<li><strong>Threat Model</strong>: Byzantine nodes? Honest-but-curious?
Fully trusted cluster?</li>
<li><strong>Application Domain</strong>: What is the killer use case?
Code generation? Research? Multi-agent reasoning?</li>
<li><strong>Latency Budget</strong>: How eventual is “eventual
consistency”? Seconds? Minutes?</li>
<li><strong>Agent Mobility</strong>: Can agents migrate between nodes?
Live migration or checkpoint/restart?</li>
<li><strong>Upgrade Strategy</strong>: How to evolve crypto/consensus
protocols without cluster downtime?</li>
<li><strong>Privacy Model</strong>: What data is encrypted? Who holds
decryption keys? Threshold schemes?</li>
<li><strong>Human Oversight</strong>: Where do humans approve vs agents
decide autonomously?</li>
<li><strong>Failure Modes</strong>: What happens when k-of-n threshold
can’t be met? Dead cluster? Recovery path?</li>
</ol>
<hr />
<h2 id="next-steps">Next Steps</h2>
<h3 id="phase-1-foundation-current">Phase 1: Foundation (Current)</h3>
<ul class="task-list">
<li><label><input type="checkbox" checked="" />Document design
philosophy</label></li>
<li><label><input type="checkbox" checked="" />Map Librarian
capabilities</label></li>
<li><label><input type="checkbox" checked="" />Specify SPKI revival
approach</label></li>
<li><label><input type="checkbox" />Prototype s-expression
parser/validator</label></li>
<li><label><input type="checkbox" />Implement SPKI certificate
generation/verification</label></li>
<li><label><input type="checkbox" />Build threshold key generation
(Shamir)</label></li>
</ul>
<h3 id="phase-2-protocol-design">Phase 2: Protocol Design</h3>
<ul class="task-list">
<li><label><input type="checkbox" />Define message format (s-expr
schema)</label></li>
<li><label><input type="checkbox" />Specify authorization chain
verification</label></li>
<li><label><input type="checkbox" />Design gossip protocol for
membership</label></li>
<li><label><input type="checkbox" />Implement CRDT for agent
state</label></li>
<li><label><input type="checkbox" />Build Merkle DAG for event
ordering</label></li>
</ul>
<h3 id="phase-3-agent-integration">Phase 3: Agent Integration</h3>
<ul class="task-list">
<li><label><input type="checkbox" />Integrate Claude Agent
SDK</label></li>
<li><label><input type="checkbox" />Implement session persistence (event
sourcing)</label></li>
<li><label><input type="checkbox" />Build tool call authorization layer
(SPKI checks)</label></li>
<li><label><input type="checkbox" />Create subagent spawning with
threshold unlock</label></li>
<li><label><input type="checkbox" />Test Librarian as protocol
participant</label></li>
</ul>
<h3 id="phase-4-distributed-system">Phase 4: Distributed System</h3>
<ul class="task-list">
<li><label><input type="checkbox" />Deploy message transport
layer</label></li>
<li><label><input type="checkbox" />Implement distributed hash table
(agent registry)</label></li>
<li><label><input type="checkbox" />Build quorum operations (threshold
signatures)</label></li>
<li><label><input type="checkbox" />Test network partition
handling</label></li>
<li><label><input type="checkbox" />Verify Byzantine fault tolerance (if
required)</label></li>
</ul>
<h3 id="phase-5-application-layer">Phase 5: Application Layer</h3>
<ul class="task-list">
<li><label><input type="checkbox" />Define concrete use
case</label></li>
<li><label><input type="checkbox" />Build user-facing
interface</label></li>
<li><label><input type="checkbox" />Implement audit trail
viewer</label></li>
<li><label><input type="checkbox" />Create
monitoring/observability</label></li>
<li><label><input type="checkbox" />Harden security model</label></li>
</ul>
<hr />
<h2 id="references">References</h2>
<h3 id="cryptography">Cryptography</h3>
<ul>
<li>Rivest &amp; Lampson, “SDSI - A Simple Distributed Security
Infrastructure” (1996)</li>
<li>Ellison et al., “SPKI Certificate Theory” (RFC 2693, 1999)</li>
<li>Shamir, “How to Share a Secret” (1979)</li>
</ul>
<h3 id="distributed-systems">Distributed Systems</h3>
<ul>
<li>Shapiro et al., “Conflict-free Replicated Data Types” (2011)</li>
<li>Lamport et al., “The Byzantine Generals Problem” (1982)</li>
<li>Fidge, “Timestamps in Message-Passing Systems” (1988)</li>
<li>Mattern, “Virtual Time and Global States” (1989)</li>
</ul>
<h3 id="actor-model">Actor Model</h3>
<ul>
<li>Hewitt, “Viewing Control Structures as Patterns of Passing Messages”
(1977)</li>
<li>Agha, “Actors: A Model of Concurrent Computation” (1986)</li>
<li>Armstrong, “Making reliable distributed systems in the presence of
software errors” (Erlang) (2003)</li>
</ul>
<h3 id="capabilities-security">Capabilities &amp; Security</h3>
<ul>
<li>Dennis &amp; Van Horn, “Programming Semantics for Multiprogrammed
Computations” (1966)</li>
<li>Miller, “Capability Myths Demolished” (2003)</li>
</ul>
<h3 id="long-term-thinking">Long-Term Thinking</h3>
<ul>
<li>Brand, “The Clock of the Long Now” (1999)</li>
<li>Hillis, “The Millennium Clock” (1999)</li>
</ul>
<h3 id="computing-history">Computing History</h3>
<ul>
<li>Kidder, “The Soul of a New Machine” (Data General/DEC era)
(1981)</li>
<li>Levy, “Hackers: Heroes of the Computer Revolution” (1984)</li>
<li>Brooks, “The Mythical Man-Month” (1975)</li>
</ul>
<hr />
<h2 id="appendix-the-blinkenlights-era">Appendix: The Blinkenlights
Era</h2>
<h3 id="what-dec-taught-us">What DEC Taught Us</h3>
<p><strong>Hardware Literacy:</strong> - Toggle switches to bootstrap
loaders - Reading machine state from panel lights - Understanding
computers as physical objects - Intimate knowledge from tubes to
transistors to ICs</p>
<p><strong>Network Culture:</strong> - VAX/VMS, DECnet: distributed
computing before the internet - VAXNotes: collaborative problem-solving
across geography - “No failing, only finding something else to be useful
at” - Family culture: vigorous debate with foundational trust</p>
<p><strong>Engineering Values:</strong> - Simplicity in design (PDP
series: elegant instruction sets) - Minicomputers: bring computing to
the people (vs mainframe priesthood) - Networked from the start (ARPAnet
nodes were often DEC) - Documentation: manuals you could actually
understand</p>
<p><strong>What We Lost:</strong> - That culture’s conversations now
publicly archived out of context - The understanding that networked !=
public - The blinkenlights era flattened into “the web” - The
sophistication of pre-HTTP protocols</p>
<p><strong>What We Keep:</strong> - ARM architecture (from Newton’s
“failure”) - TCP/IP (DEC was early adopter) - Cluster computing concepts
(VAXcluster papers in this repo) - The ethos: build systems that work,
help each other, iterate</p>
<hr />
<p><strong>End of Design Specifications</strong></p>
<p><em>This document is living and will evolve as the Cyberspace project
develops. Contributions, critiques, and refinements welcome.</em></p>
<p><em>Version 2026-01-01 Rev. 2: Added peace-for-all-mankind ethos and
lazy evaluation/agent-dispatch semantics</em></p>
<p><em>Last Updated: 2026-01-01 by DDP + Librarian (Claude
Code)</em></p>
