#!/usr/bin/env csi -s
;;; sync - Global synchronization primitive for Cyberspace
;;;
;;; Usage: sync [OPTIONS]
;;;
;;; Synchronizes the entire Cyberspace repository with remote sources.
;;; During bootstrapping, this ensures all components are up to date.
;;;
;;; Options:
;;;   --dry-run    Show what would be synced without making changes
;;;   --quiet      Suppress informational messages
;;;   --help       Show this help message
;;;
;;; Philosophy:
;;;   "Rough consensus, cryptography, trusted systems and running code."
;;;
;;;   This primitive ensures Cyberspace stays synchronized across machines
;;;   and confederations of friends. It's the bootstrap mechanism for
;;;   maintaining coherence.

(import (chicken process)
        (chicken process-context)
        (chicken file)
        (chicken pathname)
        (chicken string)
        (chicken io)
        (chicken format)
        (chicken time)
        (chicken time posix)
        srfi-1
        srfi-13)

;;; --- Configuration ---

(define *cyberspace-root*
  (or (get-environment-variable "CYBERSPACE_ROOT")
      (current-directory)))

(define *default-branch* "main")

;;; Master node abstraction - can be:
;;;   1. Environment variable: CYBERSPACE_MASTER
;;;   2. Config file: ~/.cyberspace/master
;;;   3. Lambda in config file (for dynamic resolution)
;;;   4. Default: "origin" (git remote)
;;;
;;; During bootstrapping, fluffy.eludom.net is the master
(define (resolve-master)
  "Resolve the master node for synchronization"
  (or
   ;; 1. Environment variable (highest priority)
   (get-environment-variable "CYBERSPACE_MASTER")

   ;; 2. Config file ~/.cyberspace/master
   (and (file-exists? (make-pathname (list (get-environment-variable "HOME") ".cyberspace") "master"))
        (call-with-input-file
            (make-pathname (list (get-environment-variable "HOME") ".cyberspace") "master")
          (lambda (port)
            (let ((line (read-line port)))
              (if (eof-object? line)
                  #f
                  (string-trim-both line))))))

   ;; 3. Default to origin git remote
   "origin"))

(define *master-node* (resolve-master))

;;; --- Helpers ---

(define (timestamp)
  "Return current timestamp in ISO-8601 format"
  (time->string (seconds->local-time (current-seconds)) "%Y-%m-%d %H:%M:%S"))

(define (log-info msg . args)
  (unless (member "--quiet" (command-line-arguments))
    (apply printf (cons (string-append "[" (timestamp) "] " msg "\n") args))))

(define (log-error msg . args)
  (apply fprintf (cons (current-error-port)
                       (cons (string-append "[" (timestamp) " ERROR] " msg "\n") args))))

(define (dry-run?)
  (member "--dry-run" (command-line-arguments)))

(define (run-command cmd . args)
  "Execute command and return (exit-code . output)"
  (if (dry-run?)
      (begin
        (log-info "DRY RUN: ~a ~a" cmd (string-intersperse args " "))
        (values 0 ""))
      (let ((full-cmd (string-append cmd " " (string-intersperse args " "))))
        (call-with-input-pipe
         full-cmd
         (lambda (port)
           (let ((output (read-string #f port)))
             (values 0 (or output ""))))))))

(define (git . args)
  "Run git command in cyberspace root"
  (let ((old-dir (current-directory)))
    (change-directory *cyberspace-root*)
    (let-values (((status output) (apply run-command "git" args)))
      (change-directory old-dir)
      (if (zero? status)
          output
          (begin
            (log-error "git ~a failed with status ~a"
                      (string-intersperse args " ")
                      status)
            #f)))))

;;; --- Blob Metadata ---

(define (get-commit-info)
  "Get current commit metadata"
  (let ((hash (git "rev-parse" "--short" "HEAD"))
        (subject (git "log" "-1" "--format=%s"))
        (author (git "log" "-1" "--format=%an"))
        (date (git "log" "-1" "--format=%ci")))
    (if (and hash subject)
        `((hash . ,(string-trim-both (or hash "")))
          (subject . ,(string-trim-both (or subject "")))
          (author . ,(string-trim-both (or author "")))
          (date . ,(string-trim-both (or date ""))))
        #f)))

(define (get-repo-stats)
  "Get repository statistics"
  (let ((object-count (git "rev-list" "--all" "--count"))
        (branch-count (git "branch" "--list"))
        (tag-count (git "tag" "--list")))
    `((commits . ,(string-trim-both (or object-count "0")))
      (branches . ,(length (filter (lambda (s) (> (string-length s) 0))
                                   (string-split (or branch-count "") "\n"))))
      (tags . ,(length (filter (lambda (s) (> (string-length s) 0))
                               (string-split (or tag-count "") "\n")))))))

;;; --- Code Metrics ---

(define (count-lines-symbols path pattern)
  "Count lines and symbols for files matching pattern in path"
  (let ((cmd (sprintf "find ~a/~a -name '~a' -exec cat {} + 2>/dev/null | wc -lw"
                      *cyberspace-root* path pattern)))
    (call-with-input-pipe cmd
      (lambda (port)
        (let ((line (read-line port)))
          (if (eof-object? line)
              (cons 0 0)
              (let ((parts (string-split (string-trim-both line))))
                (if (>= (length parts) 2)
                    (cons (string->number (car parts))
                          (string->number (cadr parts)))
                    (cons 0 0)))))))))

(define (count-assets)
  "Count total assets in cyberspace"
  (let ((cmd (sprintf "find ~a -type f -not -path '*/.git/*' | wc -l"
                      *cyberspace-root*)))
    (call-with-input-pipe cmd
      (lambda (port)
        (let ((line (read-line port)))
          (if (eof-object? line)
              0
              (string->number (string-trim-both line))))))))

(define (display-code-metrics)
  "Display code metrics for cyberspace"
  (let* ((rfc-stats (count-lines-symbols "spki/scheme/docs/rfc" "*.txt"))
         (rfc-lines (car rfc-stats))
         (rfc-words (cdr rfc-stats))
         (ocaml-stats (let ((ml (count-lines-symbols "spki" "*.ml"))
                           (mli (count-lines-symbols "spki" "*.mli")))
                       (cons (+ (car ml) (car mli))
                             (+ (cdr ml) (cdr mli)))))
         (ocaml-lines (car ocaml-stats))
         (ocaml-symbols (cdr ocaml-stats))
         (scheme-stats (count-lines-symbols "spki/scheme" "*.scm"))
         (scheme-lines (car scheme-stats))
         (scheme-symbols (cdr scheme-stats))
         (assets (count-assets))
         (ratio-lines (if (> ocaml-lines 0)
                         (/ (exact->inexact scheme-lines) ocaml-lines)
                         0))
         (ratio-symbols (if (> ocaml-symbols 0)
                           (/ (exact->inexact scheme-symbols) ocaml-symbols)
                           0)))
    (log-info "--- Code Metrics ---")
    (log-info "RFCs: ~a lines, ~a words" rfc-lines rfc-words)
    (log-info "OCaml (TCB): ~a lines, ~a symbols" ocaml-lines ocaml-symbols)
    (log-info "Scheme: ~a lines, ~a symbols" scheme-lines scheme-symbols)
    (log-info "TCB is ~ax smaller by lines, ~ax smaller by symbols"
              (/ (round (* 10 ratio-lines)) 10)
              (/ (round (* 10 ratio-symbols)) 10))
    (log-info "~a assets comprise cyberspace" assets)
    (log-info "--------------------")))

(define (get-vault-metadata)
  "Get vault metadata if available"
  (let ((vault-dir (make-pathname *cyberspace-root* ".vault")))
    (if (directory-exists? vault-dir)
        (let ((releases-dir (make-pathname vault-dir "releases"))
              (audit-dir (make-pathname vault-dir "audit"))
              (metadata-dir (make-pathname vault-dir "metadata")))
          `((releases . ,(if (directory-exists? releases-dir)
                             (length (directory releases-dir))
                             0))
            (audit-entries . ,(if (directory-exists? audit-dir)
                                  (length (directory audit-dir))
                                  0))
            (metadata-files . ,(if (directory-exists? metadata-dir)
                                   (length (directory metadata-dir))
                                   0))))
        #f)))

(define (display-blob-metadata)
  "Display blob and repository metadata"
  (log-info "--- Blob Metadata ---")

  ;; Commit info
  (let ((commit (get-commit-info)))
    (when commit
      (log-info "HEAD: ~a ~a"
                (cdr (assq 'hash commit))
                (cdr (assq 'subject commit)))
      (log-info "Author: ~a @ ~a"
                (cdr (assq 'author commit))
                (cdr (assq 'date commit)))))

  ;; Repo stats
  (let ((stats (get-repo-stats)))
    (log-info "Objects: ~a commits, ~a branches, ~a tags"
              (cdr (assq 'commits stats))
              (cdr (assq 'branches stats))
              (cdr (assq 'tags stats))))

  ;; Vault metadata
  (let ((vault (get-vault-metadata)))
    (when vault
      (log-info "Vault: ~a releases, ~a audit entries, ~a metadata files"
                (cdr (assq 'releases vault))
                (cdr (assq 'audit-entries vault))
                (cdr (assq 'metadata-files vault)))))

  (log-info "---------------------"))

;;; --- Audit Trail ---

(define (write-sync-audit-entry status details)
  "Write an audit entry for sync operation"
  (let ((audit-dir (make-pathname *cyberspace-root* ".vault/audit")))
    ;; Create audit directory if needed
    (unless (directory-exists? audit-dir)
      (create-directory audit-dir #t))

    ;; Generate audit entry
    (let* ((ts (current-seconds))
           (entry-file (make-pathname audit-dir
                                      (sprintf "sync-~a.sexp" ts))))
      (call-with-output-file entry-file
        (lambda (port)
          (write
           `(audit-entry
             (type sync)
             (timestamp ,(timestamp))
             (epoch ,ts)
             (status ,status)
             (master ,*master-node*)
             (root ,*cyberspace-root*)
             (details ,@details)
             (commit ,(let ((c (get-commit-info)))
                       (if c (cdr (assq 'hash c)) "unknown"))))
           port)
          (newline port)))
      (log-info "Audit: sync recorded → ~a" entry-file))))

;;; --- Synchronization Stages ---

(define (sync-git-fetch)
  "Fetch latest changes from remote"
  (log-info "Fetching from master node: ~a..." *master-node*)
  (let ((result (git "fetch" *master-node*)))
    (if result
        (begin
          (log-info "Fetch complete")
          #t)
        #f)))

(define (sync-git-status)
  "Check if local branch is behind remote"
  (log-info "Checking synchronization status...")
  (let ((status (git "status" "-sb")))
    (if status
        (begin
          (log-info "Status: ~a" (string-trim-both status))
          (cond
           ((string-contains status "behind")
            (log-info "Local branch is behind remote")
            'behind)
           ((string-contains status "ahead")
            (log-info "Local branch is ahead of remote")
            'ahead)
           (else
            (log-info "Local branch is synchronized")
            'synced)))
        'unknown)))

(define (sync-git-pull)
  "Pull changes from remote if behind (stashes local changes first)"
  (log-info "Pulling changes from ~a/~a..." *master-node* *default-branch*)
  ;; Stash any local changes to avoid conflicts
  (let ((stash-result (git "stash" "--include-untracked" "-m" "sync-autostash")))
    (let ((had-stash (and stash-result
                          (not (string-contains stash-result "No local changes")))))
      (when had-stash
        (log-info "Stashed local changes"))
      (let ((result (git "pull" *master-node* *default-branch*)))
        ;; Restore stashed changes
        (when had-stash
          (let ((pop-result (git "stash" "pop")))
            (if (and pop-result (not (string-contains (or pop-result "") "CONFLICT")))
                (log-info "Restored local changes")
                (log-info "Note: stashed changes may need manual resolution"))))
        (if result
            (begin
              (log-info "Pull complete: ~a" (string-trim-both result))
              #t)
            #f)))))

(define (sync-submodules)
  "Update git submodules if present"
  (log-info "Checking for submodules...")
  (let ((has-submodules? (file-exists?
                          (make-pathname *cyberspace-root* ".gitmodules"))))
    (if has-submodules?
        (begin
          (log-info "Updating submodules...")
          (let ((result (git "submodule" "update" "--init" "--recursive")))
            (if result
                (begin
                  (log-info "Submodules updated")
                  #t)
                #f)))
        (begin
          (log-info "No submodules found")
          #t))))

(define (sync-sealed-releases)
  "Synchronize sealed releases if vault.scm is available"
  (log-info "Checking for sealed release system...")
  (let ((vault-path (make-pathname
                     (list *cyberspace-root* "spki" "scheme")
                     "vault.scm")))
    (if (file-exists? vault-path)
        (begin
          (log-info "Sealed release system found (vault.scm)")
          (log-info "To sync releases, use: (seal-synchronize \"remote\")")
          #t)
        (begin
          (log-info "No sealed release system found")
          #t))))

;;; --- Main Synchronization ---

(define (show-help)
  (display "sync - Global synchronization primitive for Cyberspace

Usage: sync [OPTIONS]

Synchronizes the entire Cyberspace repository with remote sources.

Options:
  --dry-run    Show what would be synced without making changes
  --quiet      Suppress informational messages
  --help       Show this help message

Philosophy:
  \"Rough consensus, cryptography, trusted systems and running code.\"

  This primitive ensures Cyberspace stays synchronized across machines
  and confederations of friends. It's the bootstrap mechanism for
  maintaining coherence.

Examples:
  sync              # Full synchronization
  sync --dry-run    # Preview what would be synced
  sync --quiet      # Silent operation

")
  (exit 0))

(define (sync-all)
  "Execute all synchronization stages"
  (log-info "========================================")
  (log-info "Starting global synchronization of Cyberspace")
  (log-info "Root: ~a" *cyberspace-root*)
  (log-info "Master: ~a" *master-node*)
  (log-info "========================================")

  ;; Display blob metadata before sync
  (display-blob-metadata)

  (let ((stages (list
                 (cons "Git Fetch" sync-git-fetch)
                 (cons "Git Status Check" sync-git-status)
                 (cons "Submodules" sync-submodules)
                 (cons "Sealed Releases" sync-sealed-releases)))
        (sync-details '()))

    (let loop ((remaining stages)
               (failed '())
               (details '()))
      (if (null? remaining)
          ;; All stages complete
          (begin
            ;; Display final blob metadata and code metrics
            (log-info "")
            (display-blob-metadata)
            (display-code-metrics)

            ;; Write audit entry
            (let ((status (if (null? failed) 'success 'partial-failure)))
              (write-sync-audit-entry status (reverse details)))

            (if (null? failed)
                (begin
                  (log-info "✓ Synchronization complete")
                  (exit 0))
                (begin
                  (log-error "✗ Some stages failed: ~a"
                            (string-intersperse (reverse failed) ", "))
                  (exit 1))))

          ;; Process next stage
          (let* ((stage (car remaining))
                 (name (car stage))
                 (proc (cdr stage)))
            (log-info "Stage: ~a" name)
            (let ((result (proc)))
              (cond
               ;; Special handling for status check
               ((and (eq? proc sync-git-status) (eq? result 'behind))
                (if (sync-git-pull)
                    (loop (cdr remaining) failed
                          (cons `(,name pulled) details))
                    (loop (cdr remaining) (cons name failed)
                          (cons `(,name pull-failed) details))))

               ;; Normal boolean result
               ((or (boolean? result) (eq? result 'synced) (eq? result 'ahead))
                (loop (cdr remaining)
                      (if result failed (cons name failed))
                      (cons `(,name ,(if result 'ok 'failed)) details)))

               ;; Unknown result
               (else
                (loop (cdr remaining) failed
                      (cons `(,name ,result) details))))))))))

;;; --- Entry Point ---

(define (main)
  (let ((args (command-line-arguments)))
    (cond
     ((member "--help" args)
      (show-help))

     (else
      (sync-all)))))

;; Run main
(main)
