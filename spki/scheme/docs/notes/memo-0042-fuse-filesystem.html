<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <title>Memo 0042: Wormholes</title>
  <link rel="icon" id="favicon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27%230f0%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>">
  <script>
(function(){
  var h=new Date().getHours(),c;
  if(h>=4&&h<6)c='%23845EC2';       // brahma muhurta - violet
  else if(h>=6&&h<8)c='%23ffd700';  // dawn - gold
  else if(h>=8&&h<11)c='%2300d4aa'; // morning - teal
  else if(h>=11&&h<14)c='%230f0';   // midday - phosphor
  else if(h>=14&&h<17)c='%2339ff14';// afternoon - neon
  else if(h>=17&&h<19)c='%23ff6600';// sunset - orange
  else if(h>=19&&h<22)c='%23ff3366';// evening - coral
  else c='%2300ffff';               // night - cyan
  document.getElementById('favicon').href='data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27'+c+'%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>';
})();
</script>
  <link rel="stylesheet" href="memo.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<h1>Memo 0042: Wormholes</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This Memo specifies wormholes—FUSE-based bidirectional portals between the macOS filesystem and the Library of Cyberspace vault. Wormholes preserve full metadata including extended attributes, Finder tags, and ACLs. All operations are auditable (Memo-003) and rate-limited (Memo-032).[^h1]</p>
<p>[^h1]: Historical: FUSE originated in Linux 2.6 (2005), inspired by earlier userspace filesystem work in Plan 9 and Hurd. macFUSE (originally MacFUSE) brought it to macOS in 2007. The abstraction outlived Apple's hostility.</p>
</section>
<section>
<h2>Motivation</h2>
<p>Users need seamless integration between their existing filesystem and the vault. Manual import/export creates friction and risks metadata loss.</p>
<p>A wormhole provides:</p>
<ul>
<li>Transparency - Finder, cp, rsync work unchanged</li>
<li>Bidirectionality - No separate sync step; it IS the filesystem</li>
<li>Metadata preservation - Full macOS attributes captured automatically</li>
<li>Content addressing - Deduplication and integrity built-in</li>
<li>Security - First-class Simple Public Key Infrastructure (SPKI) object with audit and rate-limit</li>
</ul>
<p>The filesystem abstraction is the right boundary—everything above it (apps, shell, Finder) works without modification.[^d1]</p>
<p>[^d1]: Design: FUSE inverts the usual model. Instead of teaching applications about vaults, we teach the vault to speak filesystem. Unix got this right: everything is a file.</p>
</section>
<section>
<h2>Wormhole as Security Object</h2>
<p>A wormhole is a first-class security object in cyberspace, subject to:[^d2]</p>
<ul>
<li>SPKI Authorization (Memo-004) — Opening requires valid certificate</li>
<li>Capability Delegation (Memo-021) — Wormhole access can be delegated</li>
<li>Audit Trail (Memo-003) — All operations logged</li>
<li>Rate Limiting (Memo-032) — Configurable ops/minute</li>
<li>Sandboxing (Memo-023) — Agents access wormholes through capabilities</li>
</ul>
<p>Wormholes bridge two security domains—the filesystem and the vault—making them inherently privileged operations. Treating wormholes as first-class security objects ensures that filesystem access remains under cryptographic control, not just ambient POSIX permissions.</p>
<p>[^d2]: Design: Wormholes are attack surface. Unrestricted filesystem access defeats vault security. Every wormhole must be explicitly authorized, continuously audited, and rate-limited against abuse.</p>
<h3>Wormhole Certificate</h3>
<pre class="language-scheme">
(define (wormhole-cert issuer fs-path vault-path permissions)
  "Create SPKI certificate authorizing wormhole"
  (create-cert
   issuer
   (wormhole-principal fs-path vault-path)
   `(tag (wormhole
          (fs-path ,fs-path)
          (vault-path ,vault-path)
          (permissions ,@permissions)   ; read, write, delete
          (rate-limit 1000)             ; ops/minute
          (expires ,(+ (current-seconds) 86400))))))
</pre>
<h3>Capability Model</h3>
<p>Wormholes support fine-grained capabilities:[^d3]</p>
<p>[^d3]: Design: Rich capabilities enable principle of least privilege. A backup agent needs read-only; a sync agent needs read-write but not delete. Capabilities compose—grant exactly what's needed.</p>
<p>Table 0: Wormhole Capabilities</p>
<table>
<tr><th>Capability </th><th>Allows </th></tr>
<tr><td>Data Access </td></tr>
<tr><td>read </td><td>Read file contents </td></tr>
<tr><td>write </td><td>Write/modify file contents </td></tr>
<tr><td>create </td><td>Create new files </td></tr>
<tr><td>delete </td><td>Remove files </td></tr>
<tr><td>rename </td><td>Rename/move files </td></tr>
<tr><td>Metadata </td></tr>
<tr><td>stat </td><td>Read POSIX attributes </td></tr>
<tr><td>chmod </td><td>Modify permissions </td></tr>
<tr><td>chown </td><td>Change ownership </td></tr>
<tr><td>xattr-read </td><td>Read extended attributes </td></tr>
<tr><td>xattr-write </td><td>Modify extended attributes </td></tr>
<tr><td>acl-read </td><td>Read ACLs </td></tr>
<tr><td>acl-write </td><td>Modify ACLs </td></tr>
<tr><td>Directory </td></tr>
<tr><td>readdir </td><td>List directory contents </td></tr>
<tr><td>mkdir </td><td>Create directories </td></tr>
<tr><td>rmdir </td><td>Remove directories </td></tr>
<tr><td>Control </td></tr>
<tr><td>admin </td><td>Configure wormhole </td></tr>
<tr><td>delegate </td><td>Delegate capabilities to others </td></tr>
<tr><td>audit-read </td><td>Read wormhole audit log </td></tr>
<tr><td>rate-limit </td><td>Modify rate limits </td></tr>
</table>
<h3>Capability Composition</h3>
<pre class="language-scheme">
;; Common capability sets (long form for readability)
(define capability:read-only
  '(read stat readdir xattr-read acl-read))

(define capability:read-write
  '(read write create stat chmod readdir mkdir xattr-read xattr-write))

(define capability:full
  '(read write create delete rename
    stat chmod chown
    xattr-read xattr-write acl-read acl-write
    readdir mkdir rmdir admin delegate audit-read rate-limit))

(define capability:backup
  '(read stat readdir xattr-read acl-read))

(define capability:synchronize
  '(read write create delete rename
    stat chmod readdir mkdir rmdir
    xattr-read xattr-write))
</pre>
<h3>Capability Attenuation</h3>
<p>Capabilities can only be reduced, never amplified:[^r1]</p>
<p>[^r1]: Research: Capability attenuation is fundamental to the object-capability model. See Miller, "Robust Composition" (2006). You cannot grant more authority than you possess.</p>
<pre class="language-scheme">
(define (wormhole-delegate wormhole new-caps recipient)
  "Delegate subset of wormhole capabilities"
  (let ((my-caps (wormhole-capabilities wormhole)))
    (unless (subset? new-caps my-caps)
      (error 'capability-amplification
             "Cannot delegate capabilities you don't have"))
    (wormhole-cert
     (wormhole-issuer wormhole)
     (wormhole-fs-path wormhole)
     (wormhole-vault-path wormhole)
     new-caps
     recipient: recipient)))
</pre>
<h3>Opening a Wormhole</h3>
<pre class="language-scheme">
(define (wormhole-open fs-path #!key (vault-path "/")
                                     (capabilities capability:read-write)
                                     (rate-limit 1000)
                                     (locked #f)
                                     (auth-required '())
                                     (certificate #f))
  "Open wormhole - requires valid certificate"
  (unless certificate
    (error 'unauthorized "Wormhole requires SPKI certificate"))
  (unless (verify-wormhole-cert certificate fs-path vault-path)
    (error 'unauthorized "Invalid wormhole certificate"))
  ;; Audit the open
  (wormhole-audit 'wormhole-open fs-path
                  `((vault ,vault-path)
                    (capabilities ,(length capabilities))))
  ;; Proceed with FUSE mount
  ...)
</pre>
<h3>Usage Examples</h3>
<pre class="language-scheme">
;; Basic read-write wormhole
(wormhole-open "~/Cyberspace")

;; Read-only wormhole for browsing
(wormhole-open "~/Archive" capabilities: capability:read-only)

;; Sync wormhole with rate limiting
(wormhole-open "~/Sync"
  capabilities: capability:synchronize
  rate-limit: 500)

;; Locked wormhole requiring unlock for sensitive operations
(wormhole-open "~/Secure"
  capabilities: capability:full
  locked: #t
  auth-required: '(delete admin))
</pre>
</section>
<section>
<h2>Architecture</h2>
<h3>Mount Topology</h3>
<pre class="diagram">
~/Cyberspace/                    ← FUSE mount point
├── documents/
│   ├── paper.pdf               ← Virtual file (content in vault)
│   └── notes.txt
├── projects/
│   └── cyberspace/
│       └── ...
└── .vault/                      ← Hidden, actual storage
    ├── objects/                 ← Content-addressed blobs
    │   ├── sha256:abc123...
    │   └── sha256:def456...
    ├── manifests/               ← Directory → file mappings
    └── metadata/                ← Per-file metadata store
</pre>
<h3>Component Stack</h3>
<pre class="diagram">
┌─────────────────────────────────────┐
│         Applications                │
│    (Finder, cp, rsync, etc.)        │
├─────────────────────────────────────┤
│         VFS (kernel)                │
├─────────────────────────────────────┤
│      FUSE-T / macFUSE               │
├─────────────────────────────────────┤
│    cyberspace-fuse daemon           │  ← Our code
├─────────────────────────────────────┤
│         Vault layer                 │
│   (content-address, metadata)       │
└─────────────────────────────────────┘
</pre>
</section>
<section>
<h2>Metadata Preservation</h2>
<h3>macOS Metadata Captured</h3>
<p>Table 1: Preserved Metadata</p>
<table>
<tr><th>Category </th><th>Attributes </th><th>Capture Method </th></tr>
<tr><td>POSIX </td><td>mode, uid, gid, size </td><td>stat() </td></tr>
<tr><td>Timestamps </td><td>mtime, atime, ctime, birthtime </td><td>stat() </td></tr>
<tr><td>Extended attrs </td><td>Finder info, tags, quarantine </td><td>listxattr(), getxattr() </td></tr>
<tr><td>Spotlight </td><td>kMDItem* metadata </td><td>mdls / MDItem API </td></tr>
<tr><td>ACLs </td><td>Access control lists </td><td>aclgetfile() </td></tr>
<tr><td>Flags </td><td>hidden, locked, immutable </td><td>chflags() / stat() </td></tr>
<tr><td>Resource fork </td><td>Legacy resource data </td><td>xattr com.apple.ResourceFork </td></tr>
</table>
<h3>Internal Representation</h3>
<pre class="language-scheme">
(define-record-type &lt;vault-file&gt;
  (make-vault-file path content-hash metadata)
  vault-file?
  (path vault-file-path)
  (content-hash vault-file-hash)
  (metadata vault-file-metadata))

(define (capture-metadata path)
  "Capture all macOS metadata for a file"
  `((posix
     (mode ,(file-mode path))
     (uid ,(file-uid path))
     (gid ,(file-gid path))
     (size ,(file-size path))
     (mtime ,(file-mtime path))
     (atime ,(file-atime path))
     (ctime ,(file-ctime path))
     (birthtime ,(file-birthtime path)))
    (xattr ,(capture-xattrs path))
    (flags ,(capture-flags path))
    (acl ,(capture-acl path))))
</pre>
<h3>Restoration</h3>
<pre class="language-scheme">
(define (restore-metadata path metadata)
  "Restore all metadata to a file"
  (let ((posix (alist-ref 'posix metadata))
        (xattr (alist-ref 'xattr metadata))
        (flags (alist-ref 'flags metadata))
        (acl (alist-ref 'acl metadata)))
    (restore-posix path posix)
    (restore-xattrs path xattr)
    (restore-flags path flags)
    (restore-acl path acl)))
</pre>
</section>
<section>
<h2>FUSE Operations</h2>
<h3>Required Operations</h3>
<p>Table 2: FUSE Operations</p>
<table>
<tr><th>Operation </th><th>Purpose </th><th>Vault Action </th></tr>
<tr><td>getattr </td><td>stat() </td><td>Return stored metadata </td></tr>
<tr><td>readdir </td><td>List directory </td><td>Read manifest </td></tr>
<tr><td>open </td><td>Open file </td><td>Validate hash exists </td></tr>
<tr><td>read </td><td>Read content </td><td>Fetch by content hash </td></tr>
<tr><td>write </td><td>Write content </td><td>Content-address, update manifest </td></tr>
<tr><td>create </td><td>Create file </td><td>Allocate manifest entry </td></tr>
<tr><td>unlink </td><td>Delete file </td><td>Remove from manifest (GC later) </td></tr>
<tr><td>mkdir </td><td>Create directory </td><td>Create manifest node </td></tr>
<tr><td>rmdir </td><td>Remove directory </td><td>Remove manifest node </td></tr>
<tr><td>rename </td><td>Move/rename </td><td>Update manifest path </td></tr>
<tr><td>setxattr </td><td>Set extended attr </td><td>Store in metadata </td></tr>
<tr><td>getxattr </td><td>Get extended attr </td><td>Retrieve from metadata </td></tr>
<tr><td>listxattr </td><td>List extended attrs </td><td>Enumerate metadata </td></tr>
</table>
<h3>Implementation Sketch</h3>
<pre class="language-scheme">
(define (fuse-getattr path)
  "Return file attributes from vault metadata"
  (let ((entry (manifest-lookup path)))
    (if entry
        (let ((meta (vault-file-metadata entry)))
          (make-stat
           (alist-ref 'mode (alist-ref 'posix meta))
           (alist-ref 'size (alist-ref 'posix meta))
           (alist-ref 'mtime (alist-ref 'posix meta))
           ...))
        -ENOENT)))

(define (fuse-read path size offset)
  "Read file content from vault"
  (let ((entry (manifest-lookup path))
         (hash (vault-file-hash entry))
         (content (vault-fetch hash)))
    (subbytes content offset (+ offset size))))

(define (fuse-write path data offset)
  "Write to file, content-address the result"
  (let ((entry (manifest-lookup path))
         (current (vault-fetch (vault-file-hash entry)))
         (updated (bytes-splice current offset data))
         (new-hash (content-address updated)))
    (manifest-update! path new-hash)
    (string-length data)))

(define (fuse-setxattr path name value)
  "Store extended attribute in vault metadata"
  (let ((entry (manifest-lookup path)))
    (metadata-set-xattr! entry name value)
    0))
</pre>
</section>
<section>
<h2>Content Addressing</h2>
<p>Files are stored by content hash (Memo-020):</p>
<pre class="language-scheme">
(define (content-address data)
  "Store data, return hash"
  (let* ((hash (sha256 data))
         (path (vault-object-path hash)))
    (unless (file-exists? path)
      (write-blob path data))
    hash))

(define (vault-fetch hash)
  "Retrieve data by hash"
  (read-blob (vault-object-path hash)))
</pre>
<p>Benefits: - Identical files stored once (deduplication) - Integrity verification on every read - Immutable objects enable safe caching</p>
</section>
<section>
<h2>Synchronization</h2>
<h3>Change Detection</h3>
<p>The FUSE layer captures all writes in real-time. No separate sync needed for local changes.</p>
<p>For multi-device sync, the manifest includes version vectors (Memo-012):</p>
<pre class="language-scheme">
(define (manifest-entry path hash metadata)
  `(entry
    (path ,path)
    (hash ,hash)
    (metadata ,metadata)
    (version-vector ,local-node ,lamport-clock)))
</pre>
<h3>Conflict Resolution</h3>
<p>When merging manifests from different devices (Memo-016 lazy clustering):</p>
<ul>
<li>Same hash - No conflict (identical content)</li>
<li>Different hash, one newer - Take newer</li>
<li>Different hash, concurrent - Conflict, apply lazy-resolve</li>
</ul>
<p>Content-addressing eliminates most conflicts at the object level; the manifest's version vectors resolve the remainder. Lazy clustering defers conflicts to user decision rather than attempting automatic resolution that may lose work.</p>
<pre class="language-scheme">
(define (merge-manifests local remote)
  (for-each
   (lambda (path)
     (let ((l (manifest-lookup local path))
           (r (manifest-lookup remote path)))
       (cond
        ((not l) (manifest-add! local r))
        ((not r) 'keep-local)
        ((equal? (vault-file-hash l) (vault-file-hash r)) 'identical)
        ((version-newer? r l) (manifest-update! local r))
        ((version-newer? l r) 'keep-local)
        (else (queue-conflict! path l r)))))
   (union (manifest-paths local) (manifest-paths remote))))
</pre>
</section>
<section>
<h2>Mount Commands</h2>
<h3>REPL Interface</h3>
<pre class="language-scheme">
(define (vault-mount point)
  "Mount vault at filesystem path"
  (fuse-main point
    `((getattr . ,fuse-getattr)
      (readdir . ,fuse-readdir)
      (open . ,fuse-open)
      (read . ,fuse-read)
      (write . ,fuse-write)
      (create . ,fuse-create)
      (unlink . ,fuse-unlink)
      (mkdir . ,fuse-mkdir)
      (rmdir . ,fuse-rmdir)
      (rename . ,fuse-rename)
      (setxattr . ,fuse-setxattr)
      (getxattr . ,fuse-getxattr)
      (listxattr . ,fuse-listxattr))))

(define (vault-unmount point)
  "Unmount vault filesystem"
  (fuse-unmount point))
</pre>
<h3>Command Line</h3>
<pre class="language-bash">
# Mount
cyberspace mount ~/Cyberspace

# Unmount
cyberspace unmount ~/Cyberspace

# Or via REPL
$ ./repl
&gt; (vault-mount "~/Cyberspace")
Mounted vault at /Users/ddp/Cyberspace
</pre>
</section>
<section>
<h2>macOS Integration</h2>
<h3>FUSE-T vs macFUSE</h3>
<p>Table 3: FUSE Implementation Options</p>
<table>
<tr><th>Feature </th><th>macFUSE </th><th>FUSE-T </th></tr>
<tr><td>Kernel extension </td><td>Yes (deprecated) </td><td>No </td></tr>
<tr><td>System extension </td><td>Optional </td><td>Uses NFS </td></tr>
<tr><td>SIP compatible </td><td>Requires disable </td><td>Yes </td></tr>
<tr><td>Performance </td><td>Better </td><td>Adequate </td></tr>
<tr><td>Maintenance </td><td>Active </td><td>Active </td></tr>
</table>
<p>FUSE-T recommended for new installations—no kernel extension required.[^i1]</p>
<p>[^i1]: Implementation: FUSE-T implements FUSE API over NFS loopback. Slightly higher latency but avoids Apple's kernel extension hostility.</p>
<h3>Installation</h3>
<pre class="language-bash">
# FUSE-T (recommended)
brew install fuse-t

# Or macFUSE (if kernel ext acceptable)
brew install macfuse
</pre>
<h3>Finder Integration</h3>
<p>The mount appears as a regular volume in Finder. Optional .VolumeIcon.icns for custom icon.</p>
<p>Spotlight indexing can be enabled by implementing getxattr for com.apple.FinderInfo and related Spotlight attributes.</p>
</section>
<section>
<h2>Information Flow Model</h2>
<p>Wormholes bridge two security domains—the macOS filesystem and the vault. This section makes the information flow semantics explicit.[^s1]</p>
<p>[^s1]: Security: Classic mandatory access control (Bell-LaPadula, Biba) uses security labels and lattice-based flow rules. We choose a simpler model: capability attenuation at the boundary, no lattice, no mandatory labels.</p>
<h3>Vault-Authoritative</h3>
<p>The vault is the source of truth. The filesystem mount is a capability-constrained view of vault contents, not a peer. Writes are ingested into the vault's content-addressed store; reads retrieve content by hash. The filesystem namespace is a manifest overlay. Unmounted, the projection vanishes; the vault remains.</p>
<h3>Bidirectional by Default</h3>
<p>Unless capabilities restrict it, data flows both ways through the wormhole. A read-only capability creates a one-way flow (vault→filesystem); a write-only capability creates the reverse (filesystem→vault, the dropbox pattern). The default read+write permits bidirectional flow.</p>
<h3>No Implicit Labels</h3>
<p>Unlike VMS security classifications, vault objects carry no mandatory security labels. Flow control is purely through capability attenuation at the wormhole boundary.[^s2]</p>
<p>[^s2]: Security: Mandatory labels require a trusted labeling authority and policy engine. We avoid this complexity. The tradeoff: no automatic "top secret can't flow to unclassified" enforcement. If an application requires labeled objects with mandatory flow rules, it must implement them at a layer above the wormhole.</p>
<p>The deeper rationale is human factors: labels are cognitively hostile. SELinux is technically sound but practically disabled on most systems because administrators cannot reason about label propagation correctly. Capabilities are intuitive—"I have this, I can use it, I can delegate a subset"—requiring no classification decisions and producing no "why can't I access my own file" mysteries.[^s2a]</p>
<p>[^s2a]: Security: Experience with deployed MAC systems (SEVMS, SELinux, Windows MIC) shows that label complexity defeats usability. SEVMS was a layered product on VMS providing B1-level security classifications—powerful but rarely deployed outside government contracts. Users misconfigure labels, administrators disable enforcement, and the security model exists only on paper. Capability attenuation succeeds because it matches human intuition about possession and delegation.</p>
<h3>Audit as Flow Record</h3>
<p>Every crossing (read or write) is logged. The audit trail IS the flow history. Post-hoc analysis can reconstruct what data moved through which wormholes, when, and under what authority.</p>
<p>This is the key assurance property: you cannot prove that information didn't flow (covert channels exist in any real system), but you can prove what DID flow and reconstruct the path post-hoc. The audit trail provides accountability rather than prevention—a pragmatic tradeoff that scales to real-world use.[^s3]</p>
<p>[^s3]: Security: Mandatory access control aims to prevent unauthorized flows. We aim to detect and attribute them. Prevention requires trusting the entire stack; detection requires only trusting the audit log. For most threat models, accountable flow is sufficient.</p>
<p>Audit is orthogonal to authorization. The capability check determines what is permitted; audit records what occurred. The audit trail is never consulted to decide whether to allow an operation—only to reconstruct flow history after the fact.</p>
<h3>Capability as Flow Constraint</h3>
<p>Table 4: Capability and Information Flow</p>
<table>
<tr><th>Capabilities </th><th>Flow Direction </th><th>Pattern </th></tr>
<tr><td>read without write </td><td>vault→filesystem only </td><td>Browse, export </td></tr>
<tr><td>write without read </td><td>filesystem→vault only </td><td>Dropbox, ingest </td></tr>
<tr><td>read+write </td><td>bidirectional </td><td>Full sync </td></tr>
<tr><td>neither </td><td>no data flow </td><td>Metadata-only mount </td></tr>
</table>
<h3>Reference Monitor</h3>
<p>The wormhole acts as a reference monitor at the domain boundary. Every operation crosses the monitor, which validates capability, enforces rate limits (Memo-032), and records the audit trail (Memo-003). The monitor is complete (all crossings pass through it) and verifiable (audit enables post-hoc analysis).</p>
<pre class="language-scheme">
(define (wormhole-flow-guard wormhole operation object)
  "Reference monitor for wormhole operations"
  (let ((caps (wormhole-capabilities wormhole)))
    (unless (memq operation caps)
      (wormhole-audit 'denied operation object)
      (error 'capability-denied operation))
    (unless (rate-limit-ok? wormhole)
      (wormhole-audit 'rate-limited operation object)
      (error 'rate-limited))
    (wormhole-audit 'permitted operation object)
    `(permitted ,operation ,object)))
</pre>
</section>
<section>
<h2>Security Considerations</h2>
<h3>Permissions</h3>
<p>FUSE daemon runs as user, not root. Respects vault ACLs.</p>
<h3>Content Integrity</h3>
<p>Every read verifies content hash. Corruption detected immediately.</p>
<h3>Metadata Trust</h3>
<p>Metadata is stored separately from content. A compromised metadata store cannot alter file contents (hashes won't match).</p>
<h3>Mount Security</h3>
<pre class="language-scheme">
(define (vault-mount point #!key (allow-other #f))
  ;; allow-other permits other users to access mount
  ;; Default: owner only
  ...)
</pre>
</section>
<section>
<h2>Dependencies</h2>
<table>
<tr><th>Component </th><th>Purpose </th></tr>
<tr><td>FUSE-T or macFUSE </td><td>Userspace filesystem </td></tr>
<tr><td>libfuse </td><td>FUSE library </td></tr>
<tr><td>Scheme FFI </td><td>Bindings to libfuse </td></tr>
</table>
</section>
<section>
<h2>References</h2>
<ul>
<li>Memo-012: Lamport Clocks</li>
<li>Memo-016: Lazy Clustering</li>
<li>Memo-020: Content-Addressed Storage</li>
<li>FUSE documentation: https://libfuse.github.io/</li>
<li>FUSE-T: https://github.com/macos-fuse-t/fuse-t</li>
</ul>
</section>
<section>
<h2>Changelog</h2>
<ul>
<li>2026-01-07</li>
<li>Initial specification</li>
</ul>
</section>
<script>
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
}
(function() {
  // Query param override (for REPL: ?theme=dark or ?theme=light)
  const params = new URLSearchParams(window.location.search);
  const param = params.get('theme');
  if (param === 'dark' || param === 'light') {
    document.documentElement.setAttribute('data-theme', param);
    localStorage.setItem('theme', param);
    return;
  }
  // localStorage preference
  const saved = localStorage.getItem('theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
  } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script>
</body>
</html>
