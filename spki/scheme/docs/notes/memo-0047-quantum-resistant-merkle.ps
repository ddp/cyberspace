%!PS-Adobe-3.0
%%Title: memo-0047-quantum-resistant-merkle
%%Creator: Library of Cyberspace Memo Pipeline
%%Pages: (atend)
%%EndComments

/Courier findfont 10 scalefont setfont
/margin 72 def
/pagewidth 612 def
/pageheight 792 def
/leading 12 def
/topmargin pageheight margin sub def
/bottommargin margin def
/linewidth pagewidth margin 2 mul sub def
/ypos topmargin def
/pagenum 1 def

/newline {
  /ypos ypos leading sub def
  ypos bottommargin lt {
    showpage
    /pagenum pagenum 1 add def
    /ypos topmargin def
  } if
  margin ypos moveto
} def

margin topmargin moveto
(Memo 047: Quantum-Resistant Merkle Trees) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
() show newline
(------------------------------------------------------------------------) show newline
(ABSTRACT) show newline
(------------------------------------------------------------------------) show newline
() show newline
(SHA-512 won't survive. Grover's algorithm halves the effective security) show newline
(- 256 bits becomes 128. For the wilderness of mirrors to endure the) show newline
(quantum winter, we need quantum-resistant Merkle trees. This Memo) show newline
(specifies the transition from flat SHA-512 hashes to tree-structured) show newline
(SHAKE256 hashes.) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(THE PROBLEM) show newline
(------------------------------------------------------------------------) show newline
() show newline
(Current cyberspace object identity:) show newline
() show newline
() show newline
(    sha512\(content\) > 64 bytes > object address) show newline
() show newline
(Against a quantum computer with Grover's algorithm: - Classical) show newline
(security: 256 bits - Quantum security: 128 bits \(square root\)) show newline
() show newline
(128 bits may be acceptable for some threat models, but cyberspace is) show newline
(built to last. The Library of Alexandria burned once. We won't let) show newline
(quantum computers burn it again.) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(THE SOLUTION: MERKLE TREES) show newline
(------------------------------------------------------------------------) show newline
() show newline
(Instead of hashing content as a flat blob, structure it as a tree:) show newline
() show newline
() show newline
(                        +-----------------+) show newline
(                        |   Merkle Root   |  < Object identity) show newline
(                        |  shake256\(...\)  |) show newline
(                        +--------+--------+) show newline
(                                 |) show newline
(                  +--------------+--------------+) show newline
(                  |              |              |) show newline
(             +----v----+    +----v----+    +----v----+) show newline
(             | Node 0  |    | Node 1  |    | Node 2  |) show newline
(             +----+----+    +----+----+    +----+----+) show newline
(                  |              |              |) show newline
(            +-----+-----+  +-----+-----+  +-----+-----+) show newline
(            |           |  |           |  |           |) show newline
(        +---v---+ +---v---+ +---v---+ +---v---+ +---v---+ ...) show newline
(        |Chunk 0| |Chunk 1| |Chunk 2| |Chunk 3| |Chunk 4|) show newline
(        | 4 KB  | | 4 KB  | | 4 KB  | | 4 KB  | | 4 KB  |) show newline
(        +-------+ +-------+ +-------+ +-------+ +-------+) show newline
() show newline
(Benefits:) show newline
() show newline
(1. Incremental updates - Change one chunk, rehash one branch 2.) show newline
(Selective disclosure - Prove a chunk exists without revealing siblings) show newline
(3. Streaming verification - Verify chunks as they arrive 4.) show newline
(Parallelizable - Hash chunks concurrently 5. Quantum-resistant -) show newline
(SHAKE256 at every node) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(HASH FUNCTION: SHAKE256) show newline
(------------------------------------------------------------------------) show newline
() show newline
(SHAKE256 is an extendable-output function \(XOF\) from the SHA-3 \(Keccak\)) show newline
(family.) show newline
() show newline
(Why SHAKE256:) show newline
() show newline
() show newline
(  Property         Value                                             ) show newline
(  Security level   256-bit classical, 128-bit quantum                ) show newline
(  Output length    Variable \(we use 256 bits\)                        ) show newline
(  Construction     Sponge \(different from SHA-2's Merkle-DamgÃ¥rd\)   ) show newline
(  Standard         NIST FIPS 202                                     ) show newline
(  Used by          SPHINCS+ \(post-quantum signatures\)                ) show newline
(  In libsodium     No, but in OpenSSL, libgcrypt                     ) show newline
() show newline
(Alternative: BLAKE3) show newline
() show newline
() show newline
(  Property         Value                                ) show newline
(  Security level   256-bit classical, 128-bit quantum   ) show newline
(  Output length    Variable                             ) show newline
(  Construction     Merkle tree internally               ) show newline
(  Speed            Very fast, SIMD optimized            ) show newline
(  Standard         Not NIST, but widely trusted         ) show newline
() show newline
(BLAKE3 is faster and already tree-structured, but SHAKE256 has NIST) show newline
(blessing. We support both.) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(OBJECT FORMAT) show newline
(------------------------------------------------------------------------) show newline
() show newline
() show newline
(Current \(Legacy\)) show newline
(----------------) show newline
() show newline
() show newline
(    \(object) show newline
(      \(hash "sha512:3a7bd3e2c4f8..."\)) show newline
(      \(size 1048576\)) show newline
(      \(content ...\)\)) show newline
() show newline
() show newline
(Quantum-Resistant) show newline
(-----------------) show newline
() show newline
() show newline
(    \(object) show newline
(      \(merkle-root "shake256:7f4a2b9c..."\)) show newline
(      \(hash-algorithm "shake256"\)          ; or "blake3") show newline
(      \(tree-params) show newline
(        \(chunk-size 4096\)                  ; 4 KB chunks) show newline
(        \(fanout 16\)                        ; Children per node) show newline
(        \(depth 4\)\)                         ; Tree depth) show newline
(      \(size 1048576\)) show newline
(      \(content ...\)\)) show newline
() show newline
() show newline
(Transition Period \(Dual Hash\)) show newline
(-----------------------------) show newline
() show newline
() show newline
(    \(object) show newline
(      \(hash "sha512:3a7bd3e2c4f8..."\)           ; Legacy - for old clients) show newline
(      \(merkle-root "shake256:7f4a2b9c..."\)      ; Quantum-resistant) show newline
(      \(hash-algorithm "shake256"\)) show newline
(      \(tree-params) show newline
(        \(chunk-size 4096\)) show newline
(        \(fanout 16\)) show newline
(        \(depth 4\)\)) show newline
(      \(size 1048576\)) show newline
(      \(content ...\)\)) show newline
() show newline
(Old clients use hash. New clients use merkle-root. Both verify the same) show newline
(content.) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(TREE CONSTRUCTION) show newline
(------------------------------------------------------------------------) show newline
() show newline
() show newline
(Algorithm) show newline
(---------) show newline
() show newline
() show newline
(    \(define \(merkle-hash content algorithm chunk-size fanout\)) show newline
(      "Build Merkle tree, return root hash") show newline
(      ;; 1. Split content into chunks) show newline
(      \(let* \(\(chunks \(chunk-content content chunk-size\)\)) show newline
(             ;; 2. Hash each chunk \(leaves\)) show newline
(             \(leaves \(map \(lambda \(chunk\)) show newline
(                            \(hash algorithm chunk\)\)) show newline
(                          chunks\)\)) show newline
(             ;; 3. Build tree bottom-up) show newline
(             \(root \(build-tree leaves fanout algorithm\)\)\)) show newline
(        root\)\)) show newline
(    \(define \(build-tree nodes fanout algorithm\)) show newline
(      "Combine nodes into parent nodes until one root remains") show newline
(      \(if \(<= \(length nodes\) 1\)) show newline
(          \(car nodes\)) show newline
(          \(let \(\(parents \(map \(lambda \(group\)) show newline
(                                \(hash algorithm \(apply append group\)\)\)) show newline
(                              \(partition nodes fanout\)\)\)\)) show newline
(            \(build-tree parents fanout algorithm\)\)\)\)) show newline
() show newline
() show newline
(Node Hashing) show newline
(------------) show newline
() show newline
(Each internal node hashes the concatenation of its children:) show newline
() show newline
() show newline
(    nodehash = shake256\(child0 || child1 || ... || childn\)) show newline
() show newline
(For leaves:) show newline
() show newline
() show newline
(    leafhash = shake256\(chunkdata\)) show newline
() show newline
() show newline
(Canonical Parameters) show newline
(--------------------) show newline
() show newline
() show newline
(  Parameter       Default    Notes                             ) show newline
(  chunk-size      4096       4 KB, filesystem-friendly         ) show newline
(  fanout          16         Balance between depth and width   ) show newline
(  algorithm       shake256   NIST approved                     ) show newline
(  output-length   32         256 bits                          ) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(PROOFS) show newline
(------------------------------------------------------------------------) show newline
() show newline
() show newline
(Inclusion Proof) show newline
(---------------) show newline
() show newline
(Prove a chunk is part of an object without revealing other chunks:) show newline
() show newline
() show newline
(    \(inclusion-proof) show newline
(      \(merkle-root "shake256:7f4a2b9c..."\)) show newline
(      \(chunk-index 42\)) show newline
(      \(chunk-hash "shake256:abc123..."\)) show newline
(      \(path) show newline
(        \(\(sibling "shake256:def456..." position left\)) show newline
(         \(sibling "shake256:789abc..." position right\)) show newline
(         \(sibling "shake256:012def..." position left\)\)\)\)) show newline
() show newline
(Verifier reconstructs path to root:) show newline
() show newline
() show newline
(    chunk_hash > combine with sibling > ... > must equal merkle-root) show newline
() show newline
() show newline
(Exclusion Proof) show newline
(---------------) show newline
() show newline
(Prove a chunk does NOT exist \(for sparse objects\):) show newline
() show newline
() show newline
(    \(exclusion-proof) show newline
(      \(merkle-root "shake256:7f4a2b9c..."\)) show newline
(      \(chunk-index 999\)) show newline
(      \(boundary-left 998 "shake256:left..."\)) show newline
(      \(boundary-right 1000 "shake256:right..."\)) show newline
(      \(path ...\)\)) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(STREAMING VERIFICATION) show newline
(------------------------------------------------------------------------) show newline
() show newline
(Large objects can be verified chunk-by-chunk as they stream:) show newline
() show newline
() show newline
(    \(define \(verify-stream merkle-root chunk-size\)) show newline
(      "Return a verifier that checks chunks as they arrive") show newline
(      \(let \(\(received-chunks '\(\)\)) show newline
(            \(verified-nodes \(make-hash-table\)\)\)) show newline
(        \(lambda \(chunk-index chunk-data proof\)) show newline
(          ;; Verify this chunk against the proof) show newline
(          \(let \(\(chunk-hash \(shake256 chunk-data\)\)\)) show newline
(            \(if \(verify-inclusion-proof merkle-root chunk-index chunk-hash proof\)) show newline
(                \(begin) show newline
(                  \(cache-verified-node! verified-nodes chunk-index chunk-hash\)) show newline
(                  #t\)) show newline
(                #f\)\)\)\)\)) show newline
() show newline
(You don't need the whole object to start verifying. Each chunk carries) show newline
(its own proof.) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(THE FOREST) show newline
(------------------------------------------------------------------------) show newline
() show newline
(The soup becomes a forest of Merkle trees:) show newline
() show newline
() show newline
(    +-----------------------------------------------------------------+) show newline
(    |                    THE FOREST \(formerly soup\)                    |) show newline
(    |                                                                  |) show newline
(    |     ðŸŒ² obj    ðŸŒ² obj       +-----------------+      ðŸŒ² obj       |) show newline
(    |          ðŸŒ² obj           |â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘|           ðŸŒ² obj  |) show newline
(    |    ðŸŒ² obj          ðŸŒ² obj |â–‘â–‘â–‘  REALM  â–‘â–‘â–‘â–‘â–‘|    ðŸŒ² obj         |) show newline
(    |         ðŸŒ² obj            |â–‘â–‘â–‘ \(island\) â–‘â–‘â–‘â–‘|         ðŸŒ² obj    |) show newline
(    |   ðŸŒ² obj       ðŸŒ² obj     |â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘|  ðŸŒ² obj           |) show newline
(    |        ðŸŒ² obj             +-----------------+       ðŸŒ² obj      |) show newline
(    |                                                                  |) show newline
(    |   Each object a tree. Each tree quantum-hardened.               |) show newline
(    +-----------------------------------------------------------------+) show newline
() show newline
(Objects are trees. The wilderness of mirrors becomes a forest. Agents) show newline
(navigate between trees, climbing branches, verifying paths. The) show newline
(capability chain is still their thread - but now the mirrors are) show newline
(structured.) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(MIGRATION) show newline
(------------------------------------------------------------------------) show newline
() show newline
() show newline
(Phase 1: Dual Hash \(Now â†’ Q-Day - 5 years\)) show newline
(--------------------------------------------) show newline
() show newline
(All new objects get both hashes. Old objects rehashed on access.) show newline
() show newline
() show newline
(    \(define \(store-object content\)) show newline
(      \(let \(\(legacy-hash \(sha512 content\)\)) show newline
(            \(merkle-root \(merkle-hash content 'shake256 4096 16\)\)\)) show newline
(        \(vault-store) show newline
(          `\(object) show newline
(            \(hash ,\(string-append "sha512:" legacy-hash\)\)) show newline
(            \(merkle-root ,\(string-append "shake256:" merkle-root\)\)) show newline
(            ...\)\)\)\)) show newline
() show newline
() show newline
(Phase 2: Merkle Primary \(Q-Day - 5 years â†’ Q-Day\)) show newline
(---------------------------------------------------) show newline
() show newline
(Merkle root becomes the canonical address. SHA-512 kept for) show newline
(compatibility.) show newline
() show newline
() show newline
(Phase 3: Legacy Sunset \(Q-Day â†’ Q-Day + 2 years\)) show newline
(--------------------------------------------------) show newline
() show newline
(SHA-512 hashes deprecated. Only Merkle roots used for addressing.) show newline
() show newline
() show newline
(Phase 4: Pure Quantum-Resistant \(Q-Day + 2 years â†’\)) show newline
(-----------------------------------------------------) show newline
() show newline
(SHA-512 hashes removed from new objects. Legacy objects retain both for) show newline
(historical verification.) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(PERFORMANCE) show newline
(------------------------------------------------------------------------) show newline
() show newline
() show newline
(  Operation             SHA-512 \(flat\)   SHAKE256 \(Merkle\)   Notes             ) show newline
(  Hash 1 MB             2 ms             3 ms                Slightly slower   ) show newline
(  Hash 1 GB             2000 ms          2500 ms             Tree overhead     ) show newline
(  Update 4 KB in 1 GB   2000 ms          15 ms               Merkle wins       ) show newline
(  Prove inclusion       N/A              0.1 ms              New capability    ) show newline
(  Streaming verify      N/A              Per-chunk           New capability    ) show newline
() show newline
(The overhead is small. The benefits are large.) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(SECURITY CONSIDERATIONS) show newline
(------------------------------------------------------------------------) show newline
() show newline
() show newline
(Grover's Algorithm) show newline
(------------------) show newline
() show newline
(Grover's algorithm provides quadratic speedup for searching: - SHA-512:) show newline
(2^256 > 2^128 quantum operations - SHAKE256-256: 2^256 > 2^128 quantum) show newline
(operations) show newline
() show newline
(128-bit quantum security is considered sufficient for the foreseeable) show newline
(future.) show newline
() show newline
() show newline
(Second Preimage Resistance) show newline
(--------------------------) show newline
() show newline
(Finding another input that hashes to the same tree requires: -) show newline
(Classical: 2^256 operations - Quantum: 2^128 operations \(Grover\)) show newline
() show newline
() show newline
(Tree Structure Attacks) show newline
(----------------------) show newline
() show newline
(The Merkle tree structure must prevent: - Length extension: SHAKE256) show newline
(immune \(sponge construction\) - Subtree collision: Domain separation in) show newline
(node hashing - Malleability: Canonical serialization required) show newline
() show newline
() show newline
(Implementation) show newline
(--------------) show newline
() show newline
() show newline
(    ;; Domain separation for nodes vs leaves) show newline
(    \(define \(hash-leaf algorithm chunk\)) show newline
(      \(hash algorithm \(bytevector-append #u8\(0\) chunk\)\)\)) show newline
(    \(define \(hash-node algorithm children\)) show newline
(      \(hash algorithm \(bytevector-append #u8\(1\) \(apply bytevector-append children\)\)\)\)) show newline
() show newline
(The 0x00 prefix for leaves and 0x01 for nodes prevents a leaf from being) show newline
(interpreted as a node.) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(INVARIANTS) show newline
(------------------------------------------------------------------------) show newline
() show newline
() show newline
(    M1. Object identity is Merkle root) show newline
(        id\(o\) = merkle-root\(shake256, chunks\(o\)\)) show newline
(    M2. Any chunk is provable) show newline
(        chunk\(o,i\) > âˆƒproof: verify\(root\(o\), i, chunk, proof\)) show newline
(    M3. Tree structure is canonical) show newline
(        tree\(content, params\) is deterministic) show newline
(    M4. Dual hashes are consistent) show newline
(        sha512\(content\) â†” merkle-root\(content\) verify same content) show newline
(    M5. Migration preserves identity) show newline
(        old-objects retain verifiable legacy hashes) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(REFERENCES) show newline
(------------------------------------------------------------------------) show newline
() show newline
(1. NIST FIPS 202 - SHA-3 Standard \(SHAKE256\) 2. BLAKE3 specification -) show newline
(https://github.com/BLAKE3-team/BLAKE3 3. Merkle, R., "A Digital) show newline
(Signature Based on a Conventional Encryption Function", 1987 4. Grover,) show newline
(L., "A Fast Quantum Mechanical Algorithm for Database Search", 1996 5.) show newline
(Memo-040 - Cyberspace Security Architecture) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(CHANGELOG) show newline
(------------------------------------------------------------------------) show newline
() show newline
(  * 2026-01-08) show newline
(  * Initial draft) show newline
() show newline
(------------------------------------------------------------------------) show newline

showpage
%%Trailer
%%Pages: pagenum
%%EOF
