<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <title>Memo 0039: Realm Roles and Capabilities</title>
  <link rel="icon" id="favicon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27%230f0%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>">
  <script>
(function(){
  var h=new Date().getHours(),c;
  if(h>=4&&h<6)c='%23845EC2';       // brahma muhurta - violet
  else if(h>=6&&h<8)c='%23ffd700';  // dawn - gold
  else if(h>=8&&h<11)c='%2300d4aa'; // morning - teal
  else if(h>=11&&h<14)c='%230f0';   // midday - phosphor
  else if(h>=14&&h<17)c='%2339ff14';// afternoon - neon
  else if(h>=17&&h<19)c='%23ff6600';// sunset - orange
  else if(h>=19&&h<22)c='%23ff3366';// evening - coral
  else c='%2300ffff';               // night - cyan
  document.getElementById('favicon').href='data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27'+c+'%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>';
})();
</script>
  <link rel="stylesheet" href="memo.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<p class="format-notice"><em>For pixel-perfect diagrams: <a href="memo-0039-node-roles.ps">PostScript</a> or <a href="memo-0039-node-roles.pdf">PDF</a></em></p>
<h1>Memo 0039: Realm Roles and Capabilities</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This Memo defines functional roles for nodes in a Library of Cyberspace confederation based on compute, storage, network, and security capabilities. Roles determine what operations a node can perform and how it participates in the distributed system.</p>
</section>
<section>
<h2>Terminology</h2>
<p>Realm: A node's place in cyberspace. A realm encompasses: - The node's vault (local content-addressed object store) - The node's principal (Ed25519 identity) - The node's capabilities (hardware, network, security) - The node's objects (what it stores and serves)</p>
<p>A realm is local-first and sovereign. The node controls what to share, who to trust, what to replicate. When nodes federate, their realms overlap - objects flow between them according to trust relationships.</p>
<p>The hardware manifest stored at .vault/node-hardware declares what kind of place this realm occupies in cyberspace.</p>
</section>
<section>
<h2>Motivation</h2>
<p>Memo-010 (Federation Protocol) defines trust relationships between peers (publisher, subscriber, peer). However, it does not address functional capabilities - what operations each node can actually perform based on its hardware and network constraints.</p>
<p>A Raspberry Pi on a solar-powered satellite uplink has different capabilities than a rack-mounted server in a datacenter. The system should:</p>
<ul>
<li>Self-assess - Nodes should know their own capabilities</li>
<li>Declare - Nodes should advertise their role to peers</li>
<li>Adapt - Operations should degrade gracefully based on available roles</li>
<li>Persist - Role assignments should survive restarts</li>
</ul>
<p>Automatic role detection enables heterogeneous hardware to participate appropriately without manual configuration.</p>
<p>Without explicit role management, the system either assumes all nodes are equal or requires manual configuration; neither scales.</p>
</section>
<section>
<h2>Node Roles</h2>
<h3>Role Hierarchy</h3>
<pre class="diagram">
                    ┌─────────────┐
                    │ COORDINATOR │  Byzantine consensus, threshold signing
                    │   (rare)    │  Always-on, high compute
                    └──────┬──────┘
                           │
              ┌────────────┼────────────┐
              ▼            ▼            ▼
       ┌───────────┐ ┌───────────┐ ┌───────────┐
       │   FULL    │ │  WITNESS  │ │ ARCHIVER  │
       │   NODE    │ │           │ │           │
       └─────┬─────┘ └───────────┘ └───────────┘
             │
             ▼
       ┌───────────┐
       │   EDGE    │  Read-only, mobile, intermittent
       └───────────┘
</pre>
<h3>Role Definitions</h3>
<table>
<tr><th>Role </th><th>Compute </th><th>Storage </th><th>Network </th><th>Operations </th></tr>
<tr><td>coordinator </td><td>High </td><td>Medium </td><td>Always-on </td><td>Byzantine consensus, threshold signing, key ceremony </td></tr>
<tr><td>full </td><td>Medium </td><td>High </td><td>Reliable </td><td>All vault operations, replication origin </td></tr>
<tr><td>witness </td><td>Low </td><td>High </td><td>Intermittent </td><td>Passive storage, hash verification, audit </td></tr>
<tr><td>archiver </td><td>Low </td><td>Maximum </td><td>Batch </td><td>Cold storage, offline preservation </td></tr>
<tr><td>edge </td><td>Minimal </td><td>Minimal </td><td>Sporadic </td><td>Read-only sync, mobile access </td></tr>
</table>
<h3>Capability Requirements</h3>
<pre class="language-scheme">
(node-role-capabilities
  (coordinator
    (compute    (min-cores 4) (min-ram-gb 8))
    (storage    (min-gb 100) (type ssd))
    (network    (uptime 0.99) (latency-ms 50))
    (security   (hsm optional) (secure-enclave optional)))

  (full
    (compute    (min-cores 2) (min-ram-gb 4))
    (storage    (min-gb 500) (type any))
    (network    (uptime 0.95) (latency-ms 200))
    (security   (signing-key required)))

  (witness
    (compute    (min-cores 1) (min-ram-gb 1))
    (storage    (min-gb 100) (type any))
    (network    (uptime 0.50) (latency-ms 1000))
    (security   (verify-key required)))

  (archiver
    (compute    (min-cores 1) (min-ram-gb 512mb))
    (storage    (min-gb 1000) (type cold))
    (network    (uptime 0.10) (batch-ok #t))
    (security   (verify-key required) (offline-ok #t)))

  (edge
    (compute    (min-cores 1) (min-ram-gb 256mb))
    (storage    (min-gb 1) (type any))
    (network    (uptime 0.01) (latency-ms 5000))
    (security   (read-only #t))))
</pre>
</section>
<section>
<h2>Role Detection</h2>
<h3>Automatic Probing</h3>
<pre class="language-scheme">
(define (node-probe-capabilities)
  "Probe local system capabilities"
  `((compute
     (cores ,(get-cpu-cores))
     (ram-gb ,(get-ram-gb))
     (load-avg ,(get-load-average)))
    (storage
     (available-gb ,(get-available-storage))
     (type ,(detect-storage-type)))
    (network
     (latency-ms ,(probe-network-latency))
     (bandwidth-mbps ,(estimate-bandwidth))
     (type ,(detect-network-type)))  ; ethernet, wifi, cellular, satellite
    (security
     (signing-key ,(has-signing-key?))
     (verify-key ,(has-verify-key?))
     (hsm ,(has-hsm?)))))
</pre>
<h3>Role Assignment</h3>
<pre class="language-scheme">
(define (node-assign-role capabilities)
  "Assign role based on probed capabilities"
  (let ((compute (assq 'compute capabilities))
        (storage (assq 'storage capabilities))
        (network (assq 'network capabilities)))
    (cond
     ;; Coordinator: high everything
     ((and (&gt;= (get-cores compute) 4)
           (&gt;= (get-ram compute) 8)
           (&lt;= (get-latency network) 50))
      'coordinator)

     ;; Full node: medium compute, high storage
     ((and (&gt;= (get-cores compute) 2)
           (&gt;= (get-storage storage) 500))
      'full)

     ;; Archiver: low compute, massive storage, batch network
     ((and (&gt;= (get-storage storage) 1000)
           (eq? (get-network-type network) 'batch))
      'archiver)

     ;; Witness: low compute, decent storage
     ((&gt;= (get-storage storage) 100)
      'witness)

     ;; Edge: everything else
     (else 'edge))))
</pre>
</section>
<section>
<h2>Role Declaration</h2>
<h3>Local Configuration</h3>
<pre class="language-scheme">
;; ~/.cyberspace/node-role
(node-config
  (role witness)                    ; Declared role
  (auto-detect #f)                  ; Don't override with probed
  (capabilities                     ; Known constraints
    (network (type satellite)
             (latency-ms 600)
             (bandwidth-mbps 100))))
</pre>
<h3>Role Announcement</h3>
<pre class="language-scheme">
(define (node-announce-role)
  "Announce role to federation peers"
  (let ((role (node-current-role))
        (caps (node-probe-capabilities))
        (key (vault-config 'signing-key)))
    (when key
      (let ((announcement
             `(node-role-announcement
               (principal ,(get-vault-principal key))
               (role ,role)
               (capabilities ,caps)
               (timestamp ,(current-seconds)))))
        ;; Sign and broadcast
        (federation-broadcast
         (sign-announcement announcement key))))))
</pre>
</section>
<section>
<h2>Role-Based Operation Constraints</h2>
<h3>Operation Matrix</h3>
<table>
<tr><th>Operation </th><th>coordinator </th><th>full </th><th>witness </th><th>archiver </th><th>edge </th></tr>
<tr><td>seal-commit </td></tr>
<tr><td>seal-release </td></tr>
<tr><td>seal-archive </td></tr>
<tr><td>seal-restore </td></tr>
<tr><td>seal-publish </td></tr>
<tr><td>seal-subscribe </td></tr>
<tr><td>seal-synchronize </td></tr>
<tr><td>seal-verify </td></tr>
<tr><td>threshold-sign </td></tr>
<tr><td>byzantine-vote </td></tr>
<tr><td>key-ceremony </td></tr>
<tr><td>audit-append </td></tr>
<tr><td>audit-verify </td></tr>
</table>
<h3>Graceful Degradation</h3>
<pre class="language-scheme">
(define (node-can-perform? operation)
  "Check if current role permits operation"
  (let ((role (node-current-role))
        (required (operation-required-role operation)))
    (role-permits? role required)))

(define (role-permits? actual required)
  "Check role hierarchy"
  (let ((hierarchy '(coordinator full witness archiver edge)))
    (&lt;= (list-index hierarchy actual)
        (list-index hierarchy required))))
</pre>
</section>
<section>
<h2>Starlink Considerations</h2>
<p>Per Memo-016, the system is optimized for satellite links:</p>
<pre class="language-scheme">
(node-config
  (role witness)
  (network
    (type satellite)
    (provider starlink)
    (characteristics
      (latency-ms 20-40)           ; Low-earth orbit
      (bandwidth-mbps 100-200)     ; Bursty
      (jitter high)                ; Variable
      (uptime 0.95)                ; Weather dependent
      (data-cap none))))           ; Unlimited for now

;; Satellite-optimized behavior
(define satellite-mode
  '((batch-sync #t)                ; Aggregate operations
    (lazy-pull #t)                 ; Don't fetch eagerly
    (compress-always #t)           ; Minimize transfer
    (retry-aggressive #t)          ; Handle drops
    (heartbeat-interval 300)))     ; 5 min, not seconds
</pre>
<h3>Role Implications for Satellite Nodes</h3>
<p>- coordinator: Generally NOT suitable for satellite (latency too variable for consensus) - full: Marginal (can work with lazy clustering) - witness: IDEAL (passive, tolerates latency) - archiver: IDEAL (batch operations) - edge: IDEAL (intermittent by design)</p>
</section>
<section>
<h2>Implementation</h2>
<h3>REPL Commands</h3>
<pre class="language-scheme">
;; Probe and display capabilities
(node-probe)

;; Show current role
(node-role)

;; Set role explicitly
(node-role 'witness)

;; Check if operation permitted
(node-can? 'threshold-sign)

;; Announce role to peers
(node-announce)
</pre>
<h3>Persistence</h3>
<p>Role configuration stored in the realm:</p>
<pre>
~/.cyberspace/node-role      ; User override (global)
.vault/node-role             ; Realm-specific role
.vault/node-hardware         ; Hardware manifest (auto-refreshed)
</pre>
<p>The hardware manifest is automatically updated on REPL startup, declaring the realm's capabilities to federated peers.</p>
<h3>Audit Trail</h3>
<p>Role changes are auditable events:</p>
<pre class="language-scheme">
(audit-entry
  (type node-role-change)
  (timestamp 1736280000)
  (from edge)
  (to witness)
  (reason "Storage expanded")
  (actor #${principal}))
</pre>
</section>
<section>
<h2>Security Considerations</h2>
<h3>Role Spoofing</h3>
<p>A node could claim a higher role than its capabilities warrant. Mitigations:</p>
<ul>
<li>Capability proofs: Require benchmark results</li>
<li>Peer validation: Other nodes can challenge claims</li>
<li>Reputation: Track role fulfillment history</li>
<li>Threshold trust: Multiple witnesses needed</li>
</ul>
<p>These mitigations layer defense in depth; no single spoofing technique defeats all of them.</p>
<h3>Role Downgrade Attacks</h3>
<p>An attacker could force nodes to operate at lower roles:</p>
<ul>
<li>Signed role declarations: Can't forge</li>
<li>Local override: Node controls own role</li>
<li>Audit trail: Role changes are logged</li>
</ul>
<p>A node's sovereignty over its own role prevents external actors from dictating its participation level.</p>
</section>
<section>
<h2>Membership Lifecycle</h2>
<p>Roles define what a node can do; membership defines who belongs. This section specifies the full lifecycle: enrollment, persistence, voluntary departure, and involuntary removal.</p>
<h3>Join Policy</h3>
<p>A realm's join policy determines how new members are admitted. Four policies, from most to least permissive:</p>
<table>
<tr><th>Policy </th><th>Description </th><th>When </th></tr>
<tr><td>open </td><td>Any node may join; master auto-approves </td><td>Development, testing, personal realms </td></tr>
<tr><td>sponsored </td><td>Existing member vouches for joiner </td><td>Default for small realms (2-10 nodes) </td></tr>
<tr><td>voted </td><td>N-of-M existing members must approve </td><td>Production realms, high-trust environments </td></tr>
<tr><td>closed </td><td>No new members accepted </td><td>Frozen realms, archival configurations </td></tr>
</table>
<p>The policy is a realm-level setting, stored in realm state and enforced by the join listener.</p>
<pre class="language-scheme">
(realm-state
  (version 1)
  (master fluffy)
  (join-policy sponsored)    ; open | sponsored | voted | closed
  (vote-threshold (2 3))     ; 2-of-3 required (voted policy only)
  ...)
</pre>
<p>Open policy is the current default. The join listener accepts any well-formed join request and issues a certificate. This is correct for the current two-node development scenario but must evolve as realms grow.</p>
<h3>Sponsored Enrollment</h3>
<p>Under the sponsored policy, the sponsoring member's identity is recorded in the enrollment certificate:</p>
<pre class="language-scheme">
(signed-enrollment-cert
  (spki-cert
    (issuer (principal ed25519:...))
    (subject (name new-node) (principal ed25519:...))
    (role full)
    (sponsor fluffy)             ; who vouched
    (validity (not-before ...) (not-after ...))))
  (signature ...))
</pre>
<p>The sponsor field creates an accountability chain. If a sponsored node misbehaves, the sponsor's judgment is part of the audit record.</p>
<h3>Voted Enrollment</h3>
<p>Under the voted policy, a join request enters a pending queue. Existing members vote to approve or reject.</p>
<pre class="language-scheme">
;; Pending join request (stored in *pending-proposals*)
(pending-join
  (name starlight)
  (pubkey #${...})
  (hardware (introspection ...))
  (proposed-by fluffy)
  (proposed-at 1770583600)
  (votes ((fluffy . approve)
          (luna . approve)))
  (threshold (2 3))              ; need 2-of-3
  (status pending))              ; pending | approved | rejected | expired
</pre>
<p>When the threshold is met, the proposing member (or any approver) issues the enrollment certificate. Votes are gossiped so all members converge on the same decision.</p>
<p>Pending proposals expire after a configurable timeout (default: 7 days). Expired proposals are garbage-collected and the joiner must re-request.</p>
<h3>Enrollment Persistence</h3>
<p>After successful enrollment (by any policy), three artifacts are persisted to the vault:</p>
<pre>
.vault/
  certs/membership.sexp           ; signed enrollment certificate
  keystore/
    enrollment.pub                ; Ed25519 public key (plaintext)
    enrollment.key                ; Ed25519 private key (plaintext)
  realm-state.sexp                ; master, role, members, timestamp
</pre>
<p>On restart, the system checks all three. If any is missing or invalid, the node falls back to fresh auto-enrollment. This three-point check prevents a node from operating with stale identity material.</p>
<p>Hardware capabilities and scaling factors are NOT persisted. They are recomputed from fresh introspection on every startup, ensuring the node's declared capabilities always match reality.</p>
</section>
<section>
<h2>Leaving a Realm</h2>
<p>A node may voluntarily depart a realm. Departure is clean: the node revokes its own membership, notifies peers, and returns to the Wilderness.</p>
<h3>Voluntary Departure</h3>
<pre class="language-scheme">
(define (leave-realm)
  "Voluntarily depart the realm. Clean exit."
  ;; 1. Notify peers (gossip departure)
  ;; 2. Revoke local membership cert
  ;; 3. Delete realm-state.sexp
  ;; 4. Delete enrollment keypair
  ;; 5. Stop join listener
  ;; 6. Unregister from Bonjour
  ;; 7. Reset in-memory state
  ;; Node returns to Wilderness
  ...)
</pre>
<p>Steps 1-6 are idempotent. A crashed node that restarts after partial departure will detect the missing files and fall through to fresh enrollment, achieving the same end state.</p>
<h3>Member List Update</h3>
<p>When a node departs, the remaining members must update their member lists. The departure is gossiped as a membership event:</p>
<pre class="language-scheme">
(membership-event
  (type departure)
  (node starlight)
  (timestamp 1770583600)
  (reason voluntary)             ; voluntary | timeout | disbarred
  (signed-by starlight))
</pre>
<p>On receiving a departure event, each member removes the node from its local member list and recomputes scaling factors. If the departing node was master, the remaining members trigger a new election.</p>
<h3>Master Departure</h3>
<p>If the master departs, the realm needs a new one. The remaining members hold a capability-based election (same as initial enrollment). The most capable remaining node becomes master.</p>
<p>If no members remain, the realm ceases to exist. Its artifacts persist in vaults but no active realm operates.</p>
</section>
<section>
<h2>Disbarment</h2>
<p>Involuntary removal of a malicious or compromised node. Unlike voluntary departure, the node does not cooperate.</p>
<h3>Grounds for Disbarment</h3>
<ul>
<li>Certificate compromise: Private key leaked or stolen</li>
<li>Byzantine behavior: Node issues conflicting statements</li>
<li>Resource abuse: Excessive storage, bandwidth, or compute consumption</li>
<li>Protocol violation: Malformed messages, replay attacks</li>
</ul>
<p>Disbarment is a serious action. The bar is high because false positives destroy trust in the system.</p>
<h3>Disbarment Protocol</h3>
<p>Disbarment requires a vote under the realm's join policy (even if the join policy is 'open', disbarment always requires a vote):</p>
<pre class="language-scheme">
;; Disbarment proposal
(pending-disbar
  (name compromised-node)
  (proposed-by fluffy)
  (proposed-at 1770583600)
  (reason "Certificate compromise detected")
  (evidence (audit-ref "hash-of-evidence"))
  (votes ((fluffy . disbar)
          (luna . disbar)))
  (threshold (2 3))
  (status pending))
</pre>
<p>When the threshold is met:</p>
<ul>
<li>The node's membership certificate is revoked (added to a revocation list)</li>
<li>The node is removed from all member lists</li>
<li>The revocation is gossiped to all members</li>
<li>The node's Bonjour registration is ignored by members</li>
<li>Scaling factors are recomputed without the disbarred node</li>
</ul>
<h3>Certificate Revocation</h3>
<p>Revoked certificates are stored in a revocation list that is gossiped alongside membership events:</p>
<pre class="language-scheme">
(revocation-list
  (version 1)
  (entries
    ((principal ed25519:abc123...)
     (revoked-at 1770583600)
     (reason "Byzantine behavior")
     (revoked-by (fluffy luna)))))
</pre>
<p>Any node encountering a revoked certificate rejects it, even if the certificate is otherwise valid. The revocation list is append-only and signed by the revoking quorum.</p>
<h3>Disbarred Node Behavior</h3>
<p>A disbarred node finds itself unable to participate:</p>
<ul>
<li>Join requests are rejected (pubkey is on revocation list)</li>
<li>Gossip messages from the node are dropped</li>
<li>The node can still operate locally but cannot federate</li>
</ul>
<p>The node effectively returns to the Wilderness but with a tainted identity. It must generate new keys to re-enroll, and even then, the voted policy provides a gate.</p>
</section>
<section>
<h2>Pending Joins Queue</h2>
<p>The pending proposals queue (*pending-proposals*) tracks join and disbarment votes in progress.</p>
<h3>Queue Structure</h3>
<pre class="language-scheme">
(define *pending-proposals* '())

;; Each proposal:
(proposal
  (id "hash-of-proposal")
  (type join)                    ; join | disbar
  (subject node-name)
  (proposed-by proposer-name)
  (proposed-at timestamp)
  (votes ())                     ; ((name . vote) ...)
  (threshold (n m))              ; n-of-m required
  (expires (+ proposed-at 604800))  ; 7 days
  (status pending))              ; pending | approved | rejected | expired
</pre>
<h3>Queue Operations</h3>
<pre class="language-scheme">
;; Propose a new member
(propose-join 'new-node pubkey hardware)

;; Vote on a pending proposal
(vote-proposal proposal-id 'approve)  ; or 'reject

;; List pending proposals
(pending)

;; Proposals are gossiped between members
;; Votes are gossiped as they arrive
;; Threshold check happens on every vote receipt
</pre>
<h3>Consistency</h3>
<p>Proposals and votes are gossiped, so all members eventually see the same state. Because votes are idempotent (a member can only vote once per proposal), convergence is guaranteed regardless of message ordering.</p>
<p>In the event of a network partition, each partition may independently reach a threshold if enough members are present. When the partition heals, the gossiped results converge. If conflicting decisions were made (one partition approved, another rejected), the earlier timestamp wins.</p>
</section>
<section>
<h2>Voting Protocol</h2>
<p>Membership votes use the quorum protocol defined in Memo-038. The specific application to membership decisions:</p>
<h3>Simple Majority</h3>
<p>For small realms (2-5 members), a simple majority suffices. Votes are open (not encrypted) since the social cost of disagreement is low in small groups.</p>
<pre class="language-scheme">
(vote-threshold
  (policy majority)
  (minimum 2))                   ; at least 2 votes regardless of realm size
</pre>
<h3>N-of-M Threshold</h3>
<p>For larger realms, an explicit threshold prevents single members from controlling admission:</p>
<pre class="language-scheme">
(vote-threshold
  (policy threshold)
  (n 3)
  (m 5))                         ; 3 of 5 members must approve
</pre>
<p>The threshold is a realm-level setting. Changing the threshold itself requires a vote at the current threshold.</p>
<h3>Private Ballot</h3>
<p>For sensitive decisions (especially disbarment), the homomorphic voting protocol from Memo-038 applies. Individual votes are encrypted; only the tally is revealed.</p>
<p>Private ballot is RECOMMENDED for disbarment and OPTIONAL for join votes. The realm's join policy configuration specifies which.</p>
</section>
<section>
<h2>References</h2>
<ul>
<li>Memo-010: Federation Protocol</li>
<li>Memo-011: Byzantine Consensus</li>
<li>Memo-016: Lazy Clustering</li>
<li>Memo-017: Security Considerations</li>
<li>Memo-038: Quorum Protocol with Homomorphic Voting</li>
<li>Memo-050: The Wilderness</li>
</ul>
</section>
<section>
<h2>Changelog</h2>
<ul>
<li>2026-02-09: Membership lifecycle (enrollment, departure, disbarment, voting)</li>
<li>2026-01-07: Initial draft (roles and capabilities)</li>
</ul>
</section>
<script>
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
}
(function() {
  // Query param override (for REPL: ?theme=dark or ?theme=light)
  const params = new URLSearchParams(window.location.search);
  const param = params.get('theme');
  if (param === 'dark' || param === 'light') {
    document.documentElement.setAttribute('data-theme', param);
    localStorage.setItem('theme', param);
    return;
  }
  // localStorage preference
  const saved = localStorage.getItem('theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
  } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script>
</body>
</html>
