<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <title>Memo 0032: Monitoring and Observability</title>
  <link rel="icon" id="favicon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27%230f0%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>">
  <script>
(function(){
  var h=new Date().getHours(),c;
  if(h>=4&&h<6)c='%23845EC2';       // brahma muhurta - violet
  else if(h>=6&&h<8)c='%23ffd700';  // dawn - gold
  else if(h>=8&&h<11)c='%2300d4aa'; // morning - teal
  else if(h>=11&&h<14)c='%230f0';   // midday - phosphor
  else if(h>=14&&h<17)c='%2339ff14';// afternoon - neon
  else if(h>=17&&h<19)c='%23ff6600';// sunset - orange
  else if(h>=19&&h<22)c='%23ff3366';// evening - coral
  else c='%2300ffff';               // night - cyan
  document.getElementById('favicon').href='data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27'+c+'%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>';
})();
</script>
  <link rel="stylesheet" href="memo.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<h1>Memo 0032: Monitoring and Observability</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This Memo specifies monitoring and observability for the Library of Cyberspace: how vaults expose metrics, traces, and logs for operational visibility while maintaining privacy and security. Observability data is itself content-addressed and auditable.</p>
</section>
<section>
<h2>Motivation</h2>
<p>Operating distributed systems requires visibility:</p>
<ul>
<li>Health</li>
<li>Is the vault functioning correctly?</li>
<li>Performance</li>
<li>How fast are operations?</li>
<li>Capacity</li>
<li>How much storage remains?</li>
<li>Errors</li>
<li>What's failing and why?</li>
<li>Security</li>
<li>Who's accessing what?</li>
</ul>
<p>But observability must not compromise:</p>
<ul>
<li>Privacy</li>
<li>No sensitive data in metrics</li>
<li>Security</li>
<li>Metrics don't leak capabilities</li>
<li>Performance</li>
<li>Minimal overhead</li>
<li>Storage</li>
<li>Observability data is bounded</li>
</ul>
</section>
<section>
<h2>Metrics</h2>
<h3>Core Metrics</h3>
<pre class="language-scheme">
(define vault-metrics
  '(;; Storage
    (storage.used.bytes gauge "Total bytes used")
    (storage.available.bytes gauge "Bytes available")
    (storage.objects.count gauge "Number of objects")

    ;; Operations
    (cas.put.count counter "CAS put operations")
    (cas.put.bytes counter "Bytes written")
    (cas.put.duration histogram "Put latency")
    (cas.get.count counter "CAS get operations")
    (cas.get.bytes counter "Bytes read")
    (cas.get.duration histogram "Get latency")

    ;; Soup
    (soup.queries.count counter "Soup queries")
    (soup.queries.duration histogram "Query latency")
    (soup.index.size.bytes gauge "Index size")

    ;; Network
    (network.connections.active gauge "Active connections")
    (network.bytes.sent counter "Bytes sent")
    (network.bytes.received counter "Bytes received")

    ;; Replication
    (replication.lag.seconds gauge "Replication lag")
    (replication.objects.pending gauge "Objects pending sync")

    ;; Errors
    (errors.total counter "Total errors" labels: (type))
    (errors.rate gauge "Error rate per second")))
</pre>
<h3>Metric Collection</h3>
<pre class="language-scheme">
(define metrics-registry (make-hash-table))

(define (register-metric name type help #!key labels)
  (hash-table-set! metrics-registry name
    `((type . ,type)
      (help . ,help)
      (labels . ,labels)
      (value . ,(case type
                  ((counter) 0)
                  ((gauge) 0)
                  ((histogram) (make-histogram-buckets)))))))

(define (metric-inc! name #!key (delta 1) labels)
  (let ((metric (hash-table-ref metrics-registry name)))
    (case (assoc-ref metric 'type)
      ((counter gauge)
       (set! (assoc-ref metric 'value)
             (+ (assoc-ref metric 'value) delta))))))

(define (metric-set! name value #!key labels)
  (let ((metric (hash-table-ref metrics-registry name)))
    (set! (assoc-ref metric 'value) value)))

(define (metric-observe! name value #!key labels)
  (let ((metric (hash-table-ref metrics-registry name)))
    (histogram-observe! (assoc-ref metric 'value) value)))
</pre>
<h3>Histogram Buckets</h3>
<pre class="language-scheme">
(define (make-histogram-buckets)
  "Default latency buckets in milliseconds"
  (let ((buckets '(1 5 10 25 50 100 250 500 1000 2500 5000 10000)))
    (map (lambda (b) (cons b 0)) buckets)))

(define (histogram-observe! histogram value)
  (for-each (lambda (bucket)
              (when (&lt;= value (car bucket))
                (set-cdr! bucket (+ (cdr bucket) 1))))
            histogram))
</pre>
</section>
<section>
<h2>Tracing</h2>
<h3>Trace Structure</h3>
<pre class="language-scheme">
(define (make-trace operation)
  `(trace
    (trace-id ,(generate-trace-id))
    (span-id ,(generate-span-id))
    (parent-span-id #f)
    (operation ,operation)
    (start-time ,(current-time-ns))
    (end-time #f)
    (status pending)
    (attributes ())
    (events ())))

(define (trace-start! trace)
  (set! (assoc-ref trace 'start-time) (current-time-ns))
  trace)

(define (trace-end! trace status)
  (set! (assoc-ref trace 'end-time) (current-time-ns))
  (set! (assoc-ref trace 'status) status)
  (record-trace! trace))
</pre>
<h3>Span Context</h3>
<pre class="language-scheme">
(define current-trace (make-parameter #f))
(define current-span (make-parameter #f))

(define (with-span operation proc)
  "Execute proc within a traced span"
  (let* ((parent (current-span))
         (span (make-span operation (and parent (span-id parent)))))
    (parameterize ((current-span span))
      (span-start! span)
      (guard (ex
              (else
               (span-error! span ex)
               (span-end! span 'error)
               (raise ex)))
        (let ((result (proc)))
          (span-end! span 'ok)
          result)))))

;; Example usage
(define (traced-cas-get hash)
  (with-span "cas.get"
    (lambda ()
      (span-set-attribute! "hash" hash)
      (cas-get hash))))
</pre>
<h3>Distributed Tracing</h3>
<pre class="language-scheme">
;; Propagate trace context across vault boundaries
(define (inject-trace-context headers)
  "Inject trace context into outgoing request"
  (let ((span (current-span)))
    (when span
      (hash-table-set! headers "X-Trace-Id" (span-trace-id span))
      (hash-table-set! headers "X-Span-Id" (span-id span)))))

(define (extract-trace-context headers)
  "Extract trace context from incoming request"
  (let ((trace-id (hash-table-ref headers "X-Trace-Id" #f))
        (parent-span-id (hash-table-ref headers "X-Span-Id" #f)))
    (when trace-id
      (current-trace trace-id)
      (make-span-with-parent parent-span-id))))
</pre>
</section>
<section>
<h2>Logging</h2>
<h3>Structured Logging</h3>
<pre class="language-scheme">
(define (log level message #!rest attributes)
  "Emit structured log entry"
  (let ((entry `((timestamp . ,(current-time-iso8601))
                 (level . ,level)
                 (message . ,message)
                 (vault . ,(vault-id))
                 (trace-id . ,(and (current-span) (span-trace-id (current-span))))
                 ,@(plist-&gt;alist attributes))))
    (emit-log entry)))

(define (log-debug message . attrs) (apply log 'debug message attrs))
(define (log-info message . attrs) (apply log 'info message attrs))
(define (log-warn message . attrs) (apply log 'warn message attrs))
(define (log-error message . attrs) (apply log 'error message attrs))

;; Example
(log-info "Object stored"
          'hash hash
          'size (bytevector-length data)
          'duration-ms elapsed)
</pre>
<h3>Log Levels</h3>
<pre class="language-scheme">
(define log-levels '((trace . 0) (debug . 1) (info . 2)
                     (warn . 3) (error . 4) (fatal . 5)))

(define current-log-level (make-parameter 'info))

(define (log-enabled? level)
  (&gt;= (assoc-ref log-levels level)
      (assoc-ref log-levels (current-log-level))))
</pre>
<h3>Log Sinks</h3>
<pre class="language-scheme">
;; Multiple output destinations
(define log-sinks '())

(define (add-log-sink! sink)
  (set! log-sinks (cons sink log-sinks)))

(define (emit-log entry)
  (when (log-enabled? (assoc-ref entry 'level))
    (for-each (lambda (sink)
                (sink-write sink entry))
              log-sinks)))

;; Sink implementations
(define (make-file-sink path)
  (lambda (entry)
    (with-output-to-file path
      (lambda () (write-json entry) (newline))
      'append)))

(define (make-soup-sink)
  (lambda (entry)
    (soup-put entry type: 'log-entry)))
</pre>
</section>
<section>
<h2>Health Checks</h2>
<h3>Health Endpoints</h3>
<pre class="language-scheme">
(define (health-check)
  "Comprehensive health check"
  ((status . ,(if (all-healthy?) 'healthy 'unhealthy))
    (checks . ((storage . ,(check-storage))
               (network . ,(check-network))
               (replication . ,(check-replication))
               (keys . ,(check-keys))))))

(define (check-storage)
  ((status . ,(if (storage-accessible?) 'healthy 'unhealthy))
    (used . ,(storage-used))
    (available . ,(storage-available))
    (percent . ,(storage-percent-used))))

(define (check-network)
  ((status . ,(if (network-healthy?) 'healthy 'unhealthy))
    (peers . ,(connected-peer-count))
    (latency-ms . ,(average-peer-latency))))

(define (check-replication)
  ((status . ,(if (replication-healthy?) 'healthy 'unhealthy))
    (lag-seconds . ,(replication-lag))
    (pending . ,(pending-replication-count))))
</pre>
<h3>Readiness vs Liveness</h3>
<pre class="language-scheme">
;; Liveness: is the process running?
(define (liveness-check)
  '((status . alive)))

;; Readiness: can we serve requests?
(define (readiness-check)
  (if (and (storage-accessible?)
           (keys-available?)
           (not (vault-readonly?)))
      '((status . ready))
      '((status . not-ready))))
</pre>
</section>
<section>
<h2>Alerting</h2>
<h3>Alert Rules</h3>
<pre class="language-scheme">
(define alert-rules
  `((storage-critical
     (condition (&gt; (metric-value 'storage.percent.used) 95))
     (severity critical)
     (message "Storage critically low"))

    (storage-warning
     (condition (&gt; (metric-value 'storage.percent.used) 80))
     (severity warning)
     (message "Storage running low"))

    (error-rate-high
     (condition (&gt; (metric-value 'errors.rate) 10))
     (severity warning)
     (message "High error rate detected"))

    (replication-lag
     (condition (&gt; (metric-value 'replication.lag.seconds) 300))
     (severity warning)
     (message "Replication lag exceeds 5 minutes"))

    (peer-disconnected
     (condition (&lt; (metric-value 'network.peers.connected) 1))
     (severity critical)
     (message "No peers connected"))))
</pre>
<h3>Alert Evaluation</h3>
<pre class="language-scheme">
(define (evaluate-alerts)
  "Check all alert conditions"
  (filter-map
    (lambda (rule)
      (when (eval-condition (assoc-ref rule 'condition))
        (fire-alert rule)))
    alert-rules))

(define (fire-alert rule)
  (let ((alert `((name . ,(car rule))
                 (severity . ,(assoc-ref (cdr rule) 'severity))
                 (message . ,(assoc-ref (cdr rule) 'message))
                 (timestamp . ,(current-time)))))
    (audit-append action: 'alert-fired alert: alert)
    (notify-alert alert)
    alert))
</pre>
</section>
<section>
<h2>Dashboards</h2>
<h3>Metric Export</h3>
<pre class="language-scheme">
;; Prometheus format
(define (export-prometheus)
  (with-output-to-string
    (lambda ()
      (for-each
        (lambda (metric)
          (let ((name (car metric))
                (data (cdr metric)))
            (format #t "# HELP ~a ~a~%" name (assoc-ref data 'help))
            (format #t "# TYPE ~a ~a~%" name (assoc-ref data 'type))
            (format #t "~a ~a~%" name (assoc-ref data 'value))))
        (hash-table-&gt;alist metrics-registry)))))
</pre>
<h3>Status Page</h3>
<pre class="language-scheme">
(define (status-page)
  "Generate human-readable status"
  `(vault-status
    (health . ,(health-check))
    (uptime . ,(vault-uptime))
    (version . ,(vault-version))
    (metrics . ((storage . ,(storage-metrics))
                (operations . ,(operation-metrics))
                (network . ,(network-metrics))))
    (recent-errors . ,(recent-errors 10))))
</pre>
</section>
<section>
<h2>Privacy</h2>
<h3>Metric Sanitization</h3>
<pre class="language-scheme">
;; Never expose sensitive data in metrics
(define (sanitize-metric-labels labels)
  (map (lambda (label)
         (case (car label)
           ((hash) (cons 'hash "[REDACTED]"))
           ((principal) (cons 'principal (hash-principal (cdr label))))
           (else label)))
       labels))

(define (safe-metric name value #!key labels)
  (metric-set! name value labels: (sanitize-metric-labels labels)))
</pre>
<h3>Aggregate Metrics Only</h3>
<pre class="language-scheme">
;; Expose only aggregates, not individual operations
(define (operation-metrics)
  `((total-operations . ,(metric-value 'cas.operations.total))
    (operations-per-second . ,(metric-value 'cas.operations.rate))
    (average-latency-ms . ,(metric-value 'cas.latency.average))
    (p99-latency-ms . ,(metric-value 'cas.latency.p99))))
</pre>
</section>
<section>
<h2>Storage</h2>
<h3>Metric Retention</h3>
<pre class="language-scheme">
;; Metrics stored in soup with TTL
(define metric-retention ( 30 24 3600))  ; 30 days

(define (store-metric-snapshot)
  "Periodic metric snapshot"
  (let ((snapshot `((timestamp . ,(current-time))
                    (metrics . ,(export-all-metrics)))))
    (soup-put snapshot
      type: 'metric-snapshot
      ttl: metric-retention)))

(define (gc-old-metrics)
  "Remove expired metric snapshots"
  (let ((expired (soup-query type: 'metric-snapshot
                             timestamp: (&lt; (- (current-time) metric-retention*)))))
    (for-each soup-delete! expired)))
</pre>
<h3>Trace Sampling</h3>
<pre class="language-scheme">
;; Sample traces to control storage
(define trace-sample-rate 0.1)  ; 10%

(define (should-sample-trace?)
  (&lt; (random 1.0) trace-sample-rate))

(define (record-trace! trace)
  (when (or (trace-has-error? trace)
            (should-sample-trace?))
    (soup-put trace type: 'trace)))
</pre>
</section>
<section>
<h2>References</h2>
<p>1. [OpenTelemetry](https://opentelemetry.io/) - Observability framework 2. [Prometheus](https://prometheus.io/) - Monitoring system 3. [Memo-003: Cryptographic Audit Trail](memo-003-audit-trail.html) 4. [Memo-028: Error Handling](memo-028-error-handling.html)</p>
</section>
<section>
<h2>Changelog</h2>
<ul>
<li>2026-01-07</li>
<li>Initial draft</li>
</ul>
</section>
<script>
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
}
(function() {
  // Query param override (for REPL: ?theme=dark or ?theme=light)
  const params = new URLSearchParams(window.location.search);
  const param = params.get('theme');
  if (param === 'dark' || param === 'light') {
    document.documentElement.setAttribute('data-theme', param);
    localStorage.setItem('theme', param);
    return;
  }
  // localStorage preference
  const saved = localStorage.getItem('theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
  } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script>
</body>
</html>
