<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <title>Memo 057: Lazy Discovery</title>
  <link rel="icon" id="favicon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27%230f0%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>">
  <script>
(function(){
  var h=new Date().getHours(),c;
  if(h>=4&&h<6)c='%23845EC2';       // brahma muhurta - violet
  else if(h>=6&&h<8)c='%23ffd700';  // dawn - gold
  else if(h>=8&&h<11)c='%2300d4aa'; // morning - teal
  else if(h>=11&&h<14)c='%230f0';   // midday - phosphor
  else if(h>=14&&h<17)c='%2339ff14';// afternoon - neon
  else if(h>=17&&h<19)c='%23ff6600';// sunset - orange
  else if(h>=19&&h<22)c='%23ff3366';// evening - coral
  else c='%2300ffff';               // night - cyan
  document.getElementById('favicon').href='data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27'+c+'%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>';
})();
</script>
  <link rel="stylesheet" href="memo.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<h1>Memo 057: Lazy Discovery</h1>
<dl class="metadata">
  <dt>Status</dt><dd>Draft</dd>
  <dt>Date</dt><dd>January 2026</dd>
  <dt>Author</dt><dd>Derrell Piper &lt;ddp@archlinux.us&gt;</dd>
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>Defines a reactive layer for the weave where realms lazily discover changes forged elsewhere. Complements the active forge model with pubsub semantics over gossip.</p>
</section>
<section>
<h2>1. Motivation</h2>
<p>The forge model requires active participation: realms compile, seal, sign, and gossip propagates results. But realms also need to know when peers have forged something new without polling.</p>
<p>Lazy discovery adds subscription semantics. Realms express interest; the weave notifies them. Pull when interested, ignore when not.</p>
</section>
<section>
<h2>2. Subscription Model</h2>
<h3>2.1 Interest Expression</h3>
<p>Realms subscribe to change feeds:</p>
<pre class="language-scheme">
(subscribe realm: 'fluffy)           ; all changes from fluffy
(subscribe key: hash)                 ; changes to specific object
(subscribe topic: 'rfc)               ; semantic topic
(subscribe pattern: "spki/scheme/*") ; glob pattern
</pre>
<p>Subscriptions are SPKI certificates - signed expressions of interest that can be delegated and revoked.</p>
<h3>2.2 Notification Format</h3>
<p>Change notifications are lightweight:</p>
<pre class="language-scheme">
(change
  (realm fluffy)
  (lamport 42)
  (hash "sha512:...")
  (type sealed-archive)
  (topic rfc)
  (signature ...))
</pre>
<p>Notifications announce existence, not content. Interested realms pull the object via normal gossip.</p>
</section>
<section>
<h2>3. Gossip as Tala</h2>
<p>In Indian classical music, tala is the rhythmic cycle underlying the raga. Without tala, the melody has no structure. Without gossip, the weave has no coherence.</p>
<p>Gossip is the tala of cyberspace - the steady beat that carries forge and discovery alike. Realms may create in isolation, but the rhythm connects them.</p>
</section>
<section>
<h2>4. Gossip Integration</h2>
<h3>4.1 Notification Propagation</h3>
<p>Change notifications piggyback on gossip protocol (Memo-010). They are small, signed, and expire:</p>
<ul>
<li>Notifications included in gossip heartbeat</li>
<li>TTL limits propagation (default: 24 hours)</li>
<li>Deduplication by (realm, lamport, hash) tuple</li>
</ul>
<h3>4.2 Request on Interest</h3>
<p>When a notification matches a subscription:</p>
<pre class="language-scheme">
(on-change notification
  (when (matches-subscription? notification subscriptions)
    (request-object (change-hash notification) (change-realm notification))))
</pre>
<p>The request is lazy - realms may defer, batch, or ignore based on priority.</p>
</section>
<section>
<h2>5. Subscription Certificates</h2>
<h3>5.1 Structure</h3>
<pre class="language-scheme">
(cert
  (issuer realm-key)
  (subject subscription)
  (validity (not-after "2026-12-31"))
  (delegate #f)
  (signature ...))
</pre>
<p>Subscriptions are first-class objects in the SPKI model. They can be stored in vaults, shared, and audited.</p>
<h3>5.2 Privacy Considerations</h3>
<p>Subscriptions reveal interest. Realms may:</p>
<ul>
<li>Subscribe through intermediaries</li>
<li>Use broad patterns to obscure specific interest</li>
<li>Accept latency for privacy (poll instead of subscribe)</li>
</ul>
</section>
<section>
<h2>6. Implementation</h2>
<h3>6.1 Subscription Registry</h3>
<pre class="language-scheme">
(define *subscriptions* '())

(define (subscribe #!key realm key topic pattern)
  "Register interest in changes."
  (let ((sub (make-subscription realm: realm key: key
                                topic: topic pattern: pattern)))
    (set! *subscriptions* (cons sub *subscriptions*))
    (announce-subscription sub)
    sub))

(define (unsubscribe sub)
  "Revoke interest."
  (set! *subscriptions* (remove sub *subscriptions*))
  (announce-revocation sub))
</pre>
<h3>6.2 Change Emission</h3>
<pre class="language-scheme">
(define (emit-change object)
  "Announce a newly forged object."
  (let ((notification (make-change-notification
                        realm: *current-realm*
                        lamport: (lamport-time)
                        hash: (object-hash object)
                        type: (object-type object)
                        topic: (object-topic object))))
    (sign-and-gossip notification)))
</pre>
</section>
<section>
<h2>7. Relationship to Forge</h2>
<p>Lazy discovery complements, not replaces, the forge:</p>
<pre>
Forge:     Active. You create, you seal, you sign.
Discovery: Reactive. You express interest, you're notified.
Gossip:    Transport. Carries both forged objects and notifications.
</pre>
<p>The weave remains a system of forges. Lazy discovery is how forges hear about each other's work.</p>
</section>
<section>
<h2>8. Security Considerations</h2>
<ul>
<li>Notification spam: Rate limiting per realm (Memo-032)</li>
<li>Subscription flooding: Quota on active subscriptions</li>
<li>Privacy leakage: Subscriptions reveal interest graphs</li>
<li>Replay attacks: Lamport ordering prevents stale notifications</li>
</ul>
</section>
<section>
<h2>References</h2>
<ul class="references">
<li><strong>Memo-010 (2026)</strong>: Federation Protocol</li>
<li><strong>Memo-012 (2026)</strong>: Lamport Clocks</li>
<li><strong>Memo-032 (2026)</strong>: Rate Limiting</li>
<li><strong>Memo-004 (2026)</strong>: SPKI Authorization</li>
</ul>
</section>
<script>
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
}
(function() {
  // Query param override (for REPL: ?theme=dark or ?theme=light)
  const params = new URLSearchParams(window.location.search);
  const param = params.get('theme');
  if (param === 'dark' || param === 'light') {
    document.documentElement.setAttribute('data-theme', param);
    localStorage.setItem('theme', param);
    return;
  }
  // localStorage preference
  const saved = localStorage.getItem('theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
  } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script>
</body>
</html>
