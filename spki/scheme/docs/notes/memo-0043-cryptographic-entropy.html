<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <title>Memo 0043: Entropy Pool</title>
  <link rel="icon" id="favicon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27%230f0%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>">
  <script>
(function(){
  var h=new Date().getHours(),c;
  if(h>=4&&h<6)c='%23845EC2';       // brahma muhurta - violet
  else if(h>=6&&h<8)c='%23ffd700';  // dawn - gold
  else if(h>=8&&h<11)c='%2300d4aa'; // morning - teal
  else if(h>=11&&h<14)c='%230f0';   // midday - phosphor
  else if(h>=14&&h<17)c='%2339ff14';// afternoon - neon
  else if(h>=17&&h<19)c='%23ff6600';// sunset - orange
  else if(h>=19&&h<22)c='%23ff3366';// evening - coral
  else c='%2300ffff';               // night - cyan
  document.getElementById('favicon').href='data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27'+c+'%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>';
})();
</script>
  <link rel="stylesheet" href="memo.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<h1>Memo 0043: Entropy Pool</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>All cryptographic operations in Cyberspace require high-quality entropy. This Memo specifies the canonical entropy sources for each platform, ensuring consistent, auditable, and secure randomness across the entire system.</p>
</section>
<section>
<h2>Motivation</h2>
<h3>The Fundamental Requirement</h3>
<p>All cryptography requires true quantum randomness. The math doesn't work otherwise.</p>
<p>Cryptographic proofs assume a source of bits that are:</p>
<ul>
<li>Statistically uniform - Each bit equally likely 0 or 1</li>
<li>Independent - No correlations between bits</li>
<li>Unpredictable in principle - Not just hard to predict, but impossible</li>
</ul>
<p>Only quantum mechanical processes satisfy condition 3. Classical chaotic systems (lava lamps, thermal noise, ring oscillators) are deterministic - an adversary with sufficient knowledge of initial conditions could, in theory, predict their output. Quantum processes have no "initial conditions" to know - the randomness is fundamental to physics itself.</p>
<p>Why this matters: - Security proofs assume perfect randomness - Key security = min(algorithmbits, entropybits) - A 256-bit key from a 32-bit PRNG seed provides only 32 bits of security - Nation-state adversaries may have capabilities to model classical entropy sources</p>
<h3>Cryptographic Operations Requiring Entropy</h3>
<ul>
<li>Key generation (Ed25519, X25519)</li>
<li>Nonce generation (XSalsa20-Poly1305)</li>
<li>Salt generation (Argon2id)</li>
<li>Shamir secret sharing</li>
<li>Challenge-response protocols</li>
<li>Zero-knowledge proofs</li>
</ul>
<p>Every cryptographic primitive assumes access to uniformly random bits. Without true entropy, key generation produces predictable keys, nonces repeat, and mathematical security guarantees collapse. A realm's sovereignty rests entirely on the unpredictability of its secrets.</p>
</section>
<section>
<h2>The Commandment</h2>
<p>THOU SHALT USE CRYPTOGRAPHIC RANDOMNESS.</p>
<p>All randomness in Cyberspace flows through libsodium's randombytes_buf(), which uses:</p>
<ul>
<li>Linux: getrandom(2) syscall</li>
<li>macOS: arc4random_buf()</li>
<li>OpenBSD: getentropy(2)</li>
<li>Windows: RtlGenRandom</li>
</ul>
<p>Hardware entropy (RDRAND/RDSEED) feeds the OS pool. Quantum RNG (ID Quantique, drand beacons) planned for Phase 3+.</p>
<p>There are NO EXCEPTIONS. Never use:</p>
<ul>
<li>(chicken random) - Uses Mersenne Twister, not cryptographically secure</li>
<li>srfi-27 - Statistical randomness, not cryptographic</li>
<li>/dev/urandom directly - Platform-specific, misses getrandom(2) benefits</li>
<li>arc4random_buf() directly - Use libsodium's abstraction</li>
<li>Custom PRNGs - Unaudited, likely insecure</li>
</ul>
<p>The only approved functions are from crypto-ffi:</p>
<pre class="language-scheme">
(random-bytes n)         ; n cryptographically random bytes
(random-u8)              ; random byte [0, 255]
(random-u32)             ; random 32-bit unsigned
(random-uniform limit)   ; uniform [0, limit) with rejection sampling
</pre>
</section>
<section>
<h2>Boot-Time FIPS Testing</h2>
<p>Trust but verify. Every entropy source MUST be tested at boot time with FIPS 140-2 statistical tests on 20,000 bits (2500 bytes):</p>
<h3>Monobit Test</h3>
<p>Count of 1-bits must be 9654 &lt; n &lt; 10346 (within 3.43σ of expected 10000).</p>
<pre class="language-scheme">
(fips-monobit-test bytes)  ; Pass if balanced
</pre>
<h3>Poker Test</h3>
<p>Distribution of 4-bit nibbles must be uniform. X = (16/5000) × Σf² - 5000 must satisfy 1.03 &lt; X &lt; 57.4.</p>
<pre class="language-scheme">
(fips-poker-test bytes)   ; Pass if nibbles distributed
</pre>
<h3>Runs Test</h3>
<p>Runs of consecutive 0s and 1s must fall within bounds:</p>
<table>
<tr><th>Run Length</th><th>Expected Range (each bit value)</th></tr>
<tr><td>1</td><td>2267-2733</td></tr>
<tr><td>2</td><td>1079-1421</td></tr>
<tr><td>3</td><td>502-748</td></tr>
<tr><td>4</td><td>223-402</td></tr>
<tr><td>5</td><td>90-223</td></tr>
<tr><td>6+</td><td>90-223</td></tr>
</table>
<pre class="language-scheme">
(fips-runs-test bytes)    ; Pass if run distribution normal
</pre>
<h3>Long Run Test</h3>
<p>No run of 26 or more consecutive identical bits.</p>
<pre class="language-scheme">
(fips-long-run-test bytes) ; Pass if no pathological runs
</pre>
<p>Implementation in fips.scm:</p>
<pre class="language-scheme">
(define (test-randomness)
  "FIPS 140-2 randomness tests on 20,000 bits."
  (let* ((sample (random-bytes 2500))
         (bytes (blob-&gt;u8vector sample)))
    (and (fips-monobit-test bytes)
         (fips-poker-test bytes)
         (fips-runs-test bytes)
         (fips-long-run-test bytes))))

;; Called at REPL boot and by forge module load
(unless (test-randomness)
  (error "Entropy source failed FIPS 140-2 tests"))
</pre>
<p>If any test fails, Cyberspace refuses to start. There is no fallback. Weak entropy is not acceptable.</p>
</section>
<section>
<h2>Specification</h2>
<h3>Canonical Source: libsodium</h3>
<p>All Cyberspace implementations MUST use libsodium's randombytes_buf() as the primary entropy source:</p>
<pre>
randombytes_buf(buffer, size)
</pre>
<p>libsodium automatically selects the best available source: - Linux: getrandom(2) syscall, falls back to /dev/urandom - macOS/iOS: arc4random_buf() - Windows: RtlGenRandom() - OpenBSD: arc4random_buf() (ChaCha20-based)</p>
<h3>Why libsodium?</h3>
<ul>
<li>Cross-platform consistency - Same API everywhere</li>
<li>Automatic best-source selection - No platform-specific code</li>
<li>Initialization safety - Blocks until entropy available</li>
<li>Fork safety - Handles process forking correctly</li>
<li>Audited implementation - Widely reviewed cryptographic library</li>
</ul>
<p>libsodium provides a single canonical interface for entropy across all platforms. Using one audited implementation eliminates the class of bugs where platform-specific entropy code diverges or contains subtle flaws.</p>
<h3>Platform Requirements</h3>
<p>#### Scheme (CHICKEN)</p>
<pre class="language-scheme">
;; crypto-ffi.scm provides:
(define (random-bytes n)
  "Generate n cryptographically secure random bytes"
  (let ((buf (make-blob n)))
    ((foreign-lambda void "randombytes_buf" scheme-pointer unsigned-integer)
     buf n)
    buf))
</pre>
<p>All Scheme code MUST use random-bytes from crypto-ffi. NEVER use: - (chicken random) - Uses PRNG, not cryptographically secure - /dev/random directly - Platform-specific, may block - Custom PRNGs - Unaudited, likely insecure</p>
<p>#### OCaml</p>
<p>Status: Open Issue</p>
<p>OCaml implementations should use one of: - mirage-crypto-rng with Nocrypto.Rng.generate - Direct FFI to libsodium via ctypes</p>
<p>Decision pending based on: - Multicore OCaml compatibility - Domain-local PRNG state handling - Build system integration (dune vs opam)</p>
<h3>Entropy Initialization</h3>
<p>Before ANY cryptographic operation, ensure libsodium is initialized:</p>
<pre class="language-scheme">
(define (sodium-init)
  (let ((result ((foreign-lambda int "sodiuminit"))))
    (when (= result -1)
      (error "sodiuminit failed - entropy source unavailable"))))
</pre>
<p>sodium_init() is idempotent and thread-safe. Call it early in program startup.</p>
<h3>Key Generation</h3>
<p>All key generation MUST use libsodium's key generation functions, which internally use randombytes_buf():</p>
<table>
<tr><th>Operation </th><th>Function </th></tr>
<tr><td>Ed25519 signing key </td><td>cryptosignkeypair() </td></tr>
<tr><td>X25519 key exchange </td><td>cryptoboxkeypair() </td></tr>
<tr><td>Symmetric key </td><td>cryptosecretboxkeygen() </td></tr>
<tr><td>Generic random </td><td>randombytes_buf() </td></tr>
</table>
<h3>Nonce Generation</h3>
<p>Nonces MUST be generated fresh for each encryption:</p>
<pre class="language-scheme">
(define (generate-nonce)
  (random-bytes (secretbox-noncebytes)))  ;; 24 bytes
</pre>
<p>For XSalsa20-Poly1305 with 24-byte nonces, random nonces are safe: - 2^192 possible nonces - Birthday collision after ~2^96 messages - Practical limit: ~2^64 messages per key (still astronomical)</p>
<h3>Salt Generation</h3>
<p>For Argon2id key derivation:</p>
<pre class="language-scheme">
(define (generate-salt)
  (random-bytes 16))  ;; cryptopwhashSALTBYTES
</pre>
<p>Salts prevent rainbow table attacks. Each salt MUST be unique per derived key.</p>
</section>
<section>
<h2>Deep Dive: Entropy Sources</h2>
<p>Randomness is the foundation of all cryptography. This section explores the physics and engineering of true randomness.</p>
<h3>The Entropy Hierarchy</h3>
<pre class="diagram">
┌───────────────────────────────────────────────────────────┐
│                   Entropy Quality Pyramid                   │
├───────────────────────────────────────────────────────────┤
│                                                             │
│                    ┌───────────────┐                        │
│           ***      │  Quantum RNG  │  &lt;- TRUE RANDOMNESS    │
│                    └───────────────┘     (required for      │
│                          ^               cryptographic      │
│                          │               security)          │
│                    ──────┴──────                            │
│                    SECURITY BOUNDARY                        │
│                    ─────────────────                        │
│                          │                                  │
│                          v                                  │
│                  ┌───────────────────┐                      │
│                  │  Hardware TRNG    │  &lt;- Best effort      │
│                  └───────────────────┘     (should feed     │
│                ┌───────────────────────┐   quantum source)  │
│                │  Environmental/Analog │                    │
│                └───────────────────────┘                    │
│              ┌───────────────────────────┐                  │
│              │  Public Beacons (NIST)    │  &lt;- Verifiable   │
│              └───────────────────────────┘                  │
│            ┌───────────────────────────────┐                │
│            │  OS Entropy Pool              │  &lt;- Mixed      │
│            └───────────────────────────────┘                │
│          ┌───────────────────────────────────┐              │
│          │  CSPRNG (seeded from above)       │  &lt;- Expand   │
│          └───────────────────────────────────┘              │
│                                                             │
└───────────────────────────────────────────────────────────┘

   *** = Cryptographic operations MUST trace to quantum sources
</pre>
<p>Critical distinction: Everything below the security boundary is computationally secure (hard to predict), not information-theoretically secure (impossible to predict). For operations like key generation that must withstand future advances in computation and modeling, only quantum sources provide provable security.</p>
<h3>Practical Access to Quantum Randomness</h3>
<p>The ideal: Every cryptographic operation sources entropy from a local quantum RNG.</p>
<p>Current reality: Most systems rely on:</p>
<ul>
<li>Hardware RNG (thermal noise, ring oscillators) - classical, but unpredictable at human scales</li>
<li>OS mixing of multiple sources - defense in depth</li>
<li>NIST beacon - quantum-sourced, publicly verifiable, but network-dependent</li>
</ul>
<p>Path forward for Cyberspace: - Phase 1 (Now): libsodium with OS entropy (relies on hardware quality) - Phase 2: Optional quantum RNG hardware support (USB devices, PCIe cards) - Phase 3: Attestation of entropy source in realm metadata - Phase 4: Quantum RNG as standard infrastructure (as quantum internet develops)</p>
<p>Minimum acceptable: Modern Intel/AMD RDSEED instruction, which samples thermal noise at the silicon level. While not provably quantum, it has no known exploits and is mixed with other sources.</p>
<p>Goal: True quantum randomness as the foundation. The math requires it; the engineering will catch up.</p>
<h3>Cyberspace as Entropy Provider</h3>
<p>We will provide all the randomness that our users need - on demand, for whatever their cryptographic desires.</p>
<p>Cyberspace realms can serve as entropy sources for their users:</p>
<pre class="language-scheme">
;; Request entropy from the realm
(realm-entropy-request
  (bytes 32)
  (purpose "key-generation")
  (attestation-required #t))

;; Response includes attestation of entropy source
(realm-entropy-response
  (value #${...32 bytes...})
  (source "quantum-rng")
  (attestation (signed-by realm-principal)
               (hardware "ID-Quantique-QUANTIS")
               (timestamp 1736344800)))
</pre>
<p>Entropy services:</p>
<ul>
<li>Local generation - Realm uses its best available source</li>
<li>Federated entropy - Request quantum entropy from realms with quantum hardware</li>
<li>Beacon aggregation - Mix NIST + drand + realm sources</li>
<li>Attestation chain - Prove the entropy source for audit</li>
</ul>
<p>Long-term vision: A network of realms with quantum RNG hardware providing verifiable, quantum-sourced entropy to all participants. The soup carries randomness as naturally as it carries data.</p>
<h3>True Random Number Generators (TRNG)</h3>
<p>True randomness comes from physical processes that are fundamentally unpredictable:</p>
<p>#### Quantum Sources (Required for Provable Security)</p>
<p>The only sources that satisfy cryptographic assumptions. Quantum mechanics guarantees unpredictability:</p>
<ul>
<li>Photon beam splitters</li>
<li>Single photon hits 50/50 beam splitter, detection is truly random</li>
<li>Vacuum fluctuations</li>
<li>Measuring quantum vacuum state</li>
<li>Quantum tunneling</li>
<li>Electron tunneling through barriers</li>
<li>Nuclear decay</li>
<li>Timing of radioactive decay events</li>
</ul>
<p>Commercial quantum RNGs: ID Quantique (QUANTIS), Quintessence Labs, Crypta Labs</p>
<p>#### Silicon-Based TRNG</p>
<p>Modern CPUs include hardware random number generators:</p>
<table>
<tr><th>CPU </th><th>Instruction </th><th>Mechanism </th></tr>
<tr><td>Intel </td><td>RDRAND/RDSEED </td><td>Thermal noise + AES-CBC-MAC </td></tr>
<tr><td>AMD </td><td>RDRAND/RDSEED </td><td>Ring oscillator jitter </td></tr>
<tr><td>ARM </td><td>TRNG </td><td>Metastable flip-flops </td></tr>
<tr><td>RISC-V </td><td>Zkr extension </td><td>Implementation-defined </td></tr>
</table>
<p>Security note: Intel's RDRAND has faced scrutiny. Mix with other sources.</p>
<h3>Environmental Entropy: Lavarand</h3>
<p>The most famous entropy source in computing.</p>
<p>Silicon Graphics (SGI) invented Lavarand in 1996. Cloudflare operates the modern successor.</p>
<p>#### How It Works</p>
<pre class="diagram">
┌─────────────────────────────────────────────────────────────┐
│                     LAVARAND SYSTEM                          │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   ┌─────────┐    ┌─────────┐    ┌─────────────────────┐     │
│   │  Lava   │    │ Camera  │    │  Image → Hash       │     │
│   │  Lamp   │───▶│  Feed   │───▶│  SHA-256 per frame  │     │
│   │  Wall   │    │         │    │                     │     │
│   └─────────┘    └─────────┘    └──────────┬──────────┘     │
│                                            │                 │
│                                            ▼                 │
│                                  ┌─────────────────────┐     │
│                                  │  Entropy Pool       │     │
│                                  │  (mix with CSPRNG)  │     │
│                                  └─────────────────────┘     │
│                                                              │
└─────────────────────────────────────────────────────────────┘
</pre>
<p>#### Why Lava Lamps?</p>
<ul>
<li>Chaotic fluid dynamics - Wax movement is unpredictable</li>
<li>Thermal convection - Heat creates complex flow patterns</li>
<li>High bandwidth - Each video frame yields fresh entropy</li>
<li>Tamper-evident - Physical installation is visible</li>
<li>Independent source - Not correlated with CPU state</li>
</ul>
<p>Cloudflare's wall of 100 lava lamps generates entropy for ~10% of internet HTTPS traffic.</p>
<p>#### Other Environmental Sources</p>
<table>
<tr><th>Source </th><th>Mechanism </th><th>Bandwidth </th></tr>
<tr><td>Lava lamps </td><td>Fluid dynamics </td><td>~100 Kbit/s </td></tr>
<tr><td>Radioactive decay </td><td>Nuclear physics </td><td>~1-10 Kbit/s </td></tr>
<tr><td>Atmospheric noise </td><td>RF antenna </td><td>~1 Mbit/s </td></tr>
<tr><td>Thermal camera </td><td>Johnson-Nyquist noise </td><td>~10 Kbit/s </td></tr>
<tr><td>Double pendulum </td><td>Chaotic motion </td><td>~100 bit/s </td></tr>
<tr><td>Keyboard timing </td><td>Human unpredictability </td><td>~1-10 bit/keystroke </td></tr>
</table>
<h3>Public Randomness Beacons</h3>
<p>Beacons provide verifiable public randomness - useful for: - Lottery systems - Audit sampling - Distributed protocols - Zero-knowledge proofs</p>
<p>#### NIST Randomness Beacon</p>
<p>The National Institute of Standards and Technology operates a public randomness beacon since 2013.</p>
<pre>
https://beacon.nist.gov/beacon/2.0/pulse/last
</pre>
<p>Architecture:</p>
<pre class="diagram">
┌─────────────────────────────────────────────────────────────┐
│                   NIST BEACON 2.0                            │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  Sources:           Processing:         Output:              │
│  ┌─────────┐       ┌───────────┐      ┌──────────────┐      │
│  │ Quantum │──┐    │           │      │ Pulse Record │      │
│  │   RNG   │  │    │  SHA-512  │      ├──────────────┤      │
│  └─────────┘  │    │  mixing   │      │ timestamp    │      │
│  ┌─────────┐  ├───▶│     +     │─────▶│ localRandom  │      │
│  │Photonic │  │    │  signing  │      │ outputValue  │      │
│  │  Noise  │──┘    │           │      │ signatureVal │      │
│  └─────────┘       └───────────┘      └──────────────┘      │
│                                                              │
│  Pulse interval: 60 seconds                                  │
│  Hash chain: Each pulse includes hash of previous            │
│  Signature: RSA-2048 (Beacon 2.0)                           │
│                                                              │
└─────────────────────────────────────────────────────────────┘
</pre>
<p>Pulse Record Contents: - uri - Unique pulse identifier - version - Beacon protocol version - timeStamp - Unix timestamp - localRandomValue - 512 bits from quantum sources - outputValue - SHA-512 hash (the public random value) - statusCode - Health indicator - signatureValue - Digital signature</p>
<p>Properties: - Unpredictable - Cannot be known before publication - Verifiable - Anyone can verify the signature chain - Non-manipulable - NIST cannot control output - Archived - Full history publicly available</p>
<p>Use in Cyberspace:</p>
<pre class="language-scheme">
;; For ceremonies, audits, public verifiability
(define (fetch-nist-beacon)
  (let* ((response (http-get "https://beacon.nist.gov/beacon/2.0/pulse/last"))
         (pulse (json-parse response))
         (output (assoc-ref pulse "outputValue")))
    (hex-&gt;blob output)))
</pre>
<p>#### Other Public Beacons</p>
<table>
<tr><th>Beacon </th><th>Operator </th><th>Source </th><th>Interval </th></tr>
<tr><td>NIST Beacon </td><td>US NIST </td><td>Quantum + photonic </td><td>60 seconds </td></tr>
<tr><td>Chile UChile </td><td>University of Chile </td><td>Seismic + radio </td><td>60 seconds </td></tr>
<tr><td>Cloudflare drand </td><td>League of Entropy </td><td>Distributed threshold </td><td>30 seconds </td></tr>
<tr><td>IRISA </td><td>French research </td><td>Multiple physical </td><td>60 seconds </td></tr>
</table>
<p>#### League of Entropy (drand)</p>
<p>Distributed randomness beacon - no single party controls the output:</p>
<pre class="diagram">
┌─────────────────────────────────────────────────────────────┐
│              DRAND DISTRIBUTED BEACON                        │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   Cloudflare ──┐                                            │
│                │                                             │
│   EPFL ────────┼─── Threshold ───▶ Public Random           │
│                │    BLS Sig          (t-of-n nodes          │
│   Protocol ────┤    (t-of-n)          must participate)     │
│   Labs         │                                             │
│                │                                             │
│   Kudelski ────┘                                            │
│                                                              │
│   Endpoint: https://api.drand.sh/public/latest              │
│   Chain: 8990e7a9aaed2ffed73dbd7092123d6f289930540d7651336225dc172e51b2ce │
│                                                              │
└─────────────────────────────────────────────────────────────┘
</pre>
<h3>Entropy Mixing</h3>
<p>Real systems mix multiple sources for defense in depth:</p>
<pre class="language-scheme">
;; Conceptual entropy mixer
(define (mix-entropy-sources)
  (let ((hw (hardware-random-bytes 32))      ;; RDRAND
        (os (os-entropy-pool-bytes 32))       ;; /dev/urandom
        (env (environmental-entropy 32))      ;; If available
        (beacon (cached-nist-beacon)))        ;; Public verifiability
    ;; Mix with HKDF or similar
    (hkdf-sha512
      (blob-append hw os env beacon)
      "cyberspace-entropy-v1"
      64)))
</pre>
<h3>Historical Entropy Failures</h3>
<p>Learning from disasters:</p>
<table>
<tr><th>Incident </th><th>Year </th><th>Cause </th><th>Impact </th></tr>
<tr><td>Netscape SSL </td><td>1995 </td><td>PID + timestamp = predictable </td><td>All SSL broken </td></tr>
<tr><td>Debian OpenSSL </td><td>2006-2008 </td><td>Valgrind "fix" removed entropy </td><td>32,767 possible keys </td></tr>
<tr><td>Android SecureRandom </td><td>2013 </td><td>PRNG state reuse </td><td>Bitcoin wallets drained </td></tr>
<tr><td>DualECDRBG </td><td>2013 </td><td>NSA backdoor in constants </td><td>Unknown surveillance </td></tr>
<tr><td>Taiwan smart cards </td><td>2013 </td><td>Shared PRNG state </td><td>Factored RSA keys </td></tr>
</table>
<p>Lesson: Defense in depth. Mix multiple independent sources.</p>
<h3>Entropy Requirements by Operation</h3>
<table>
<tr><th>Operation </th><th>Entropy Needed </th><th>Notes </th></tr>
<tr><td>Ed25519 keypair </td><td>32 bytes </td><td>Full key security </td></tr>
<tr><td>X25519 keypair </td><td>32 bytes </td><td>Full key security </td></tr>
<tr><td>XSalsa20 nonce </td><td>24 bytes </td><td>Random OK (large space) </td></tr>
<tr><td>AES-GCM nonce </td><td>12 bytes </td><td>Counter preferred (small space) </td></tr>
<tr><td>Argon2id salt </td><td>16 bytes </td><td>Unique per derivation </td></tr>
<tr><td>Session ID </td><td>16-32 bytes </td><td>Unpredictable </td></tr>
<tr><td>ECDSA k-value </td><td>32 bytes </td><td>CRITICAL - must not repeat </td></tr>
</table>
</section>
<section>
<h2>Security Considerations</h2>
<h3>Entropy Exhaustion</h3>
<p>libsodium's randombytes_buf() never blocks on modern systems: - Uses ChaCha20 CSPRNG seeded from OS entropy - OS entropy pools are continuously replenished - Hardware RNG (RDRAND/RDSEED) available on modern CPUs</p>
<h3>VM/Container Considerations</h3>
<p>Virtual machines may have limited entropy at boot: - Use virtio-rng to pass host entropy to guests - Ensure haveged or rng-tools if entropy-limited - libsodium will block until sufficient entropy available</p>
<h3>Fork Safety</h3>
<p>libsodium handles fork correctly: - Automatic re-seeding after fork() - No duplicate random sequences in child processes</p>
<h3>Deterministic Testing</h3>
<p>For reproducible tests ONLY (never production):</p>
<pre class="language-scheme">
(define (set-test-seed seed)
  "WARNING: Deterministic mode - testing only"
  ((foreign-lambda void "randombytes_stir")))
</pre>
<p>Production code MUST use true entropy.</p>
</section>
<section>
<h2>Implementation Notes</h2>
<h3>Current Status</h3>
<table>
<tr><th>Component </th><th>Entropy Source </th><th>Status </th></tr>
<tr><td>crypto-ffi.scm </td><td>randombytes_buf() </td><td>Implemented </td></tr>
<tr><td>vault.scm (keystore) </td><td>random-bytes </td><td>Implemented </td></tr>
<tr><td>OCaml core </td><td>TBD </td><td>Open Issue </td></tr>
</table>
<h3>Audit Trail</h3>
<p>All key generation events should be logged (not the keys themselves):</p>
<pre class="language-scheme">
(seal-commit #f
  `(entropy-event
    (type "key-generation")
    (algorithm "ed25519")
    (timestamp ,(current-seconds))
    (entropy-source "libsodium")))
</pre>
<h3>Hardware Entropy</h3>
<p>When available, hardware entropy sources enhance security:</p>
<table>
<tr><th>Platform </th><th>Hardware RNG </th></tr>
<tr><td>Intel/AMD </td><td>RDRAND, RDSEED instructions </td></tr>
<tr><td>ARM </td><td>TRNG (True Random Number Generator) </td></tr>
<tr><td>Apple Silicon </td><td>Secure Enclave entropy </td></tr>
</table>
<p>libsodium automatically uses hardware entropy when available.</p>
</section>
<section>
<h2>Migration</h2>
<h3>Phase 1: Audit (Complete)</h3>
<ul>
<li>Identified all randomness usage in codebase ✓</li>
<li>Replaced non-libsodium sources ✓</li>
<li>Fixed: repl.scm collapse used (random), now uses random-uniform</li>
<li>Fixed: forge.scm read /dev/urandom directly, now uses crypto-ffi</li>
</ul>
<h3>Phase 2: Standardize (Complete)</h3>
<ul>
<li>All Scheme uses random-bytes/random-uniform from crypto-ffi ✓</li>
<li>OCaml approach: TBD (will use libsodium FFI)</li>
</ul>
<h3>Phase 3: Verify (Complete)</h3>
<ul>
<li>FIPS 140-2 statistical tests implemented in fips.scm ✓</li>
<li>Boot-time entropy verification on every REPL start ✓</li>
<li>forge module verifies entropy source on load ✓</li>
</ul>
<h3>Phase 4: Quantum (Future)</h3>
<ul>
<li>Hardware quantum RNG support (ID Quantique, etc.)</li>
<li>Attestation of entropy source in realm metadata</li>
<li>Federated quantum entropy from partner realms</li>
</ul>
</section>
<section>
<h2>References</h2>
<ul>
<li>libsodium documentation: https://doc.libsodium.org/</li>
<li>NIST SP 800-90A: Recommendations for Random Number Generation</li>
<li>RFC 4086: Randomness Requirements for Security</li>
<li>ChaCha20: https://cr.yp.to/chacha.html</li>
</ul>
</section>
<section>
<h2>Appendix: Entropy Quality Testing</h2>
<h3>Built-in FIPS Tests</h3>
<p>The fips.scm module provides FIPS 140-2 statistical tests that run automatically at boot:</p>
<pre class="language-scheme">
;; Run all FIPS tests manually
(import fips)
(test-randomness)  ; =&gt; #t or #f

;; Individual tests on 2500 bytes
(let ((sample (blob-&gt;u8vector (random-bytes 2500))))
  (fips-monobit-test sample)
  (fips-poker-test sample)
  (fips-runs-test sample)
  (fips-long-run-test sample))
</pre>
<h3>External Verification</h3>
<p>For additional paranoid verification with external tools:</p>
<pre class="language-bash">
# Generate random data
csi -e "(import crypto-ffi) (display (random-bytes 1000000))" &gt; random.bin

# Run NIST statistical tests
ent random.bin
dieharder -a -f random.bin
</pre>
<p>Expected results: - Entropy: ~7.9999 bits per byte - Chi-square: p-value 0.01-0.99 - All dieharder tests: PASSED</p>
</section>
<script>
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
}
(function() {
  // Query param override (for REPL: ?theme=dark or ?theme=light)
  const params = new URLSearchParams(window.location.search);
  const param = params.get('theme');
  if (param === 'dark' || param === 'light') {
    document.documentElement.setAttribute('data-theme', param);
    localStorage.setItem('theme', param);
    return;
  }
  // localStorage preference
  const saved = localStorage.getItem('theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
  } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script>
</body>
</html>
