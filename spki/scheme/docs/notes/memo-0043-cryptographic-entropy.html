<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <title>Memo 0043: Cryptographic Entropy Sources</title>
  <link rel="icon" id="favicon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27%230f0%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>">
  <script>
(function(){
  var h=new Date().getHours(),c;
  if(h>=4&&h<6)c='%23845EC2';       // brahma muhurta - violet
  else if(h>=6&&h<8)c='%23ffd700';  // dawn - gold
  else if(h>=8&&h<11)c='%2300d4aa'; // morning - teal
  else if(h>=11&&h<14)c='%230f0';   // midday - phosphor
  else if(h>=14&&h<17)c='%2339ff14';// afternoon - neon
  else if(h>=17&&h<19)c='%23ff6600';// sunset - orange
  else if(h>=19&&h<22)c='%23ff3366';// evening - coral
  else c='%2300ffff';               // night - cyan
  document.getElementById('favicon').href='data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27'+c+'%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>';
})();
</script>
  <link rel="stylesheet" href="memo.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<h1>Memo 0043: Cryptographic Entropy Sources</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>All cryptographic operations in Cyberspace require high-quality entropy. This Memo specifies the canonical entropy sources for each platform, ensuring consistent, auditable, and secure randomness across the entire system.</p>
</section>
<section>
<h2>Motivation</h2>
<h3>The Fundamental Requirement</h3>
<p>All cryptography requires true quantum randomness. The math doesn't work otherwise.</p>
<p>Cryptographic proofs assume a source of bits that are: 1. Statistically uniform - Each bit equally likely 0 or 1 2. Independent - No correlations between bits 3. Unpredictable in principle - Not just hard to predict, but impossible</p>
<p>Only quantum mechanical processes satisfy condition 3. Classical chaotic systems (lava lamps, thermal noise, ring oscillators) are deterministic - an adversary with sufficient knowledge of initial conditions could, in theory, predict their output. Quantum processes have no "initial conditions" to know - the randomness is fundamental to physics itself.</p>
<p>Why this matters: - Security proofs assume perfect randomness - Key security = min(algorithmbits, entropybits) - A 256-bit key from a 32-bit PRNG seed provides only 32 bits of security - Nation-state adversaries may have capabilities to model classical entropy sources</p>
<h3>Cryptographic Operations Requiring Entropy</h3>
<ul>
<li>Key generation (Ed25519, X25519)</li>
<li>Nonce generation (XSalsa20-Poly1305)</li>
<li>Salt generation (Argon2id)</li>
<li>Shamir secret sharing</li>
<li>Challenge-response protocols</li>
<li>Zero-knowledge proofs</li>
</ul>
<p>Weak or predictable entropy destroys security completely. A realm's sovereignty depends on unpredictable secrets.</p>
</section>
<section>
<h2>Specification</h2>
<h3>Canonical Source: libsodium</h3>
<p>All Cyberspace implementations MUST use libsodium's randombytes_buf() as the primary entropy source:</p>
<pre>
randombytes_buf(buffer, size)
</pre>
<p>libsodium automatically selects the best available source: - Linux: getrandom(2) syscall, falls back to /dev/urandom - macOS/iOS: arc4randombuf() - Windows: RtlGenRandom() - OpenBSD: arc4randombuf() (ChaCha20-based)</p>
<h3>Why libsodium?</h3>
<p>1. Cross-platform consistency - Same API everywhere 2. Automatic best-source selection - No platform-specific code 3. Initialization safety - Blocks until entropy available 4. Fork safety - Handles process forking correctly 5. Audited implementation - Widely reviewed cryptographic library</p>
<h3>Platform Requirements</h3>
<p>#### Scheme (CHICKEN)</p>
<pre class="language-scheme">
;; crypto-ffi.scm provides:
(define (random-bytes n)
  "Generate n cryptographically secure random bytes"
  (let ((buf (make-blob n)))
    ((foreign-lambda void "randombytes_buf" scheme-pointer unsigned-integer)
     buf n)
    buf))
</pre>
<p>All Scheme code MUST use random-bytes from crypto-ffi. NEVER use: - (chicken random) - Uses PRNG, not cryptographically secure - /dev/random directly - Platform-specific, may block - Custom PRNGs - Unaudited, likely insecure</p>
<p>#### OCaml</p>
<p>Status: Open Issue</p>
<p>OCaml implementations should use one of: - mirage-crypto-rng with Nocrypto.Rng.generate - Direct FFI to libsodium via ctypes</p>
<p>Decision pending based on: - Multicore OCaml compatibility - Domain-local PRNG state handling - Build system integration (dune vs opam)</p>
<h3>Entropy Initialization</h3>
<p>Before ANY cryptographic operation, ensure libsodium is initialized:</p>
<pre class="language-scheme">
(define (sodium-init)
  (let ((result ((foreign-lambda int "sodiuminit"))))
    (when (= result -1)
      (error "sodiuminit failed - entropy source unavailable"))))
</pre>
<p>sodium_init() is idempotent and thread-safe. Call it early in program startup.</p>
<h3>Key Generation</h3>
<p>All key generation MUST use libsodium's key generation functions, which internally use randombytes_buf():</p>
<table>
<tr><th>Operation </th><th>Function </th></tr>
<tr><td>Ed25519 signing key </td><td>cryptosignkeypair() </td></tr>
<tr><td>X25519 key exchange </td><td>cryptoboxkeypair() </td></tr>
<tr><td>Symmetric key </td><td>cryptosecretboxkeygen() </td></tr>
<tr><td>Generic random </td><td>randombytes_buf() </td></tr>
</table>
<h3>Nonce Generation</h3>
<p>Nonces MUST be generated fresh for each encryption:</p>
<pre class="language-scheme">
(define (generate-nonce)
  (random-bytes (secretbox-noncebytes)))  ;; 24 bytes
</pre>
<p>For XSalsa20-Poly1305 with 24-byte nonces, random nonces are safe: - 2^192 possible nonces - Birthday collision after ~2^96 messages - Practical limit: ~2^64 messages per key (still astronomical)</p>
<h3>Salt Generation</h3>
<p>For Argon2id key derivation:</p>
<pre class="language-scheme">
(define (generate-salt)
  (random-bytes 16))  ;; cryptopwhashSALTBYTES
</pre>
<p>Salts prevent rainbow table attacks. Each salt MUST be unique per derived key.</p>
</section>
<section>
<h2>Deep Dive: Entropy Sources</h2>
<p>Randomness is the foundation of all cryptography. This section explores the physics and engineering of true randomness.</p>
<h3>The Entropy Hierarchy</h3>
<div class="diagram-container">
