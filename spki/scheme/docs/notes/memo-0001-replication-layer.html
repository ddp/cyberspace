<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <title>Memo 0001: Replication Layer for Library of Cyberspace</title>
  <link rel="icon" id="favicon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27%230f0%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>">
  <script>
(function(){
  var h=new Date().getHours(),c;
  if(h>=4&&h<6)c='%23845EC2';       // brahma muhurta - violet
  else if(h>=6&&h<8)c='%23ffd700';  // dawn - gold
  else if(h>=8&&h<11)c='%2300d4aa'; // morning - teal
  else if(h>=11&&h<14)c='%230f0';   // midday - phosphor
  else if(h>=14&&h<17)c='%2339ff14';// afternoon - neon
  else if(h>=17&&h<19)c='%23ff6600';// sunset - orange
  else if(h>=19&&h<22)c='%23ff3366';// evening - coral
  else c='%2300ffff';               // night - cyan
  document.getElementById('favicon').href='data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27'+c+'%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>';
})();
</script>
  <link rel="stylesheet" href="memo.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<h1>Memo 0001: Replication Layer for Library of Cyberspace</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This Memo specifies a replication layer for the Library of Cyberspace preservation architecture, enabling cryptographically sealed releases to be published, subscribed to, and synchronized across distributed locations while maintaining tamper-evident audit trails.</p>
</section>
<section>
<h2>Motivation</h2>
<h3>Heritage: "Behave as One"</h3>
<p>The VAXcluster principle (1984): N nodes must behave as one. Not eventually consistent. Not loosely coupled. Identical. One security domain, one namespace, one view of the world.</p>
<p>DECnet Phase IV's 24-bit addressing was fatal for internet scale. Cyberspace applies the same principle to IPv6's 128-bit address space. Federated nodes, behaving as one.</p>
<h3>Requirements</h3>
<p>The Library of Cyberspace requires a distribution mechanism that:</p>
<p>1. Preserves cryptographic authenticity - Signatures travel with artifacts 2. Enables offline verification - No centralized authority required 3. Records provenance - All publication events are audited 4. Supports multiple transports - Git, HTTP, filesystem 5. Maintains loose coupling - Works for confederations of friends</p>
<p>Traditional package managers and distribution systems assume centralized registries and online verification. This replication layer is designed for decentralized, long-term preservation where trust is established through SPKI certificates and cryptographic seals.</p>
</section>
<section>
<h2>Design Principles</h2>
<p>1. Sealed Releases - Only cryptographically signed releases can be published 2. Transport Agnostic - Same API works for git, HTTP, filesystem 3. Audit Everything - All replication events are recorded in tamper-evident log 4. Verify Before Trust - Subscribers must verify cryptographic seals 5. Explicit Authorization - SPKI certificates determine who can publish</p>
</section>
<section>
<h2>Specification</h2>
<h3>Three Core Operations</h3>
<p>#### 1. seal-publish</p>
<p>Publish a sealed release to a remote location.</p>
<pre class="language-scheme">
(seal-publish version
              remote: target
              archive-format: format
              message: notes)
</pre>
<p>Parameters: - version - Semantic version string (e.g., "1.0.0") - remote - Publication target (git remote, URL, or directory path) - archive-format - 'tarball, 'bundle, or 'cryptographic (default) - message - Release notes (optional)</p>
<p>Behavior: 1. Verify release exists (creates if needed via seal-release) 2. Create cryptographic archive with:    - Tarball of repository at version tag    - SHA-512 hash of tarball    - Ed25519 signature of hash    - Manifest with version, hash, signature 3. Publish to remote based on type:    - Git remote: Push tag, optionally upload archive    - HTTP URL: POST archive to endpoint    - Filesystem: Copy archive to directory 4. Record publication in audit trail with:    - Actor (public key from signing key)    - Action (seal-publish version remote)    - Motivation (release notes)    - Cryptographic seal (signature)</p>
<p>Audit Entry Format:</p>
<pre class="language-scheme">
(audit-entry
  (id "sha512:...")
  (timestamp "Mon Jan 5 23:38:20 2026")
  (sequence 1)
  (actor
    (principal #${public-key-blob})
    (authorization-chain))
  (action
    (verb seal-publish)
    (object "1.0.0")
    (parameters "/path/to/remote"))
  (context
    (motivation "Published to filesystem")
    (language "en"))
  (environment
    (platform "unknown")
    (timestamp 1767685100))
  (seal
    (algorithm "ed25519-sha512")
    (content-hash "...")
    (signature "...")))
</pre>
<p>#### 2. seal-subscribe</p>
<p>Subscribe to sealed releases from a remote source.</p>
<pre class="language-scheme">
(seal-subscribe remote
                target: local-path
                verify-key: public-key)
</pre>
<p>Parameters: - remote - Source location (git remote, URL, or directory) - target - Local path for downloaded archives (optional) - verify-key - Public key for signature verification (optional)</p>
<p>Behavior: 1. Discover available releases from remote:    - Git remote: List tags    - HTTP URL: GET /releases endpoint    - Filesystem: List .archive files 2. Download cryptographic archives 3. Verify each archive:    - Check manifest structure    - Verify SHA-512 hash of tarball    - Verify Ed25519 signature (if verify-key provided) 4. Extract verified archives to target directory 5. Record subscription in audit trail:    - Count of releases downloaded    - Source location    - Verification status</p>
<p>Security Consideration: Without verify-key, subscription downloads archives but cannot verify authenticity. SPKI certificate chains should be used to establish trust.</p>
<p>#### 3. seal-synchronize</p>
<p>Bidirectional synchronization of sealed releases.</p>
<pre class="language-scheme">
(seal-synchronize remote
                  direction: 'both
                  verify-key: public-key)
</pre>
<p>Parameters: - remote - Sync target (git remote, URL, or directory) - direction - 'both (default), 'push-only, or 'pull-only - verify-key - Public key for signature verification (optional)</p>
<p>Behavior: 1. Discover local and remote releases 2. Compare versions to determine:    - Releases to push (local but not remote)    - Releases to pull (remote but not local) 3. Execute publication for new local releases 4. Execute subscription for new remote releases 5. Record synchronization in audit trail:    - Count pushed and pulled    - Remote location    - Direction</p>
<p>Use Case: Periodic sync between trusted peers in a confederation.</p>
</section>
<section>
<h2>Archive Format</h2>
<h3>Cryptographic Archive Structure</h3>
<pre>
vault-1.0.0.archive          # Manifest file
vault-1.0.0.archive.tar.gz   # Actual tarball
</pre>
<p>Manifest S-expression:</p>
<pre class="language-scheme">
(sealed-archive
  (version "1.0.0")
  (format cryptographic)
  (tarball "vault-1.0.0.archive.tar.gz")
  (hash "sha512:...")
  (signature "ed25519:...")
  (timestamp 1767685100)
  (sealer #${public-key-blob}))
</pre>
<p>Verification Steps: 1. Read manifest 2. Hash tarball with SHA-512 3. Verify hash matches manifest 4. Verify Ed25519 signature on hash 5. Check SPKI authorization (optional)</p>
</section>
<section>
<h2>Transport Implementations</h2>
<h3>Git Remote</h3>
<ul>
<li>Uses git push to share tags</li>
<li>Optionally uploads archives as release assets (GitHub, GitLab)</li>
<li>Fetch uses git fetch + git tag -l</li>
</ul>
<h3>HTTP Endpoint</h3>
<ul>
<li>POST to /releases/&lt;version&gt; for publication</li>
<li>GET /releases for discovery</li>
<li>Content-Type: application/x-sealed-archive</li>
</ul>
<h3>Filesystem</h3>
<ul>
<li>Copy archives to shared directory</li>
<li>Directory structure: &lt;remote&gt;/&lt;archive-name&gt;</li>
<li>No network required, works with NFS, USB drives, etc.</li>
</ul>
</section>
<section>
<h2>Audit Integration</h2>
<p>Every replication operation creates an audit entry with:</p>
<p>1. Content-addressed ID - SHA-512 hash of entry 2. Chained structure - References parent entry 3. SPKI principal - Public key of actor 4. Dual context - Human motivation + machine environment 5. Cryptographic seal - Ed25519 signature</p>
<p>This provides: - Non-repudiation - Cannot deny publication - Tamper evidence - Changes are detectable - Causality - Chain shows temporal order - Accountability - Know who published what when</p>
</section>
<section>
<h2>Security Considerations</h2>
<h3>Threat Model</h3>
<p>Trusted: - Local filesystem and vault - SPKI private keys - Cryptographic primitives (libsodium)</p>
<p>Untrusted: - Remote repositories - Network transport - Downloaded archives - Remote publishers (until SPKI verified)</p>
<h3>Attack Scenarios</h3>
<p>1. Malicious Archive Substitution    - Attacker replaces archive on remote    - Mitigation: Signature verification fails</p>
<p>2. Version Rollback Attack    - Attacker removes newer releases    - Mitigation: Audit trail shows previous versions</p>
<p>3. Unauthorized Publication    - Attacker publishes fake release    - Mitigation: SPKI authorization chain required</p>
<p>4. Transport Tampering    - Network attacker modifies download    - Mitigation: Hash and signature verification</p>
<h3>Best Practices</h3>
<p>1. Always verify signatures - Use verify-key parameter 2. Check SPKI certificates - Verify authorization chain 3. Maintain audit trail - Detect suspicious patterns 4. Use HTTPS for HTTP transport - Prevent network attacks 5. Backup signing keys - Use Shamir secret sharing</p>
</section>
<section>
<h2>Implementation Notes</h2>
<h3>Helper Functions</h3>
<pre class="language-scheme">
(tag-exists? tag-name)        ; Check if git tag exists
(git-remote? str)             ; Detect git remote format
(http-url? str)               ; Detect HTTP/HTTPS URL
(publish-filesystem remote version archive)  ; Copy to directory
(publish-http url version archive)           ; POST to endpoint
</pre>
<h3>Dependencies</h3>
<ul>
<li>Git</li>
<li>For version control and tag management - libsodium</li>
<li>Ed25519 signatures, SHA-512 hashing</li>
<li>Chicken Scheme modules:   - (chicken process)</li>
<li>Run git commands   - (chicken file)</li>
<li>Filesystem operations   - (chicken irregex)</li>
<li>URL/remote detection</li>
</ul>
</section>
<section>
<h2>Compatibility</h2>
<p>This specification is compatible with:</p>
<ul>
<li>Git tags</li>
<li>Standard git operations</li>
<li>Git bundles</li>
<li>Portable repository format</li>
<li>Tarball archives</li>
<li>Universal archive format</li>
<li>S-expressions</li>
<li>LISP/Scheme readable format</li>
<li>SPKI/SDSI</li>
<li>Authorization certificates</li>
</ul>
<p>Future extensions may add: - IPFS transport - Content-addressed distribution - Tor hidden services - Anonymous publication - Encrypted archives - Confidential distribution - Multi-signature releases - Threshold authorization</p>
</section>
<section>
<h2>Test Coverage</h2>
<p>See test-replication.scm:</p>
<pre class="language-scheme">
;; Test seal-publish to filesystem
(seal-publish "1.0.0"
              remote: "/tmp/cyberspace-publish-test"
              message: "Published to filesystem")

;; Verify archive exists
(file-exists? "/tmp/cyberspace-publish-test/vault-1.0.0.archive")

;; Verify audit entry created
(audit-read sequence: 1)
</pre>
</section>
<section>
<h2>References</h2>
<p>1. SPKI/SDSI - RFC 2693, RFC 2692 2. Content-Addressed Storage - Git internals, IPFS 3. Semantic Versioning - semver.org 4. Ed25519 - Bernstein et al. 5. Audit Trails - Memo-002 (Cryptographic Audit Trail)</p>
</section>
<section>
<h2>Changelog</h2>
<ul>
<li>2026-01-05</li>
<li>Initial implementation and specification   - seal-publish with git/HTTP/filesystem support   - seal-subscribe with signature verification   - seal-synchronize with bidirectional sync  </li>
<li>Full audit trail integration  </li>
<li>Cryptographic archive format</li>
</ul>
</section>
<script>
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
}
(function() {
  // Query param override (for REPL: ?theme=dark or ?theme=light)
  const params = new URLSearchParams(window.location.search);
  const param = params.get('theme');
  if (param === 'dark' || param === 'light') {
    document.documentElement.setAttribute('data-theme', param);
    localStorage.setItem('theme', param);
    return;
  }
  // localStorage preference
  const saved = localStorage.getItem('theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
  } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script>
</body>
</html>
