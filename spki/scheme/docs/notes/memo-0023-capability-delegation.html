<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <title>Memo 0023: Capability Delegation Patterns</title>
  <link rel="icon" id="favicon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27%230f0%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>">
  <script>
(function(){
  var h=new Date().getHours(),c;
  if(h>=4&&h<6)c='%23845EC2';       // brahma muhurta - violet
  else if(h>=6&&h<8)c='%23ffd700';  // dawn - gold
  else if(h>=8&&h<11)c='%2300d4aa'; // morning - teal
  else if(h>=11&&h<14)c='%230f0';   // midday - phosphor
  else if(h>=14&&h<17)c='%2339ff14';// afternoon - neon
  else if(h>=17&&h<19)c='%23ff6600';// sunset - orange
  else if(h>=19&&h<22)c='%23ff3366';// evening - coral
  else c='%2300ffff';               // night - cyan
  document.getElementById('favicon').href='data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27'+c+'%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>';
})();
</script>
  <link rel="stylesheet" href="memo.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<h1>Memo 0023: Capability Delegation Patterns</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This Memo specifies capability delegation patterns for the Library of Cyberspace: how principals grant, attenuate, and revoke capabilities using SPKI certificates, content-addressed objects, and the soup metadata layer. Capabilities flow through delegation chains with monotonically decreasing authority.</p>
</section>
<section>
<h2>Motivation</h2>
<p>Authorization in distributed systems is hard:</p>
<p>- ACLs don't scale - Central lists become bottlenecks - Identity is fragile - Names change, keys rotate - Ambient authority is dangerous - "Run as root" is not a security model - Revocation is an afterthought - Usually bolted on badly</p>
<p>Simple Distributed Security Infrastructure/Simple Public Key Infrastructure (SDSI/SPKI) solved this decades ago:</p>
<ul>
<li>Capabilities, not identities</li>
<li>What you can do, not who you are</li>
<li>Local names</li>
<li>No global namespace required</li>
<li>Delegation chains</li>
<li>Authority flows from source to delegate</li>
<li>Threshold signatures</li>
<li>M-of-N for critical operations</li>
</ul>
<p>These principles eliminate the central authority problem: authorization decisions are local, verifiable, and require no trusted third party.</p>
<p>The Library integrates SPKI with content-addressed storage, creating capabilities that are themselves content-addressed and introspectable.</p>
</section>
<section>
<h2>Capability Model</h2>
<h3>Principals</h3>
<p>A principal is anything that can hold authority:</p>
<pre class="language-scheme">
;; Key principal - most common
(make-principal
  (type key)
  (algorithm ed25519)
  (public-key #${...32 bytes...}))

;; Hash principal - content-addressed object
(make-principal
  (type hash)
  (algorithm sha256)
  (digest #${...32 bytes...}))

;; Threshold principal - M-of-N group
(make-principal
  (type threshold)
  (threshold 3)
  (members (key1 key2 key3 key4 key5)))

;; Name principal - local binding
(make-principal
  (type name)
  (issuer parent-key)
  (name "alice"))
</pre>
<h3>Capabilities</h3>
<p>A capability is a transferable right to perform an action:</p>
<pre class="language-scheme">
(capability
  (action read)
  (object (hash sha256 "content-hash...")))

(capability
  (action write)
  (object (tree sha256 "subtree-root...")))

(capability
  (action sign)
  (object (tag "releases/*")))

(capability
  (action delegate)
  (object (capability ...)))  ; Meta-capability
</pre>
<h3>Certificates</h3>
<p>SPKI certificates bind capabilities to principals:</p>
<pre class="language-scheme">
(spki-cert
  (issuer vault-master-key)
  (subject alice-key)
  (capability
    (action read)
    (object (tree sha256 "docs-root...")))
  (validity
    (not-before "2026-01-01")
    (not-after "2027-01-01"))
  (delegation #t))  ; Alice can re-delegate
</pre>
</section>
<section>
<h2>Delegation Chains</h2>
<h3>Chain Structure</h3>
<p>Authority flows through certificate chains:</p>
<div class="diagram-container">
<svg class="diagram" viewBox="0 0 560 200" width="560" height="200" xmlns="http://www.w3.org/2000/svg">
<style>
  .diagram line { stroke: currentColor; stroke-width: 1.5; stroke-linecap: square; }
  .diagram rect { fill: currentColor; }
  .diagram text { font-family: monospace; font-size: 14px; fill: currentColor; text-anchor: middle; dominant-baseline: central; }
</style>
<text x="5" y="10">M</text>
<text x="15" y="10">a</text>
<text x="25" y="10">s</text>
<text x="35" y="10">t</text>
<text x="45" y="10">e</text>
<text x="55" y="10">r</text>
<text x="75" y="10">K</text>
<text x="85" y="10">e</text>
<text x="95" y="10">y</text>
<line x1="45" y1="20" x2="45" y2="40"/>
<text x="45" y="50">↓</text>
<text x="65" y="50">(</text>
<text x="75" y="50">c</text>
<text x="85" y="50">e</text>
<text x="95" y="50">r</text>
<text x="105" y="50">t</text>
<text x="115" y="50">:</text>
<text x="135" y="50">f</text>
<text x="145" y="50">u</text>
<text x="155" y="50">l</text>
<text x="165" y="50">l</text>
<text x="185" y="50">a</text>
<text x="195" y="50">c</text>
<text x="205" y="50">c</text>
<text x="215" y="50">e</text>
<text x="225" y="50">s</text>
<text x="235" y="50">s</text>
<text x="255" y="50">t</text>
<text x="265" y="50">o</text>
<text x="285" y="50">v</text>
<text x="295" y="50">a</text>
<text x="305" y="50">u</text>
<text x="315" y="50">l</text>
<text x="325" y="50">t</text>
<text x="335" y="50">)</text>
<text x="5" y="70">A</text>
<text x="15" y="70">d</text>
<text x="25" y="70">m</text>
<text x="35" y="70">i</text>
<text x="45" y="70">n</text>
<text x="65" y="70">K</text>
<text x="75" y="70">e</text>
<text x="85" y="70">y</text>
<line x1="45" y1="80" x2="45" y2="100"/>
<text x="45" y="110">↓</text>
<text x="65" y="110">(</text>
<text x="75" y="110">c</text>
<text x="85" y="110">e</text>
<text x="95" y="110">r</text>
<text x="105" y="110">t</text>
<text x="115" y="110">:</text>
<text x="135" y="110">r</text>
<text x="145" y="110">e</text>
<text x="155" y="110">a</text>
<text x="165" y="110">d</text>
<text x="175" y="110">/</text>
<text x="185" y="110">w</text>
<text x="195" y="110">r</text>
<text x="205" y="110">i</text>
<text x="215" y="110">t</text>
<text x="225" y="110">e</text>
<text x="245" y="110">t</text>
<text x="255" y="110">o</text>
<text x="275" y="110">d</text>
<text x="285" y="110">o</text>
<text x="295" y="110">c</text>
<text x="305" y="110">s</text>
<text x="315" y="110">/</text>
<text x="325" y="110">,</text>
<text x="345" y="110">c</text>
<text x="355" y="110">a</text>
<text x="365" y="110">n</text>
<text x="385" y="110">d</text>
<text x="395" y="110">e</text>
<text x="405" y="110">l</text>
<text x="415" y="110">e</text>
<text x="425" y="110">g</text>
<text x="435" y="110">a</text>
<text x="445" y="110">t</text>
<text x="455" y="110">e</text>
<text x="465" y="110">)</text>
<text x="5" y="130">D</text>
<text x="15" y="130">e</text>
<text x="25" y="130">v</text>
<text x="35" y="130">e</text>
<text x="45" y="130">l</text>
<text x="55" y="130">o</text>
<text x="65" y="130">p</text>
<text x="75" y="130">e</text>
<text x="85" y="130">r</text>
<text x="105" y="130">K</text>
<text x="115" y="130">e</text>
<text x="125" y="130">y</text>
<line x1="45" y1="140" x2="45" y2="160"/>
<text x="45" y="170">↓</text>
<text x="65" y="170">(</text>
<text x="75" y="170">c</text>
<text x="85" y="170">e</text>
<text x="95" y="170">r</text>
<text x="105" y="170">t</text>
<text x="115" y="170">:</text>
<text x="135" y="170">r</text>
<text x="145" y="170">e</text>
<text x="155" y="170">a</text>
<text x="165" y="170">d</text>
<text x="175" y="170">-</text>
<text x="185" y="170">o</text>
<text x="195" y="170">n</text>
<text x="205" y="170">l</text>
<text x="215" y="170">y</text>
<text x="235" y="170">t</text>
<text x="245" y="170">o</text>
<text x="265" y="170">d</text>
<text x="275" y="170">o</text>
<text x="285" y="170">c</text>
<text x="295" y="170">s</text>
<text x="305" y="170">/</text>
<text x="315" y="170">p</text>
<text x="325" y="170">u</text>
<text x="335" y="170">b</text>
<text x="345" y="170">l</text>
<text x="355" y="170">i</text>
<text x="365" y="170">c</text>
<text x="375" y="170">/</text>
<text x="385" y="170">,</text>
<text x="405" y="170">c</text>
<text x="415" y="170">a</text>
<text x="425" y="170">n</text>
<text x="435" y="170">n</text>
<text x="445" y="170">o</text>
<text x="455" y="170">t</text>
<text x="475" y="170">d</text>
<text x="485" y="170">e</text>
<text x="495" y="170">l</text>
<text x="505" y="170">e</text>
<text x="515" y="170">g</text>
<text x="525" y="170">a</text>
<text x="535" y="170">t</text>
<text x="545" y="170">e</text>
<text x="555" y="170">)</text>
<text x="5" y="190">C</text>
<text x="15" y="190">o</text>
<text x="25" y="190">n</text>
<text x="35" y="190">t</text>
<text x="45" y="190">r</text>
<text x="55" y="190">a</text>
<text x="65" y="190">c</text>
<text x="75" y="190">t</text>
<text x="85" y="190">o</text>
<text x="95" y="190">r</text>
<text x="115" y="190">K</text>
<text x="125" y="190">e</text>
<text x="135" y="190">y</text>
</svg>
</div>
<h3>Chain Validation</h3>
<pre class="language-scheme">
(define (validate-chain chain target-capability)
  "Validate delegation chain grants capability"
  (let loop ((certs chain)
             (current-authority 'unlimited))
    (if (null? certs)
        (capability-subset? target-capability current-authority)
        (let ((cert (car certs)))
          (and (verify-signature cert)
               (valid-time? cert)
               (not-revoked? cert)
               (capability-subset? (cert-capability cert) current-authority)
               (if (cert-delegation? cert)
                   (loop (cdr certs) (cert-capability cert))
                   (and (null? (cdr certs))
                        (capability-subset? target-capability
                                           (cert-capability cert)))))))))
</pre>
<h3>Monotonic Attenuation</h3>
<p>Delegated capabilities can only decrease:</p>
<pre class="language-scheme">
;; Alice has read/write to entire vault
(spki-cert
  (issuer master)
  (subject alice)
  (capability (action (read write)) (object vault-root))
  (delegation #t))

;; Alice delegates read-only to Bob (valid - attenuation)
(spki-cert
  (issuer alice)
  (subject bob)
  (capability (action read) (object vault-root))
  (delegation #t))

;; Bob tries to delegate write to Carol (INVALID - amplification)
(spki-cert
  (issuer bob)
  (subject carol)
  (capability (action write) (object vault-root))  ; REJECTED
  (delegation #f))

;; Bob delegates read to subtree only (valid - further attenuation)
(spki-cert
  (issuer bob)
  (subject carol)
  (capability (action read) (object docs-subtree))
  (delegation #f))
</pre>
</section>
<section>
<h2>Delegation Patterns</h2>
<h3>Pattern 1: Direct Delegation</h3>
<p>Simplest form - one hop:</p>
<pre class="language-scheme">
(define (delegate-direct issuer-key subject-key capability
                         #!key validity can-delegate)
  (sign-cert issuer-key
    `(spki-cert
      (issuer ,(key-&gt;principal issuer-key))
      (subject ,(key-&gt;principal subject-key))
      (capability ,capability)
      (validity ,validity)
      (delegation ,can-delegate))))
</pre>
<h3>Pattern 2: Role-Based Delegation</h3>
<p>Delegate to roles, bind keys to roles:</p>
<pre class="language-scheme">
;; Define role
(spki-cert
  (issuer vault-admin)
  (subject (name vault-admin "reviewer"))
  (capability (action read) (object (tag "pending/*")))
  (delegation #f))

;; Bind key to role
(spki-cert
  (issuer vault-admin)
  (subject alice-key)
  (capability (name vault-admin "reviewer"))
  (validity (not-after "2026-06-01")))

;; Alice now has reviewer capability via role binding
</pre>
<h3>Pattern 3: Threshold Delegation</h3>
<p>Require multiple parties:</p>
<pre class="language-scheme">
;; Critical operation requires 3-of-5
(spki-cert
  (issuer root-key)
  (subject (threshold 3 (key1 key2 key3 key4 key5)))
  (capability (action delete) (object vault-root))
  (delegation #f))

;; Exercise requires gathering signatures
(define (threshold-exercise capability signers)
  (let ((signatures (map (lambda (key) (sign key capability)) signers)))
    (if (&gt;= (length signatures) 3)
        (execute-capability capability signatures)
        (error "Insufficient signatures"))))
</pre>
<h3>Pattern 4: Time-Bounded Delegation</h3>
<p>Temporary access:</p>
<pre class="language-scheme">
;; Conference access - 3 days only
(spki-cert
  (issuer organizer-key)
  (subject attendee-key)
  (capability (action read) (object conference-materials))
  (validity
    (not-before "2026-03-15T09:00:00Z")
    (not-after "2026-03-17T18:00:00Z"))
  (delegation #f))
</pre>
<h3>Pattern 5: Conditional Delegation</h3>
<p>Capability with restrictions:</p>
<pre class="language-scheme">
;; Can read, but only from specific IP range
(spki-cert
  (issuer admin-key)
  (subject service-key)
  (capability (action read) (object api-data))
  (condition
    (source-ip "10.0.0.0/8"))
  (delegation #f))

;; Can write, but only objects under 1MB
(spki-cert
  (issuer admin-key)
  (subject uploader-key)
  (capability (action write) (object uploads))
  (condition
    (max-size 1048576))
  (delegation #f))
</pre>
<h3>Pattern 6: Proxy Delegation</h3>
<p>Delegate through intermediary:</p>
<pre class="language-scheme">
;; Alice delegates to proxy service
(spki-cert
  (issuer alice-key)
  (subject proxy-key)
  (capability (action read) (object alice-files))
  (delegation #t)
  (condition (proxy-for alice-key)))

;; Proxy can act on Alice's behalf
;; but chain shows Alice as original authority
</pre>
</section>
<section>
<h2>Content-Addressed Capabilities</h2>
<h3>Hash as Capability</h3>
<p>Knowledge of a content hash is itself a capability (Memo-020):</p>
<pre class="language-scheme">
;; Possessing this hash grants read access
(define secret-doc-hash "sha256:7f83b1657ff1fc...")

;; The hash is unguessable (256 bits of entropy)
;; Sharing the hash = sharing the capability
(define (share-capability recipient hash)
  (encrypted-send recipient hash))
</pre>
<h3>Capability Certificates for Hashes</h3>
<p>Formalize hash-based access:</p>
<pre class="language-scheme">
(spki-cert
  (issuer vault-key)
  (subject reader-key)
  (capability
    (action read)
    (object (hash sha256 "specific-doc...")))
  (validity (not-after "2027-01-01")))
</pre>
<h3>Tree Capabilities</h3>
<p>Grant access to Merkle subtree:</p>
<pre class="language-scheme">
(spki-cert
  (issuer vault-key)
  (subject team-key)
  (capability
    (action read)
    (object (tree sha256 "project-root..."))
    (propagate #t))  ; Includes all referenced objects
  (delegation #t))
</pre>
<h3>Sealed Capabilities</h3>
<p>Encrypt capability for specific recipient:</p>
<pre class="language-scheme">
(define (seal-capability cap recipient-pubkey)
  "Encrypt capability so only recipient can use it"
  (let ((serialized (serialize cap))
         (encrypted (age-encrypt serialized recipient-pubkey)))
    (cas-put encrypted)))

(define (unseal-capability sealed-hash identity)
  "Decrypt and exercise capability"
  (let ((encrypted (cas-get sealed-hash))
         (decrypted (age-decrypt encrypted identity))
         (cap (deserialize decrypted)))
    cap))
</pre>
</section>
<section>
<h2>Revocation</h2>
<h3>Revocation Lists</h3>
<pre class="language-scheme">
(spki-crl
  (issuer vault-admin)
  (revoked
    ((cert-hash "sha256:revoked1...")
     (reason key-compromise)
     (revoked-at 1767700000))
    ((cert-hash "sha256:revoked2...")
     (reason superseded)
     (revoked-at 1767700100))))
</pre>
<h3>Online Revocation Check</h3>
<pre class="language-scheme">
(define (check-revocation cert)
  "Check if certificate is revoked"
  (let* ((cert-hash (sha256 (serialize cert)))
         (issuer (cert-issuer cert))
         (crl (fetch-crl issuer)))
    (not (member cert-hash (crl-revoked-hashes crl)))))
</pre>
<h3>Tombstone Revocation</h3>
<p>Using CAS tombstones (Memo-020):</p>
<pre class="language-scheme">
(define (revoke-capability-tombstone cert-hash reason)
  "Revoke by tombstoning the certificate"
  (cas-tombstone cert-hash
    reason: reason
    actor: (current-principal)))
</pre>
<h3>Short-Lived Certificates</h3>
<p>Avoid revocation by using short validity:</p>
<pre class="language-scheme">
;; 1-hour certificate, no revocation needed
(spki-cert
  (issuer service-key)
  (subject session-key)
  (capability (action api-access))
  (validity
    (not-before ,(current-time))
    (not-after ,(+ (current-time) 3600)))
  (delegation #f))
</pre>
</section>
<section>
<h2>Soup Integration</h2>
<h3>Certificates in the Soup</h3>
<p>All certificates are soup objects:</p>
<pre class="language-scheme">
(soup-object
  (name "cert/alice-read-docs")
  (type certificate)
  (size "412B")
  (crypto (ed25519 sha256 "cert-hash..."))
  (issuer "vault-admin")
  (subject "alice")
  (capability "read docs/*")
  (expires "2027-01-01"))
</pre>
<h3>Querying Capabilities</h3>
<pre class="language-scheme">
;; Find all certificates for a subject
(soup-query type: 'certificate subject: alice-key)

;; Find all certificates granting write access
(soup-query type: 'certificate capability: 'write)

;; Find expiring certificates
(soup-query type: 'certificate
            expires-before: (+ (current-time) (* 7 24 3600)))

;; Find certificates from specific issuer
(soup-query type: 'certificate issuer: vault-admin)
</pre>
<h3>Capability Introspection</h3>
<pre class="language-scheme">
;; What can Alice do?
(define (principal-capabilities principal)
  (let ((certs (soup-query type: 'certificate subject: principal)))
    (map cert-capability certs)))

;; Who can read this object?
(define (object-readers hash)
  (let ((certs (soup-query type: 'certificate
                           capability: `(read ,hash))))
    (map cert-subject certs)))

;; Visualize delegation graph
(define (delegation-graph root-principal)
  (let ((certs (soup-query type: 'certificate issuer: root-principal)))
    (map (lambda (cert)
           (cons (cert-subject cert)
                 (delegation-graph (cert-subject cert))))
         certs)))
</pre>
</section>
<section>
<h2>Authorization Decisions</h2>
<h3>Simple Check</h3>
<pre class="language-scheme">
(define (authorized? principal action object)
  "Check if principal can perform action on object"
  (let ((chains (find-authorization-chains principal action object)))
    (any valid-chain? chains)))
</pre>
<h3>Chain Discovery</h3>
<pre class="language-scheme">
(define (find-authorization-chains principal action object)
  "Find all certificate chains granting capability"
  (let ((target-cap (capability action object)))
    (let search ((current principal) (chain '()))
      (let ((certs (soup-query type: 'certificate subject: current)))
        (append-map
          (lambda (cert)
            (if (capability-grants? (cert-capability cert) target-cap)
                (list (reverse (cons cert chain)))
                (if (cert-delegation? cert)
                    (search (cert-issuer cert) (cons cert chain))
                    '())))
          certs)))))
</pre>
<h3>Cached Authorization</h3>
<pre class="language-scheme">
(define auth-cache (make-lru-cache 10000))

(define (authorized?/cached principal action object)
  (let ((key (list principal action object)))
    (or (lru-get auth-cache key)
        (let ((result (authorized? principal action object)))
          (lru-put! auth-cache key result)
          result))))
</pre>
</section>
<section>
<h2>Delegation Ceremonies</h2>
<h3>Key Ceremony</h3>
<p>For critical delegations:</p>
<pre class="language-scheme">
(define (key-ceremony capability threshold witnesses)
  "Conduct witnessed delegation ceremony"
  (let* ((ceremony-id (generate-ceremony-id))
         (ceremony-record
          (ceremony
            (id ,ceremony-id)
            (capability ,capability)
            (threshold ,threshold)
            (witnesses ,witnesses)
            (started-at ,(current-time)))))

    ;; Record ceremony start
    (audit-append action: (ceremony-start ,ceremony-id))

    ;; Gather witness signatures
    (let ((signatures (gather-witness-signatures ceremony-record witnesses)))
      (if (&gt;= (length signatures) threshold)
          (let ((cert (finalize-ceremony ceremony-record signatures)))
            (audit-append action: (ceremony-complete ,ceremony-id))
            cert)
          (begin
            (audit-append action: (ceremony-failed ,ceremony-id))
            (error "Insufficient witnesses"))))))
</pre>
<h3>Emergency Revocation</h3>
<pre class="language-scheme">
(define (emergency-revoke cert-hash reason)
  "Emergency revocation with audit trail"
  (let ((revocation
         (emergency-revocation
           (cert ,cert-hash)
           (reason ,reason)
           (revoked-by ,(current-principal))
           (revoked-at ,(current-time)))))

    ;; Immediate tombstone
    (cas-tombstone cert-hash reason: reason)

    ;; Add to CRL
    (crl-append cert-hash reason)

    ;; Audit with high priority
    (audit-append
      action: (emergency-revoke ,cert-hash)
      motivation: reason
      priority: 'critical)

    ;; Notify affected parties
    (notify-revocation cert-hash)))
</pre>
</section>
<section>
<h2>Security Considerations</h2>
<h3>Capability Leakage</h3>
<pre class="language-scheme">
;; Capabilities can leak through:
;; 1. Logging - don't log capability tokens
;; 2. URLs - don't put capabilities in query strings
;; 3. Errors - don't include capabilities in error messages

(define (safe-log message capability)
  (log (string-append message " [capability:REDACTED]")))
</pre>
<h3>Confused Deputy</h3>
<pre class="language-scheme">
;; Always verify capability matches intended action
(define (execute-action action object capability)
  (unless (capability-grants? capability action object)
    (error "Capability does not grant this action"))
  (perform-action action object))
</pre>
<h3>Time-of-Check vs Time-of-Use</h3>
<pre class="language-scheme">
;; Validate immediately before use, not before
(define (safe-execute capability action)
  (let ((validated (validate-capability capability)))
    ;; No window between check and use
    (atomically
      (unless validated
        (error "Invalid capability"))
      (perform-action action))))
</pre>
<h3>Delegation Depth Limits</h3>
<pre class="language-scheme">
;; Prevent infinite delegation chains
(define max-delegation-depth 10)

(define (validate-chain-depth chain)
  (when (&gt; (length chain) max-delegation-depth)
    (error "Delegation chain too deep")))
</pre>
</section>
<section>
<h2>Implementation Notes</h2>
<h3>Certificate Storage</h3>
<pre class="language-scheme">
;; Certificates stored in CAS
(define (store-cert cert)
  (let ((signed (sign-cert cert)))
    (cas-put (serialize signed))))

;; Indexed by issuer and subject for fast lookup
(define cert-by-issuer (make-hash-table))
(define cert-by-subject (make-hash-table))
</pre>
<h3>Performance</h3>
<ul>
<li>Certificate validation is expensive - cache results</li>
<li>Chain discovery can be slow - index by issuer/subject</li>
<li>Revocation checks add latency - use short-lived certs when possible</li>
</ul>
</section>
<section>
<h2>References</h2>
<ul>
<li>SDSI/SPKI 2.0 - RFC 2693 (preserved)</li>
<li>A Logic of Authentication - Burrows, Abadi, Needham (preserved)</li>
<li>Capability Myths Demolished - Miller, Yee, Shapiro (preserved)</li>
<li>Memo-004: SPKI Authorization</li>
<li>Memo-020: Content-Addressed Storage</li>
<li>Memo-008: Threshold Signature Governance</li>
</ul>
</section>
<section>
<h2>Changelog</h2>
<ul>
<li>2026-01-07</li>
<li>Initial draft</li>
</ul>
</section>
<script>
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
}
(function() {
  // Query param override (for REPL: ?theme=dark or ?theme=light)
  const params = new URLSearchParams(window.location.search);
  const param = params.get('theme');
  if (param === 'dark' || param === 'light') {
    document.documentElement.setAttribute('data-theme', param);
    localStorage.setItem('theme', param);
    return;
  }
  // localStorage preference
  const saved = localStorage.getItem('theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
  } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script>
</body>
</html>
