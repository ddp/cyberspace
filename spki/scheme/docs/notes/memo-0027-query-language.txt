Memo 0027: Soup Query Language


------------------------------------------------------------------------

------------------------------------------------------------------------
ABSTRACT
------------------------------------------------------------------------

This Memo specifies the query language for the Library of Cyberspace
soup: how principals search, filter, and retrieve objects from the
content-addressed store using the rich metadata layer. Queries are
themselves content-addressed and auditable.


------------------------------------------------------------------------
MOTIVATION
------------------------------------------------------------------------

The soup contains infinite metadata. Finding needles requires a query
language that is:

  * Expressive
  * Complex predicates, joins across objects
  * Efficient
  * Indexes, bloom filters, query planning
  * Secure
  * Queries respect capability boundaries
  * Auditable
  * Query patterns reveal access patterns

Newton's soup had cursor-based queries. We extend this with
content-addressed semantics.


------------------------------------------------------------------------
QUERY MODEL
------------------------------------------------------------------------


Basic Queries
-------------


    ;; Find by type
    (soup-query type: 'document)
    ;; Find by attribute
    (soup-query author: "alice@example.com")
    ;; Find by multiple attributes (AND)
    (soup-query type: 'document
                author: "alice@example.com"
                created-after: "2026-01-01")
    ;; Find by content hash
    (soup-query hash: "sha256:7f83b1657ff1fc...")


Query Results
-------------


    ;; Results are lazy cursors
    (define results (soup-query type: 'document))
    ;; Iterate
    (soup-cursor-next results)    ; => soup-object or #f
    (soup-cursor-peek results)    ; => next without advancing
    (soup-cursor-reset results)   ; => back to beginning
    ;; Collect (careful with large result sets)
    (soup-cursor->list results)   ; => list of soup-objects
    (soup-cursor-count results)   ; => total count


Predicates
----------


    ;; Comparison operators
    (soup-query size: (> 1000000))           ; larger than 1MB
    (soup-query created: (< "2025-01-01"))   ; before 2025
    (soup-query name: (like "rfc-*"))        ; glob pattern
    (soup-query tags: (contains "urgent"))   ; list membership
    ;; Logical operators
    (soup-query (and (type: 'document)
                     (or (author: "alice")
                         (author: "bob"))))
    ;; Negation
    (soup-query (not (type: 'tombstone)))
    ;; Existence
    (soup-query (exists 'encryption-key))    ; has attribute
    (soup-query (missing 'expires))          ; lacks attribute


------------------------------------------------------------------------
ADVANCED QUERIES
------------------------------------------------------------------------


Range Queries
-------------


    ;; Numeric ranges
    (soup-query size: (between 1000 10000))
    ;; Date ranges
    (soup-query created: (between "2026-01-01" "2026-12-31"))
    ;; Lexicographic ranges
    (soup-query name: (between "memo-010" "memo-020"))


Full-Text Search
----------------


    ;; Search indexed content
    (soup-query (text-search "capability delegation"))
    ;; With highlighting
    (soup-query (text-search "SPKI certificate")
                highlight: #t)
    ;; Phrase search
    (soup-query (text-search "\"monotonic attenuation\""))
    ;; Fuzzy search
    (soup-query (text-search "delgation~"))  ; typo-tolerant


Reference Traversal
-------------------


    ;; Objects referencing this hash
    (soup-query references: "sha256:target...")
    ;; Objects referenced by this hash
    (soup-query referenced-by: "sha256:source...")
    ;; Transitive closure (careful - can be huge)
    (soup-query (transitive-references "sha256:root...")
                max-depth: 3)


Temporal Queries
----------------


    ;; Objects as they existed at a point in time
    (soup-query type: 'document
                as-of: "2026-01-01T00:00:00Z")
    ;; Objects modified in time window
    (soup-query modified: (between "2026-01-01" "2026-01-07"))
    ;; Version history
    (soup-query (versions-of "sha256:current..."))


------------------------------------------------------------------------
QUERY COMPOSITION
------------------------------------------------------------------------


Subqueries
----------


    ;; Objects authored by members of a group
    (soup-query author: (soup-query type: 'principal
                                    member-of: "engineering"))
    ;; Documents referencing any RFC
    (soup-query type: 'document
                references: (soup-query name: (like "rfc-*")))


Aggregation
-----------


    ;; Count by type
    (soup-aggregate
      group-by: 'type
      aggregate: (count))
    ;; Total size by author
    (soup-aggregate
      group-by: 'author
      aggregate: (sum 'size))
    ;; Average document size
    (soup-aggregate
      where: (type: 'document)
      aggregate: (avg 'size))
    ;; Distinct values
    (soup-aggregate
      aggregate: (distinct 'content-type))


Ordering and Pagination
-----------------------


    ;; Sort by creation date, newest first
    (soup-query type: 'document
                order-by: '((created desc)))
    ;; Multi-column sort
    (soup-query type: 'document
                order-by: '((author asc) (created desc)))
    ;; Pagination
    (soup-query type: 'document
                order-by: '((created desc))
                limit: 20
                offset: 40)
    ;; Cursor-based pagination (more efficient)
    (soup-query type: 'document
                order-by: '((created desc))
                after: "sha256:last-seen...")


------------------------------------------------------------------------
CAPABILITY-AWARE QUERIES
------------------------------------------------------------------------


Query Filtering
---------------

Queries automatically filter results based on the querying principal's
capabilities:


    (define (soup-query-with-caps query principal)
      "Execute query filtered by principal's capabilities"
      (let* ((raw-results (execute-query query))
             (caps (principal-capabilities principal)))
        (filter (lambda (obj)
                  (can-read? principal obj caps))
                raw-results)))


Capability Queries
------------------


    ;; What can I access?
    (soup-query (accessible-by (current-principal)))
    ;; Who can access this?
    (soup-query type: 'certificate
                grants-access-to: "sha256:target...")
    ;; Find my capabilities
    (soup-query type: 'certificate
                subject: (current-principal))


Query Authorization
-------------------


    ;; Some queries require explicit capability
    (soup-query type: 'audit-log)  ; requires audit-read capability
    ;; Query capability certificate
    (spki-cert
      (issuer vault-admin)
      (subject auditor-key)
      (capability
        (action query)
        (object (type 'audit-log)))
      (validity (not-after "2027-01-01")))


------------------------------------------------------------------------
INDEXES
------------------------------------------------------------------------


Index Types
-----------


    ;; B-tree index (ordered, range queries)
    (define-index 'created-idx
      type: 'btree
      on: 'created)
    ;; Hash index (equality only, faster)
    (define-index 'hash-idx
      type: 'hash
      on: 'content-hash)
    ;; Full-text index (search)
    (define-index 'content-idx
      type: 'fulltext
      on: 'content
      language: 'english)
    ;; Composite index
    (define-index 'author-date-idx
      type: 'btree
      on: '(author created))
    ;; Bloom filter index (membership testing)
    (define-index 'tags-bloom
      type: 'bloom
      on: 'tags
      false-positive-rate: 0.01)


Cost-Based Index Selection
--------------------------

Query planning uses Selinger-style cost estimation to select optimal
execution plans. The optimizer considers:

  * Cardinality estimation: How many rows will each predicate return?
  * Index selectivity: How discriminating is each index?
  * I/O cost: Sequential scan vs. random access
  * Join ordering: Which order minimizes intermediate result sizes?


    ;; Cardinality estimation using histograms
    (define (estimate-cardinality predicate index-stats)
      "Estimate result size for predicate"
      (let ((histogram (index-histogram index-stats)))
        (case (predicate-type predicate)
          ((equality)
           ;; Use histogram bucket counts
           (histogram-point-estimate histogram (predicate-value predicate)))
          ((range)
           ;; Sum histogram buckets in range
           (histogram-range-estimate histogram
                                      (predicate-low predicate)
                                      (predicate-high predicate)))
          ((like)
           ;; Estimate based on prefix selectivity
           ( (total-rows index-stats)
              (prefix-selectivity (predicate-pattern predicate))))
          (else
           ;; Conservative estimate: 10% of total
           ( 0.1 (total-rows index-stats))))))
    ;; Cost model for execution plans
    (define (plan-cost plan index-stats)
      "Estimate total cost in I/O operations"
      (let ((cardinality (estimate-cardinality (plan-predicate plan) index-stats)))
        (case (plan-access-method plan)
          ((full-scan)
           ;; Sequential I/O: count all pages
           (total-pages index-stats))
          ((index-scan)
           ;; Random I/O: estimated rows + index traversal
           (+ (log2 (total-rows index-stats))  ; B-tree depth
              cardinality))                     ; Heap fetches
          ((index-only)
           ;; No heap access needed
           (log2 (total-rows index-stats)))
          ((bloom-filter)
           ;; O(k) hash operations, negligible I/O
           ( 0.001 cardinality)))))
    ;; Dynamic programming for join ordering
    (define (optimize-join-order predicates indexes)
      "Find optimal join order using Selinger algorithm"
      (let ((memo (make-hash-table)))
        (define (best-plan preds)
          (cond
            ((null? preds) (empty-plan))
            ((hash-table-exists? memo preds)
             (hash-table-ref memo preds))
            (else
             (let ((candidates
                     (map (lambda (p)
                            (let ((rest (delete p preds)))
                              (join-plans (single-predicate-plan p)
                                          (best-plan rest))))
                          preds))
                    (best (minimum-by plan-cost candidates)))
               (hash-table-set! memo preds best)
               best))))
        (best-plan predicates)))
    ;; Select best index for query
    (define (plan-query query indexes)
      "Generate optimal query plan using cost-based optimization"
      (let ((predicates (query-predicates query))
             (stats (map index-statistics indexes))
             ;; Generate candidate plans
             (candidates
              (append
               ;; Try each applicable index
               (filter-map (lambda (idx stat)
                            (and (index-covers? idx predicates)
                                 (make-plan 'index-scan idx
                                            (plan-cost-for idx predicates stat))))
                          indexes stats)
               ;; Always consider full scan
               (list (make-plan 'full-scan #f (full-scan-cost predicates stats)))))
             ;; Select minimum cost plan
             (best (minimum-by plan-cost candidates)))
        (when (> (plan-cost best) query-cost-warning-threshold*)
          (log-warning "Expensive query plan" query (plan-cost best)))
        best))


Histogram Maintenance
---------------------


    ;; Equi-depth histograms for cardinality estimation
    (define (build-histogram values num-buckets)
      "Build equi-depth histogram for cardinality estimation"
      (let ((sorted (sort values <))
             (bucket-size (ceiling (/ (length sorted) num-buckets)))
             (boundaries (map (lambda (i)
                               (list-ref sorted ( i bucket-size)))
                             (iota num-buckets))))
        (make-histogram boundaries (/ (length sorted) num-buckets))))
    ;; Update histogram incrementally
    (define (histogram-update! hist value)
      "Incrementally update histogram with new value"
      (let ((bucket (find-bucket hist value)))
        (bucket-increment! bucket)))
    ;; Statistics refresh
    (define (refresh-index-statistics idx)
      "Rebuild index statistics (run periodically)"
      (let* ((samples (index-sample idx 10000))  ; Sample 10K rows
             (histogram (build-histogram samples 100)))
        (set-index-statistics! idx
          (make-stats
            (total-rows (index-count idx))
            (distinct-values (length (delete-duplicates samples)))
            (histogram histogram)
            (last-analyzed (current-time))))))


Index Maintenance
-----------------


    ;; Indexes are updated on soup-put
    (define (soup-put-indexed obj)
      (let ((hash (soup-put obj)))
        (for-each (lambda (idx)
                    (index-insert! idx obj hash))
                  (applicable-indexes obj))
        hash))
    ;; Periodic index optimization
    (define (optimize-indexes)
      (for-each index-compact! (all-indexes)))


------------------------------------------------------------------------
QUERY EXECUTION
------------------------------------------------------------------------


Query Planning
--------------


    (define (execute-query query)
      "Plan and execute query"
      (let ((plan (plan-query query))
             (cost (estimate-cost plan)))
        (when (> cost query-cost-limit*)
          (error "Query too expensive" cost))
        (execute-plan plan)))
    (define (plan-query query)
      "Generate query execution plan"
      `(query-plan
        (predicates ,(query-predicates query))
        (index ,(select-index query))
        (filter ,(remaining-predicates query))
        (order ,(query-order query))
        (limit ,(query-limit query))))


Execution Strategies
--------------------


    ;; Index scan
    (define (index-scan index predicate)
      (index-range-query index
                         (predicate-lower-bound predicate)
                         (predicate-upper-bound predicate)))
    ;; Full scan (last resort)
    (define (full-scan predicate)
      (filter predicate (all-soup-objects)))
    ;; Index intersection
    (define (index-intersect idx1 idx2 pred1 pred2)
      (set-intersection
        (index-scan idx1 pred1)
        (index-scan idx2 pred2)))


Query Caching
-------------

The soup is archival - objects rarely change, making aggressive caching
safe.


    ;; Multi-tier cache: L1 hot results, L2 warm, L3 persistent
    (define l1-cache (make-lru-cache 100))    ; In-memory, microseconds
    (define l2-cache (make-lru-cache 10000))  ; Warm, milliseconds
    (define l3-cache 'persistent-index)        ; On-disk, query index
    (define (cached-query query principal)
      "Multi-tier cached query with capability awareness"
      (let ((key (query-cache-key query principal)))
        (or (lru-get l1-cache key)
            (lru-get l2-cache key)
            (persistent-cache-get l3-cache key)
            (let ((result (execute-query query)))
              ;; Promote to appropriate cache tier based on cost
              (let ((cost (query-cost query)))
                (cond
                  ((> cost 1000) (persistent-cache-put! l3-cache key result))
                  ((> cost 100) (lru-put! l2-cache key result))
                  (else (lru-put! l1-cache key result))))
              result))))

#### Dependency-Based Invalidation

Track which predicates affect which cached queries using Bloom filters:


    ;; Bloom filter tracking which attributes affect cached queries
    (define query-dependencies (make-counting-bloom-filter 100000 0.001))
    (define (cache-with-deps query result)
      "Cache query and track its dependencies"
      (let ((key (query->hash query))
            (deps (query-attribute-deps query)))
        (lru-put! query-cache key result)
        ;; Track dependencies
        (for-each (lambda (attr)
                    (bloom-add! query-dependencies (cons attr key)))
                  deps)))
    (define (invalidate-on-change obj)
      "Invalidate only queries that MIGHT be affected (conservative)"
      (let ((attrs (soup-object-attributes obj)))
        (for-each (lambda (attr)
                    ;; Check if any cached query depends on this attribute
                    (when (bloom-might-contain? query-dependencies attr)
                      (invalidate-queries-for-attribute attr)))
                  attrs)))

#### Archival Cache Semantics

For the soup's archival nature, implement copy-on-write cache entries:


    ;; Immutable cache entries - archival objects never change
    (define (archival-cache-get cache hash)
      "Archival objects can be cached permanently"
      (let ((entry (hash-table-ref cache hash #f)))
        (if entry
            (if (archival-generation? (soup-get hash))
                entry  ; Archival: never expires
                (if (cache-entry-fresh? entry)
                    (cache-entry-value entry)
                    #f))  ; Non-archival: check freshness
            #f)))
    ;; Generation-aware caching
    (define (cache-ttl-for-generation gen)
      (case gen
        ((archival) +inf.0)       ; Never expires
        ((stable) 86400)          ; 1 day
        ((maturing) 3600)         ; 1 hour
        ((young) 60)              ; 1 minute
        ((ephemeral) 0)))         ; No caching


------------------------------------------------------------------------
DISTRIBUTED QUERIES
------------------------------------------------------------------------


Federated Query
---------------


    ;; Query across multiple vaults
    (soup-query type: 'document
                federation: '(vault-a vault-b vault-c))
    ;; Query with locality preference
    (soup-query type: 'document
                prefer-local: #t)


Query Routing
-------------


    (define (route-query query vaults)
      "Route query to appropriate vaults"
      (let ((partitions (query-partitions query)))
        (map (lambda (vault)
               (list vault (subquery-for-vault query vault)))
             (filter (lambda (v)
                       (vault-has-partition? v partitions))
                     vaults))))


Result Merging
--------------


    (define (merge-results results order)
      "Merge sorted results from multiple vaults"
      (let ((streams (map result->stream results)))
        (merge-sorted-streams streams (order->comparator order))))


------------------------------------------------------------------------
QUERY AUDIT
------------------------------------------------------------------------


Audit Trail
-----------


    ;; All queries are logged
    (define (audited-query query principal)
      (let ((start (current-time))
            (result (soup-query-with-caps query principal)))
        (audit-append
          action: 'query
          principal: principal
          query: (query->sexp query)
          result-count: (soup-cursor-count result)
          duration: (- (current-time) start))
        result))


Query Analysis
--------------


    ;; Analyze query patterns
    (soup-query type: 'audit-entry
                action: 'query
                principal: "alice")
    ;; Find expensive queries
    (soup-query type: 'audit-entry
                action: 'query
                duration: (> 1000))  ; > 1 second
    ;; Access pattern analysis
    (soup-aggregate
      where: (and (type: 'audit-entry) (action: 'query))
      group-by: 'principal
      aggregate: (count))


------------------------------------------------------------------------
QUERY LANGUAGE GRAMMAR
------------------------------------------------------------------------


    query       ::= (soup-query clause)
    clause      ::= attribute-clause | predicate-clause | option-clause
    attribute   ::= symbol ':' value
    predicate   ::= '(' op value ')'
    op          ::= '>' | '<' | '>=' | '<=' | '=' | '!='
                  | 'like' | 'between' | 'contains'
                  | 'and' | 'or' | 'not'
                  | 'exists' | 'missing'
                  | 'text-search' | 'references' | 'referenced-by'
    option      ::= 'order-by' | 'limit' | 'offset' | 'after'
                  | 'as-of' | 'highlight' | 'federation'
    value       ::= string | number | boolean | hash | query


------------------------------------------------------------------------
SECURITY CONSIDERATIONS
------------------------------------------------------------------------


Query Injection
---------------


    ;; Never interpolate user input into queries
    ;; BAD:
    (soup-query name: (string-append "rfc-" user-input))
    ;; GOOD:
    (soup-query name: (like (sanitize-pattern user-input)))
    (define (sanitize-pattern s)
      (string-map (lambda (c)
                    (if (member c '(#\* #\? #\[ #\]))
                        #\\
                        c))
                  s))


Query Cost Limits
-----------------


    ;; Prevent denial of service via expensive queries
    (define query-cost-limit 10000)
    (define query-timeout 30)  ; seconds
    (define (safe-query query)
      (with-timeout query-timeout
        (let ((cost (estimate-cost query)))
          (when (> cost query-cost-limit)
            (error "Query exceeds cost limit"))
          (execute-query query))))


Information Leakage
-------------------


    ;; Query existence can leak information
    ;; Even "not found" reveals something
    ;; Use constant-time responses for sensitive queries
    (define (private-query query)
      (let ((result (soup-query query)))
        (if (authorized? (current-principal) result)
            result
            (constant-time-not-found))))


------------------------------------------------------------------------
IMPLEMENTATION NOTES
------------------------------------------------------------------------


Performance
-----------

  * Index selection is critical for large soups
  * Bloom filters for fast negative lookups
  * Query result streaming to avoid memory exhaustion
  * Connection pooling for federated queries


Compatibility
-------------

  * Query language inspired by Newton's soup cursors
  * SQL-like semantics where applicable
  * S-expression syntax for Scheme integration


------------------------------------------------------------------------
REFERENCES
------------------------------------------------------------------------

1. Newton Programmer's Guide - Soup and cursor APIs 2. SQLite Query
Planner - Query optimization 3. Selinger et al., "Access Path Selection
in a Relational Database Management System" (1979) - Cost-based
optimization 4. Memo-020: Content-Addressed Storage 5. Memo-021:
Capability Delegation 6. Memo-026: Garbage Collection (generation-aware
caching)


------------------------------------------------------------------------
CHANGELOG
------------------------------------------------------------------------

  * 2026-01-09
  * Cost-based query optimization: Selinger algorithm, cardinality estimation, histograms, multi-tier caching with generation-aware TTL - 2026-01-07
  * Initial draft

------------------------------------------------------------------------
