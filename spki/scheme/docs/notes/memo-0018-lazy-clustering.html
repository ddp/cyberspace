<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <title>Memo 0018: Lazy Clustering</title>
  <link rel="icon" id="favicon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27%230f0%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>">
  <script>
(function(){
  var h=new Date().getHours(),c;
  if(h>=4&&h<6)c='%23845EC2';       // brahma muhurta - violet
  else if(h>=6&&h<8)c='%23ffd700';  // dawn - gold
  else if(h>=8&&h<11)c='%2300d4aa'; // morning - teal
  else if(h>=11&&h<14)c='%230f0';   // midday - phosphor
  else if(h>=14&&h<17)c='%2339ff14';// afternoon - neon
  else if(h>=17&&h<19)c='%23ff6600';// sunset - orange
  else if(h>=19&&h<22)c='%23ff3366';// evening - coral
  else c='%2300ffff';               // night - cyan
  document.getElementById('favicon').href='data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27'+c+'%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>';
})();
</script>
  <link rel="stylesheet" href="memo.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<p class="format-notice"><em>For pixel-perfect diagrams: <a href="memo-0018-lazy-clustering.ps">PostScript</a> or <a href="memo-0018-lazy-clustering.pdf">PDF</a></em></p>
<h1>Memo 0018: Lazy Clustering</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This Memo specifies Lazy Clustering for Cyberspace federation: a relaxed synchronization model where nodes sync when convenient, not continuously. Optimized for the "loose confederacy of friends" model.</p>
</section>
<section>
<h2>Motivation</h2>
<p>Not every deployment needs Byzantine consensus:</p>
<ul>
<li>Friends trust friends: No active adversary</li>
<li>Bandwidth costs: Continuous sync is expensive</li>
<li>Offline operation: Internet isn't always available</li>
<li>Simplicity: Complex protocols have complex bugs</li>
</ul>
<p>Protocol complexity should match trust assumptions; using Byzantine consensus among friends wastes resources and adds failure modes.</p>
<p>Lazy Clustering provides:</p>
<ul>
<li>Sync when ready: Push/pull at human pace</li>
<li>Offline-first: Work without network</li>
<li>Conflict detection: Know when divergence happens</li>
<li>Manual resolution: Humans resolve, not algorithms</li>
<li>Audit everything: Full history preserved</li>
</ul>
<p>These properties prioritize simplicity and autonomy over consistency, appropriate when participants have aligned interests and can tolerate temporary divergence.</p>
<blockquote>
<p>The best protocol is the one you don't run.</p>
</blockquote>
</section>
<section>
<h2>Specification</h2>
<h3>Cluster Model</h3>
<pre class="diagram">
     ┌─────────┐
     │  Alice  │
     │ (lazy)  │
     └────┬────┘
          │
          │ sync when ready @ 10Gb/s
          │
     ┌────▼────┐         ┌─────────┐
     │   Bob   │◄───────►│  Carol  │
     │ (lazy)  │ 10Gb/s  │ (lazy)  │
     └─────────┘         └─────────┘

No heartbeats. No leader election. No quorum.
Just friends sharing when they're ready.
At line speed when they do.
</pre>
<h3>Performance Model</h3>
<p>Lazy semantics, line speed execution.</p>
<pre>
Line speed (10 Gb/s):
  Typical release: 10 MB archive
  Transfer time:   8 ms
  Effective rate:  ~1000 releases/second

Starlink (100-200 Mb/s, 20-40ms latency):
  Typical release: 10 MB archive
  Transfer time:   400-800 ms
  Effective rate:  ~1-2 releases/second
  Optimized for:   Bursty, high-latency satellite links

Minimum bandwidth:
  Floor:           128 Kb/s (dual-ISDN)
  Target:          1 Mb/s (T1)
  Typical release: 10 MB archive
  Transfer time:   ~80 sec (T1), ~10 min (dual-ISDN)
  Strategy:        Delta sync, compressed archives
</pre>
<p>Crypto overhead (constant):</p>
<pre class="diagram">
Signature verify: ~10 μs (Ed25519)
Hash verify:      ~1 ms (SHA-512, 10MB)
Total overhead:   ~1 ms (negligible vs transfer)
</pre>
<p>"Lazy" means when, not how fast. When you sync, it saturates the pipe.</p>
<p>Design priorities:</p>
<ul>
<li>Optimized for Starlink and satellite links</li>
<li>Tolerant of high latency (no chatty protocols)</li>
<li>Graceful degradation to minimum bandwidth</li>
<li>Bursty transfer patterns (sync then idle)</li>
</ul>
<h3>Heartbeat and Timekeeping</h3>
<p>No mandatory heartbeat. That's the design.</p>
<pre class="diagram">
Traditional cluster:  ping → pong → ping → pong → ...
Lazy cluster:         ... silence ... (sync) ... silence ...
</pre>
<p>Timekeeping: Lamport clocks (Memo-012), not wall clocks. - Causality without synchronization - No NTP dependency - No GPS required - Works across time zones, planets</p>
<p>When you need consensus: Byzantine consensus (Memo-011) + Lamport clocks. - Lazy clustering for everyday sync - Byzantine consensus for critical decisions - Same Lamport clock across both modes</p>
<p>Optional presence beacon:</p>
<pre class="language-scheme">
(cluster-beacon
  (peer "alice")
  (lamport-time 4271)
  (last-release "2.1.0")
  (status available)
  (next-expected "when ready"))
</pre>
<p>Beacons are: - Pull-based (query, don't push) - Cached (no flood) - Stale-tolerant (hours/days old is fine) - Unsigned (advisory only)</p>
<h3>Sync Modes</h3>
<p>#### Push (I have something)</p>
<pre class="language-scheme">
(lazy-push peer)
;; Sends my new releases to peer
;; Non-blocking, fire-and-forget
</pre>
<p>#### Pull (What do you have?)</p>
<pre class="language-scheme">
(lazy-pull peer)
;; Fetches peer's new releases
;; Verifies signatures, stores locally
</pre>
<p>#### Sync (Bidirectional)</p>
<pre class="language-scheme">
(lazy-sync peer)
;; Push then pull
;; Returns conflict report if any
</pre>
<h3>Lazy Semantics</h3>
<p>No continuous connection. Nodes are offline by default.</p>
<p>No consistency guarantees. Nodes may diverge.</p>
<p>No automatic resolution. Conflicts flagged for humans.</p>
<p>No urgency. Sync happens when convenient.</p>
</section>
<section>
<h2>State Tracking</h2>
<h3>Version Vector</h3>
<p>Each node tracks what it knows about others:</p>
<pre class="diagram">
(define-record-type &lt;version-vector&gt;
  (make-version-vector entries)
  version-vector?
  (entries vv-entries))  ; Hash: node-id → latest-sequence

;; Alice's view:
;; { alice: 42, bob: 37, carol: 29 }
</pre>
<h3>Sync Calculation</h3>
<pre class="language-scheme">
(define (compute-sync-set local-vv remote-vv)
  "What to send/receive"
  (let ((to-send '())
        (to-receive '()))
    (for-each
      (lambda (node)
        (let ((local-seq (vv-get local-vv node))
              (remote-seq (vv-get remote-vv node)))
          (cond
            ((&gt; local-seq remote-seq)
             (push! to-send (releases-between node remote-seq local-seq)))
            ((&lt; local-seq remote-seq)
             (push! to-receive (list node remote-seq local-seq))))))
      (all-nodes local-vv remote-vv))
    (values to-send to-receive)))
</pre>
</section>
<section>
<h2>Conflict Detection</h2>
<h3>Divergence</h3>
<p>Same version, different content:</p>
<pre class="diagram">
(lazy-sync "bob")
;; =&gt;
;; ⚠ Conflict detected:
;;   Version 2.1.0
;;   Local:  sha512:abc123...
;;   Remote: sha512:def456...
;;
;;   Both modified since common ancestor 2.0.0
</pre>
<h3>Conflict Record</h3>
<pre class="language-scheme">
(conflict
  (version "2.1.0")
  (local-hash "sha512:abc123...")
  (remote-hash "sha512:def456...")
  (common-ancestor "2.0.0")
  (detected "2026-01-06T15:30:00Z")
  (status pending))  ; pending, resolved-local, resolved-remote, merged
</pre>
<h3>Resolution</h3>
<p>Manual resolution required:</p>
<pre class="language-scheme">
(lazy-resolve "2.1.0" prefer: 'local)
;; or
(lazy-resolve "2.1.0" prefer: 'remote)
;; or
(lazy-resolve "2.1.0" merged: "2.1.0-merged")
</pre>
</section>
<section>
<h2>Offline Operation</h2>
<h3>Work Offline</h3>
<pre class="language-scheme">
(seal-commit "Add feature")
(seal-release "2.2.0")
;; All local, no network required
</pre>
<h3>Queue for Sync</h3>
<pre class="language-scheme">
(lazy-queue)
;; =&gt;
;; Pending sync:
;;   2.1.1  (local, not pushed)
;;   2.2.0  (local, not pushed)
;;
;; To sync: (lazy-push "bob")
</pre>
<h3>Reconnect and Sync</h3>
<pre class="language-scheme">
(lazy-sync "bob")
;; Sends 2.1.1, 2.2.0
;; Receives bob's changes
;; Reports any conflicts
</pre>
</section>
<section>
<h2>Cluster Operations</h2>
<h3>Join Cluster</h3>
<pre class="language-scheme">
(lazy-join "bob"
  uri: "git@github.com:bob/vault.git"
  key: bob-public-key)
;; Registers peer, doesn't sync yet
</pre>
<h3>Initial Sync</h3>
<pre class="language-scheme">
(lazy-pull "bob")
;; Gets bob's full history
;; Verifies all signatures
</pre>
<h3>Leave Cluster</h3>
<pre class="language-scheme">
(lazy-leave "bob")
;; Removes peer from sync list
;; Keeps local copies of bob's releases
</pre>
<h3>Cluster Status</h3>
<pre class="diagram">
(lazy-status)
;; =&gt;
;; Cluster peers:
;;   bob    last-sync: 2026-01-05  versions: 1.0.0-2.1.0  ✓
;;   carol  last-sync: 2026-01-03  versions: 1.0.0-2.0.0  (2 behind)
;;   dave   last-sync: never       versions: none         (not synced)
;;
;; Local: 2.2.0 (2 ahead of cluster)
</pre>
</section>
<section>
<h2>Sync Strategies</h2>
<h3>Manual (Default)</h3>
<pre class="language-scheme">
(vault-config 'sync-strategy 'manual)
;; User explicitly calls lazy-sync
</pre>
<h3>Periodic</h3>
<pre class="language-scheme">
(vault-config 'sync-strategy 'periodic)
(vault-config 'sync-interval 3600)  ; hourly
;; Background sync when network available
</pre>
<h3>On-Commit</h3>
<pre class="language-scheme">
(vault-config 'sync-strategy 'on-commit)
;; Push after each seal-commit
;; Still lazy (non-blocking, best-effort)
</pre>
<h3>On-Release</h3>
<pre class="language-scheme">
(vault-config 'sync-strategy 'on-release)
;; Push only after seal-release
;; Most conservative
</pre>
</section>
<section>
<h2>Consistency Guarantees</h2>
<h3>What We Guarantee</h3>
<ul>
<li>Signature integrity: All releases verified</li>
<li>Causal ordering: Within single node</li>
<li>Conflict detection: Divergence detected</li>
<li>Audit preservation: Full history kept</li>
</ul>
<h3>What We Don't Guarantee</h3>
<ul>
<li>Global ordering: Nodes may see different orders</li>
<li>Consistency: Nodes may have different content</li>
<li>Availability: Offline nodes are offline</li>
<li>Automatic resolution: Humans must resolve</li>
</ul>
<h3>CAP Theorem Position</h3>
<pre class="diagram">
      Consistency
          /\
         /  \
        /    \
       / Lazy \
      / Cluster\
     /    ✓     \
    /\
Availability    Partition
    ✓           Tolerance ✓
</pre>
<p>We choose AP: Available and Partition-tolerant, eventually consistent.</p>
</section>
<section>
<h2>Comparison with Other Modes</h2>
<table>
<tr><th>Aspect </th><th>Lazy Cluster </th><th>Federation (Memo-010) </th><th>Byzantine (Memo-011) </th></tr>
<tr><td>Trust </td><td>Friends </td><td>Verified peers </td><td>Adversarial </td></tr>
<tr><td>Sync </td><td>Manual/periodic </td><td>Announcement-based </td><td>Consensus </td></tr>
<tr><td>Conflicts </td><td>Manual resolve </td><td>Detect + flag </td><td>Prevented </td></tr>
<tr><td>Offline </td><td>Full support </td><td>Partial </td><td>Requires quorum </td></tr>
<tr><td>Complexity </td><td>Minimal </td><td>Medium </td><td>High </td></tr>
<tr><td>Use case </td><td>Small groups </td><td>Organizations </td><td>Critical systems </td></tr>
</table>
</section>
<section>
<h2>Example Session</h2>
<pre class="diagram">
;; Morning: Alice works offline
(seal-commit "Add authentication")
(seal-commit "Add authorization")
(seal-release "2.3.0")

;; Lunch: Alice syncs with Bob
(lazy-sync "bob")
;; =&gt; Pushed 2.3.0 to bob
;; =&gt; Pulled 2.2.1 from bob
;; =&gt; No conflicts

;; Evening: Alice syncs with Carol
(lazy-sync "carol")
;; =&gt; Pushed 2.2.1, 2.3.0 to carol
;; =&gt; Pulled nothing (carol hasn't released)
;; =&gt; ⚠ Carol has unsynced commits (not our concern)
</pre>
</section>
<section>
<h2>Security Considerations</h2>
<h3>Trust Model</h3>
<p>Lazy clustering assumes good-faith peers:</p>
<ul>
<li>Peers won't inject malicious releases</li>
<li>Peers won't withhold releases maliciously</li>
<li>Peers will eventually sync</li>
</ul>
<p>Not suitable for: Adversarial environments, high-value targets.</p>
<p>Suitable for: Research groups, open source projects, friend networks.</p>
<h3>Signature Verification</h3>
<p>All releases still verified:</p>
<pre class="language-scheme">
(lazy-pull "bob")
;; Each release:
;;   1. Verify Ed25519 signature
;;   2. Verify hash matches content
;;   3. Check against known bob public key
;;   4. Store only if valid
</pre>
<h3>Conflict Attacks</h3>
<p>Malicious peer creates conflicting release.</p>
<p>Mitigation: - Conflicts flagged, not auto-resolved - Full audit trail of conflict - Peer reputation tracking</p>
</section>
<section>
<h2>Implementation Notes</h2>
<h3>Dependencies</h3>
<ul>
<li>crypto-ffi</li>
<li>Signature verification - audit</li>
<li>Sync logging</li>
<li>Transport (git/HTTP/filesystem)</li>
</ul>
<h3>Storage</h3>
<pre>
.vault/
  lazy/
    peers.sexp        # Registered peers
    vectors.sexp      # Version vectors
    conflicts/        # Unresolved conflicts
    queue/            # Pending pushes
</pre>
</section>
<section>
<h2>References</h2>
<ul>
<li>Saito, Y., &amp; Shapiro, M. (2005). Optimistic Replication.</li>
<li>Terry, D., et al. (1995). Managing Update Conflicts in Bayou.</li>
<li>DeCandia, G., et al. (2007). Dynamo: Amazon's Key-Value Store.</li>
<li>Memo-010: Federation Protocol</li>
<li>Memo-012: Lamport Logical Clocks</li>
</ul>
</section>
<section>
<h2>Changelog</h2>
<ul>
<li>2026-01-06</li>
<li>Set minimum bandwidth: 128 Kb/s floor (dual-ISDN), 1 Mb/s target (T1) - 2026-01-06</li>
<li>Initial specification</li>
</ul>
</section>
<script>
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
}
(function() {
  // Query param override (for REPL: ?theme=dark or ?theme=light)
  const params = new URLSearchParams(window.location.search);
  const param = params.get('theme');
  if (param === 'dark' || param === 'light') {
    document.documentElement.setAttribute('data-theme', param);
    localStorage.setItem('theme', param);
    return;
  }
  // localStorage preference
  const saved = localStorage.getItem('theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
  } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script>
</body>
</html>
