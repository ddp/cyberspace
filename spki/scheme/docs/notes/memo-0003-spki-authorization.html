<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <title>Memo 0003: Public Key Authorization</title>
  <link rel="icon" id="favicon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27%230f0%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>">
  <script>
(function(){
  var h=new Date().getHours(),c;
  if(h>=4&&h<6)c='%23845EC2';       // brahma muhurta - violet
  else if(h>=6&&h<8)c='%23ffd700';  // dawn - gold
  else if(h>=8&&h<11)c='%2300d4aa'; // morning - teal
  else if(h>=11&&h<14)c='%230f0';   // midday - phosphor
  else if(h>=14&&h<17)c='%2339ff14';// afternoon - neon
  else if(h>=17&&h<19)c='%23ff6600';// sunset - orange
  else if(h>=19&&h<22)c='%23ff3366';// evening - coral
  else c='%2300ffff';               // night - cyan
  document.getElementById('favicon').href='data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27'+c+'%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>';
})();
</script>
  <link rel="stylesheet" href="memo.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<h1>Memo 0003: Public Key Authorization</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This Memo specifies the Simple Distributed Security Infrastructure/Simple Public Key Infrastructure (SDSI/SPKI) certificate system for Cyberspace, providing authorization without identity. Principals are identified by cryptographic keys, not names. Authorization flows through verifiable delegation chains.</p>
</section>
<section>
<h2>E Pluribus</h2>
<blockquote>
<p>The question is not 'Who is this?' but 'What can this key do?' — Carl Ellison, SPKI co-author</p>
</blockquote>
</section>
<section>
<h2>Motivation</h2>
<h3>Heritage: SDSI at IETF 29</h3>
<p>Ron Rivest presented SDSI at Internet Engineering Task Force (IETF) 29 in Seattle (March 28 - April 1, 1994). The idea was elegant: self-certifying keys and local names. No global namespace. No certificate authorities. Just cryptographic principals naming what they choose to name.</p>
<p>SDSI later merged with SPKI to form SDSI/SPKI, standardized in RFC 2692 and RFC 2693 (1999).</p>
<p>Some in the PKI industry understood SPKI was technically superior. But they saw a monopoly to be mined—certificate authorities as toll booths on the internet. SPKI threatened that model. It was too decentralized to profit from.</p>
<p>HP quietly adopted SPKI for their E-speak middleware and printer authorization. Printers. The technology worked. The politics didn't favor it.</p>
<p>Cyberspace picks up where SPKI left off.</p>
<h3>The X.509 Problem</h3>
<p>X.509 certificates bind names to keys. This requires:</p>
<ul>
<li>Certificate authorities (trust hierarchies)</li>
<li>Global name registries (DNS)</li>
<li>Identity verification (bureaucracy)</li>
</ul>
<p>SPKI inverts this model:</p>
<blockquote>
<p>Keys are principals. Authorization is local. Delegation is explicit.</p>
</blockquote>
<p>Benefits:</p>
<ul>
<li>No CA required: Trust flows from keys you choose</li>
<li>No global names: Local namespaces, local meanings</li>
<li>No identity: Grant permissions to keys, not people</li>
<li>Auditable: S-expression format is human-readable</li>
</ul>
</section>
<section>
<h2>Specification</h2>
<h3>Principals</h3>
<p>A principal is an authorization endpoint—the entity that can do things. In SPKI, principals are keys, not names. Two types:</p>
<h3>Key Principal</h3>
<p>Direct identification by public key. The simplest case: you are your key.</p>
<pre class="language-scheme">
(define-record-type &lt;key-principal&gt;
  (make-key-principal public-key)
  key-principal?
  (public-key principal-public-key))
</pre>
<p>S-expression representation: bare bytes</p>
<pre class="language-scheme">
#${32-byte-ed25519-public-key}
</pre>
<h3>Key Hash Principal</h3>
<p>Identification by hash of public key. Useful when the full key isn't known yet or when size matters.</p>
<pre class="language-scheme">
(define-record-type &lt;keyhash-principal&gt;
  (make-keyhash-principal hash-alg hash)
  keyhash-principal?
  (hash-alg principal-hash-alg)
  (hash principal-hash))
</pre>
<p>S-expression representation:</p>
<pre class="language-scheme">
(hash sha512 #${64-byte-hash})
</pre>
<h3>Authorization Tags</h3>
<p>Tags define what permissions are granted:</p>
<pre class="language-scheme">
(define-record-type &lt;tag&gt;
  (make-tag sexp)
  tag?
  (sexp tag-sexp))
</pre>
<p>Example tags:</p>
<pre class="language-scheme">
;; Read access to library
(read (path /library/lamport-papers))

;; Agent spawning limit
(spawn-agent (max-count 5))

;; HTTP API access
(http-api (method POST) (path /deploy/))

;; All permissions (wildcard)
()
</pre>
<h3>Validity Period</h3>
<p>Optional time constraints:</p>
<pre class="language-scheme">
(define-record-type &lt;validity&gt;
  (make-validity not-before not-after)
  validity?
  (not-before validity-not-before)   ; ISO 8601 string
  (not-after validity-not-after))    ; ISO 8601 string
</pre>
<h3>Certificate Structure</h3>
<pre class="language-scheme">
(define-record-type &lt;cert&gt;
  (make-cert issuer subject tag validity propagate)
  cert?
  (issuer cert-issuer)         ; Principal granting permission
  (subject cert-subject)       ; Principal receiving permission
  (tag cert-tag)               ; What is being granted
  (validity cert-validity)     ; When valid (optional)
  (propagate cert-propagate))  ; Can subject re-delegate?
</pre>
<p>S-expression format:</p>
<pre class="language-scheme">
(cert
  (issuer #${alice-public-key})
  (subject #${bob-public-key})
  (tag (read (path /library/*)))
  (valid
    (not-before "2026-01-01")
    (not-after "2026-12-31"))
  (propagate))
</pre>
<h3>Signed Certificate</h3>
<pre class="language-scheme">
(define-record-type &lt;signed-cert&gt;
  (make-signed-cert cert signature)
  signed-cert?
  (cert signed-cert-cert)
  (signature signed-cert-signature))

(define-record-type &lt;signature&gt;
  (make-signature hash-alg cert-hash sig-bytes)
  signature?
  (hash-alg signature-hash-alg)
  (cert-hash signature-cert-hash)
  (sig-bytes signature-sig-bytes))
</pre>
</section>
<section>
<h2>Operations</h2>
<h3>Creating Certificates</h3>
<pre class="language-scheme">
(define cert
  (create-cert
    (make-key-principal alice-public)
    (make-key-principal bob-public)
    (make-tag '(read (path /library/*)))
    validity: (make-validity "2026-01-01" "2026-12-31")
    propagate: #t))
</pre>
<h3>Signing Certificates</h3>
<pre class="language-scheme">
(define signed-cert
  (sign-cert cert alice-private))
</pre>
<p>Process:</p>
<ul>
<li>Convert certificate to canonical S-expression</li>
<li>Hash with SHA-512</li>
<li>Sign hash with Ed25519</li>
<li>Create signature record</li>
<li>Combine into signed certificate</li>
</ul>
<h3>Verifying Certificates</h3>
<pre class="language-scheme">
(verify-signed-cert signed-cert alice-public)
</pre>
<p>Verification:</p>
<ul>
<li>Recompute canonical S-expression</li>
<li>Hash with SHA-512</li>
<li>Compare with stored hash</li>
<li>Verify Ed25519 signature</li>
</ul>
<h3>Verifying Delegation Chains</h3>
<pre class="language-scheme">
(verify-chain root-key cert-list target-tag)
</pre>
<p>Chain verification ensures:</p>
<ul>
<li>Each certificate is validly signed</li>
<li>Issuer of cert[n+1] matches subject of cert[n]</li>
<li>Tags are properly delegated (each implies the next)</li>
<li>Propagation is allowed (except final cert)</li>
<li>Final tag implies target tag</li>
</ul>
</section>
<section>
<h2>CLI Tools</h2>
<h3>spki-keygen</h3>
<p>Generate Ed25519 keypair:</p>
<pre class="language-bash">
$ ./spki-keygen alice
Generated keypair:
  Public:  alice.public
  Private: alice.private
</pre>
<h3>spki-cert</h3>
<p>Create and sign certificate:</p>
<pre class="language-bash">
$ ./spki-cert \
    --issuer alice.private \
    --subject bob.public \
    --tag '(read (path /library/*))' \
    --propagate \
    --not-after "2026-12-31" \
    --output alice-to-bob.cert
</pre>
<h3>spki-verify</h3>
<p>Verify certificate signature:</p>
<div class="diagram-container">
<svg class="diagram" viewBox="0 0 460 40" width="460" height="40" xmlns="http://www.w3.org/2000/svg">
<style>
  .diagram line { stroke: currentColor; stroke-width: 1.5; stroke-linecap: square; }
  .diagram rect { fill: currentColor; }
  .diagram text { font-family: 'JetBrains Mono', monospace; font-size: 14px; fill: currentColor; dominant-baseline: central; }
</style>
<text x="0" y="10">$</text>
<text x="20" y="10">./spki-verify</text>
<text x="160" y="10">alice.public</text>
<text x="290" y="10">alice-to-bob.cert</text>
<text x="0" y="30">✓</text>
<text x="20" y="30">Certificate</text>
<text x="140" y="30">signature</text>
<text x="240" y="30">valid</text>
</svg>
</div>
<h3>spki-show</h3>
<p>Display certificate in human-readable form:</p>
<pre class="language-bash">
$ ./spki-show alice-to-bob.cert
Certificate:
  Issuer:  ed25519:cbc9b260da65f6a7...
  Subject: ed25519:a5f8c9e3d2b1f0e4...
  Tag:     (read (path /library/*))
  Valid:   until 2026-12-31
  Propagate: yes
</pre>
</section>
<section>
<h2>Tag Semantics</h2>
<h3>Tag Implication</h3>
<p>Tag A implies Tag B if A grants at least all permissions of B.</p>
<pre class="language-scheme">
(define (tag-implies tag1 tag2)
  (cond
    ((all-perms? tag1) #t)    ; () implies everything
    ((all-perms? tag2) #f)    ; Only () implies (*)
    (else (equal? tag1 tag2)))) ; Simple equality (extensible)
</pre>
<h3>Standard Tag Vocabulary</h3>
<table>
<tr><th>Tag </th><th>Meaning </th></tr>
<tr><td>(*) </td><td>All permissions </td></tr>
<tr><td>(read (path P)) </td><td>Read access to path P </td></tr>
<tr><td>(write (path P)) </td><td>Write access to path P </td></tr>
<tr><td>(spawn-agent (max-count N)) </td><td>Spawn up to N agents </td></tr>
<tr><td>(http-api (method M) (path P)) </td><td>HTTP API access </td></tr>
<tr><td>(seal-release) </td><td>Permission to create releases </td></tr>
<tr><td>(seal-publish (remote R)) </td><td>Permission to publish to R </td></tr>
</table>
</section>
<section>
<h2>Delegation Chains</h2>
<h3>Example: Three-Level Delegation</h3>
<div class="diagram-container">
<svg class="diagram" viewBox="0 0 450 20" width="450" height="20" xmlns="http://www.w3.org/2000/svg">
<style>
  .diagram line { stroke: currentColor; stroke-width: 1.5; stroke-linecap: square; }
  .diagram rect { fill: currentColor; }
  .diagram text { font-family: 'JetBrains Mono', monospace; font-size: 14px; fill: currentColor; dominant-baseline: central; }
</style>
<text x="0" y="10">Alice</text>
<text x="60" y="10">(root)</text>
<text x="150" y="10">Bob</text>
<text x="190" y="10">(admin)</text>
<text x="290" y="10">Carol</text>
<text x="350" y="10">(operator)</text>
</svg>
</div>
<p>Certificates:</p>
<pre class="language-scheme">
;; Alice grants admin to Bob
(cert
  (issuer #${alice-key})
  (subject #${bob-key})
  (tag (*))
  (propagate))

;; Bob grants operator to Carol
(cert
  (issuer #${bob-key})
  (subject #${carol-key})
  (tag (seal-publish (remote origin))))
</pre>
<p>Verification:</p>
<pre class="language-scheme">
(verify-chain alice-public
              (list alice-to-bob bob-to-carol)
              (make-tag '(seal-publish (remote origin))))
;; =&gt; #t if Carol can publish
</pre>
</section>
<section>
<h2>Security Considerations</h2>
<h3>Threat Model</h3>
<p>Trusted:</p>
<ul>
<li>Local key storage</li>
<li>Ed25519/SHA-512 (libsodium)</li>
<li>Certificate chain construction</li>
</ul>
<p>Untrusted:</p>
<ul>
<li>Certificate sources (anyone can create certs)</li>
<li>Network transport (assume hostile)</li>
<li>Certificate claims (until chain verified)</li>
</ul>
<h3>Attack Mitigations</h3>
<table>
<tr><th>Attack </th><th>Mitigation </th></tr>
<tr><td>Certificate forgery </td><td>Ed25519 signatures </td></tr>
<tr><td>Unauthorized delegation </td><td>Propagate flag </td></tr>
<tr><td>Expired permissions </td><td>Validity period checks </td></tr>
<tr><td>Over-delegation </td><td>Tag implication checking </td></tr>
</table>
<h3>Key Management</h3>
<ul>
<li>Generation: Use secure random (libsodium)</li>
<li>Storage: Private keys in protected files</li>
<li>Backup: Shamir secret sharing (see Memo-004)</li>
<li>Rotation: Issue new certs, revoke old</li>
</ul>
<p>Key management is the operational foundation of SPKI security; cryptographic strength means nothing if keys are generated predictably, stored carelessly, or lost irretrievably.</p>
</section>
<section>
<h2>Integration Points</h2>
<h3>Vault Authorization</h3>
<pre class="language-scheme">
(vault-init signing-key: alice-private)
(seal-release "1.0.0")  ; Requires seal-release tag
</pre>
<h3>Audit Trail Attribution</h3>
<pre class="language-scheme">
(audit-append
  actor: bob-public
  action: '(seal-commit "abc123")
  authorization-chain: (list alice-to-bob-cert))
</pre>
<h3>Replication Access Control</h3>
<pre class="language-scheme">
(seal-publish "1.0.0"
  remote: "origin"
  authorization: bob-to-carol-cert)
</pre>
</section>
<section>
<h2>SPKI vs X.509</h2>
<table>
<tr><th>Aspect </th><th>X.509 </th><th>SPKI </th></tr>
<tr><td>Identity </td><td>Names (DN) </td><td>Keys </td></tr>
<tr><td>Trust </td><td>CA hierarchy </td><td>Local choice </td></tr>
<tr><td>Namespaces </td><td>Global (DNS) </td><td>Local </td></tr>
<tr><td>Revocation </td><td>CRL/OCSP </td><td>Validity periods </td></tr>
<tr><td>Format </td><td>ASN.1/DER </td><td>S-expressions </td></tr>
<tr><td>Readability </td><td>Requires tools </td><td>Human-readable </td></tr>
<tr><td>Delegation </td><td>Implicit (CA) </td><td>Explicit (propagate) </td></tr>
</table>
</section>
<section>
<h2>References</h2>
<ul>
<li>Ellison, C., et al. (1999). SPKI Certificate Theory. RFC 2693.</li>
<li>Ellison, C., et al. (1999). SPKI Requirements. RFC 2692.</li>
<li>Rivest, R., &amp; Lampson, B. (1996). SDSI - A Simple Distributed Security Infrastructure.</li>
<li>Lampson, B. (1971). Protection.</li>
</ul>
</section>
<section>
<h2>Changelog</h2>
<p>2026-01-19 - Added Ellison quote, expanded narrative, fixed formatting</p>
<p>2026-01-06 - Initial specification</p>
</section>
<script>
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
}
(function() {
  // Query param override (for REPL: ?theme=dark or ?theme=light)
  const params = new URLSearchParams(window.location.search);
  const param = params.get('theme');
  if (param === 'dark' || param === 'light') {
    document.documentElement.setAttribute('data-theme', param);
    localStorage.setItem('theme', param);
    return;
  }
  // localStorage preference
  const saved = localStorage.getItem('theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
  } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script>
</body>
</html>
