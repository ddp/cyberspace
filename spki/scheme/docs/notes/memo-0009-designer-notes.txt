Memo 0009: Designer Notes

Date: January 2026 (2026-01-22T04:31:00Z)
Author: Derrell Piper <ddp@eludom.net>

------------------------------------------------------------------------

------------------------------------------------------------------------
NOTICE
------------------------------------------------------------------------

This is a living document, not a specification. It records the
intellectual heritage, design philosophy, and collaborative process
behind Cyberspace.


------------------------------------------------------------------------
1. INTELLECTUAL HERITAGE
------------------------------------------------------------------------


1.1 MIT Athena and SPKI
-----------------------

Cyberspace traces its lineage to MIT's Project Athena and the Simple
Public Key Infrastructure (SPKI) work that emerged from MIT and the
Internet Engineering Task Force (IETF).

Athena (1983-1991) introduced Kerberos, distributed authentication, and
the concept of a unified computing environment across heterogeneous
systems. Digital Equipment Corporation (DEC) funded Athena and
contributed workstations.

Two independent threads merged at IETF to form SDSI/SPKI:

  * Simple Distributed Security Infrastructure (SDSI) - Ron Rivest at MIT, focusing on naming and local name spaces
  * SPKI - Carl Ellison at IETF, focusing on authorization and capabilities

Ellison's SPKI RFCs (2693, 2692) formalized capability-based
authorization through certificate chains. When IETF standardized this
work, Rivest's SDSI naming merged in. The result (SDSI/SPKI 2.0) gave us
both authorization and naming.

These ideas were absorbed during the same lamport epoch as R4RS Scheme
(1991) and SDSI (1996), alongside the practical education of Boston
traffic negotiation - both exercises in asserting authority without
central coordination.


1.2 Why Scheme
--------------

Scheme was chosen because its homoiconic S-expressions make the
representation of programs and structured data the same kind of thing.
One parser, one set of tools works uniformly over code, certificates,
audit trails, and configuration.

In a homoiconic language, the primary representation of programs is also
a data structure in a primitive type of the language. Scheme uses
S-expressions—nested lists and atoms—as both surface syntax and
natural tree-shaped data. The abstract syntax tree and textual form
closely align.

The same reader parses program text, configuration records, and
application data into a single uniform format. Certificates, audit
records, memos, and code are all S-expressions manipulated with the same
combinators:


    ;; All the same representation
    (read)           ; parse code
    (read-cert)      ; parse certificate
    (read-audit)     ; parse audit trail
    (kwic 'soup)     ; search memos

One minimal, well-specified parser eliminates impedance mismatches
between code format and data format. No JSON-to-object mapping. No
protobuf schema compiler. Structures representing policies look exactly
like structures representing the code enforcing them.

When you (kwic 'soup) you search S-expressions with S-expressions. The
memos are data. The code is data. The boundary dissolves.

The language that Abelson and Sussman used to teach computational
thinking at MIT is the same language used to implement the security
architecture that MIT research defined. Full circle.

Cyberspace Scheme is intentionally R5RS and R7RS-small, following
CHICKEN Scheme's philosophy: a small, portable core with extensions as
libraries rather than language features. R5RS (1998) remains the most
widely implemented Scheme standard. R7RS-small (2013) preserves that
minimalist tradition while adding practical improvements like
define-library. The large dialect (R7RS-large, ongoing) is explicitly
avoided - complexity belongs in libraries, not the language
specification.

CHICKEN was chosen over faster implementations (Chez, Racket, Gambit)
for its elegance and deployment model. CHICKEN compiles to C, producing
standalone executables with no runtime dependencies. The egg system
provides a curated library ecosystem. Speed matters less than simplicity
when the bottleneck is cryptographic operations in libsodium, not
interpreter overhead.


------------------------------------------------------------------------
2. COLLABORATIVE DESIGN
------------------------------------------------------------------------

Cyberspace was designed in collaboration with Claude (Anthropic), an AI
assistant. This collaboration is documented in Memo-056.

The interaction model: human provides vision and constraints, AI
provides implementation and exploration. Neither could have built this
alone.


------------------------------------------------------------------------
3. NAMING COHERENCE
------------------------------------------------------------------------

Knuth's principle from TAOCP: names should be consistent across the
totality of a system. When we renamed 'RFC' to 'Memo' internally, we
applied s/rfc/memo/g globally - not just to files being edited, but to
every reference in the codebase.

Single source of truth extends to terminology. MEMO_NUMBER_WIDTH is
defined once; the four-digit format flows from that constant through
Scheme and shell. When the namespace overflows to five digits, one
change propagates everywhere.

Piecemeal renaming creates inconsistent states where variables say one
thing and filenames say another. The systematic approach is the only
approach.


------------------------------------------------------------------------
4. TARGET ENVIRONMENTS
------------------------------------------------------------------------

Primary targets:

  * macOS (Apple Silicon) - Cyberspace.app native shell
  * Linux - including MIT Athena
  * Any POSIX system with CHICKEN Scheme 5.x

The system should feel native on a Mac, work cleanly on Athena, and
build anywhere Scheme runs.


------------------------------------------------------------------------
5. THE SCHEME BENEATH
------------------------------------------------------------------------

Scheme is the implementation language, not the user interface. The
novice sees a shell; the schemer sees a REPL. Same system, different
lenses.

By default, Scheme internals are hidden:

  * Inspector disabled - errors show simple messages, not debug> prompts
  * Exception display uses plain language, not 'unbound variable'
  * Help shows commands, not S-expressions
  * The % prompt is a portal, not a lambda

Schemers opt in with (enable-inspector!) and see the machinery. The
abstraction layer is permeable but not transparent.

This is not dumbing down. It is layered revelation - the same principle
that makes Cyberspace.app feel native on Mac while running pure Scheme
underneath.


------------------------------------------------------------------------
6. THE SCRUTINIZER
------------------------------------------------------------------------

Consistency requires tooling. The scrutinizer audits tone and
terminology across library and code.

Two failure modes:

  * Overreach - poetry where precision needed, whimsy in error messages
  * Underreach - dry jargon where warmth appropriate, internal vocabulary leaking through

Passes:

  * Vocabulary audit - banned terms in user-facing strings
  * Tone consistency - memos vs help vs errors
  * S-expression exposure - Scheme leaking to surface

Interface:


    (scrutinize)               ; both passes (default)
    (scrutinize 'library)      ; memos only
    (scrutinize 'code)         ; code only
    (scrutinize #f)            ; disable
    *scrutinize-realmtime*     ; parameter, default #f
    (scrutinize-realmtime! #t) ; enable during dev

Realmtime mode invokes spacetime - scrutiny flows through the realm as
time passes. When enabled, violations surface as modules load. Off in
production, on in beta.


------------------------------------------------------------------------
7. FORGE AND SMELTER
------------------------------------------------------------------------

The forge module generates pronounceable passwords using Markov chains
on digraph statistics. The lineage traces back to Multics.


7.1 Heritage
------------

Original design by Morrie Gasser in PL/1 on Multics. Gasser, author of
'Building a Secure Computer System' (1988), carried the code forward to
VAX/VMS where it remained in PL/1 until the Alpha transition.

When DEC moved to Alpha architecture, PL/1 wasn't in the initial
compiler release. The code had to be expunged from the TCB. Derrell
Piper and Jon Callas rewrote it for VMS 6.0 (circa 1991): Piper wrote
the BLISS system service for the Trusted Computing Base; Callas wrote
the user-mode TPU smelter.

US and EU DEC patents were filed on the design (now expired). The
terminology - forge, smelter - comes from metallurgy: the smelter
refines raw ore (word lists) into workable material (digraph
statistics); the forge shapes the final product (pronounceable words).

Callas later became a principal author of OpenPGP (RFC 4880) and
co-founded PGP Corporation and Silent Circle. He remains a planned beta
tester for Cyberspace.

The chain of custody: Gasser (Multics PL/1) → Piper/Callas (VMS 6.0
BLISS/TPU) → Cyberspace (Scheme).


7.2 Design
----------

The smelter reads word lists and extracts digraph (character pair)
statistics:

  * Starting pair frequency - which pairs begin words
  * Transition probability - given 'ab', what characters follow
  * Termination markers - which pairs end words

The forge walks these statistics with weighted random selection,
producing words that follow the phonetic patterns of the source
language. Entropy is tracked in 'decibits' (tenths of bits) to quantify
password strength.


7.3 Languages
-------------

Original VMS languages: English, Latin, Italian, Dutch, Sindarin,
Webster. The VT100 diacriticals were encoded in DEC MCS (Multinational
Character Set).

Cyberspace expansion to 40+ languages follows roughly the operational
map of the Office of Strategic Services - another egg for those who
recognize the geography:

  * Western Europe: French, German, Spanish, Portuguese
  * Iberia: Catalan, Galician, Basque
  * Nordic (resistance networks): Swedish, Norwegian, Danish, Finnish
  * Atlantic fringe: Irish, Welsh, Scottish Gaelic, Breton
  * Balkans (partisan country): Greek, Albanian, Serbian, Croatian, Slovenian, Macedonian
  * Eastern front: Polish, Czech, Slovak, Hungarian, Romanian
  * Baltic: Lithuanian, Latvian, Estonian
  * Soviet theater: Russian, Ukrainian, Bulgarian
  * Near East: Turkish, Armenian
  * Mediterranean (George Cross island): Maltese
  * Detachment 101: Vietnamese, Thai, Lao, Korean
  * Literary: Sindarin (Tolkien's Elvish), Dante's Divina Commedia

Word lists sourced from Hunspell, LibreOffice, SCOWL, OpenTaal, Eldamo,
and the Princeton Dante Project. All diacriticals converted to UTF-8.

Sindarin preserves Tolkien's circumflexes: Manwë, Aulë, Andúril.
Dante's medieval Italian sits alongside. The OSS framing is itself an
easter egg - layers of meaning for those who dig.


7.4 Related Standards
---------------------

Forge predates but relates to two password generation standards:

  * FIPS 181 (1993) - Automated Password Generator. Uses trigraph (3-letter) statistics and hyphenation rules. More structured but less natural. Forge's digraph approach (1991) produces smoother results by learning from actual language patterns rather than syllable rules.
  * OPIE/S/Key - One-time Passwords In Everything. Uses a fixed 2048-word dictionary optimized for spoken communication over phone lines. Words are short and phonetically distinct. Different goal: memorability for one-time use vs. pronounceability for permanent passwords.

Forge's contribution was combining Markov chain language modeling with
entropy tracking - knowing not just that a password sounds right, but
exactly how many bits of randomness it contains.


7.5 Interface
-------------


    (forge)              ; one English word
    (forge 5)            ; five English words
    (forge 'sindarin)    ; one Elvish word
    (forge 'latin 3)     ; three Latin words
    (forge 'passphrase)  ; 4-word passphrase
    (forge 'german 'passphrase 6) ; 6-word German passphrase

Each word reports its entropy. Passphrases join words with hyphens. The
forge is an easter egg - undocumented in help, discovered by schemers
exploring the REPL.


7.6 Cryptographic Entropy
-------------------------

Passwords fall naturally out of pronounceable words when the entropy
source is sound. Forge uses /dev/urandom for cryptographically secure
randomness, not pseudo-random generators.

Boot-time verification runs automatically on module load:

  * Confirms /dev/urandom exists and is readable
  * Reads 256 test bytes and checks byte distribution
  * Verifies no single byte appears more than ~10% (bias detection)
  * Confirms at least 100 distinct byte values (diversity check)

If verification fails, the module refuses to load. An easter egg with
real security - someone exploring the REPL discovers (forge) and gets
actual cryptographic passwords, not toys.


7.7 Audit Trail Heritage
------------------------

The cryptographic audit trail (Memo-0005) descends from VMS
SECURITY.AUDIT$JOURNAL and the cluster-wide security infrastructure of
VMS 6.0 (1993). That system introduced:

  * SECURITY_POLICY bit 7 propagation
  * Intrusion detection state replicated cluster-wide
  * Breakin attempts detected across all nodes as one
  * TLV-encoded object store
  * The [000000]SECURITY.SYS file in ODS5 stored SECURITYCLASS records

The SECURITY_POLICY system parameter controlled C2/B1 security behavior:

Bit 7 in VMS 6.0 was cluster-wide security state propagation. When set,
breakin detection and intrusion state replicated across all cluster
nodes so N nodes behaved as one security domain.

The design principle then, as now: cluster nodes behave identically. N
nodes, one security domain. Every significant action audited, every
audit record signed.

Cyberspace audit trails apply the same principle at IPv6 scale.


------------------------------------------------------------------------
8. THE NOVICE INTERFACE
------------------------------------------------------------------------

Cyberspace must be approachable by normal people. The terminal is for
operators. A friendly interface layer serves everyone else.


8.1 The Problem
---------------

A novice asked: "Why would I want to use this? I have iCloud. They have
recipes and cat pictures."

Valid question. The answer must be compelling without mentioning
Ed25519, SPKI certificates, hash chains, Merkle trees, or S-expressions.


8.2 What Novices Want
---------------------

They don't want a distributed cryptographic vault. They want:

  * My stuff is mine - Not rented from a corporation
  * It survives - No company shutdown deletes my photos
  * I control sharing - Family, not platforms
  * Privacy - My recipes aren't AI training data
  * Legacy - Grandkids can inherit the vault
  * No ads - I'm not the product


8.3 Two Doors
-------------


                        CYBERSPACE
                            │
               ┌────────────┴────────────┐
               │                         │
         ┌─────▼─────┐             ┌─────▼─────┐
         │ Terminal  │             │ Friendly  │
         │   (cs)    │             │   Door    │
         └─────┬─────┘             └─────┬─────┘
               │                         │
           Operators                  Novices
            Hackers                   Family
            Admins                   Everyone

The terminal offers full power and complexity for those who want it. The
friendly door offers drag-and-drop simplicity - same operations,
different presentation.

Both doors lead to the same vault. Both use the same Scheme underneath.


8.4 Principles
--------------

  * Never dumb down the core - Scheme stays Scheme
  * Add layers, don't subtract - Friendly is additional, not replacement
  * Same operations - Both doors do the same things
  * Gradual revelation - Novices can discover the terminal if curious
  * Family friendly - Grandma can use it


8.5 The Test
------------

If a novice can create a vault in 30 seconds, add a photo in 5 seconds,
invite family in 1 minute, and understand what they have - we've
succeeded.


8.6 The Koan
------------

There is no point scaling to 2^128 if you assume everyone is a Schemer.

The cryptographic address space, the capability chains, the Merkle
proofs — all of that is implementation. The user doesn't sign
certificates, they approve a peer. They don't query the vault, they
inspect soup.

If the system requires understanding SPKI to use safely, the system
failed. The security properties must emerge from natural actions, not
careful ones.

The complexity serves the simplicity, not the other way around.


------------------------------------------------------------------------
9. CRYPTOGRAPHIC SELECTIONS
------------------------------------------------------------------------

Every cryptographic algorithm in Cyberspace was chosen for specific
properties. This section documents the selections and their rationale.


9.1 Signatures
--------------


  Algorithm           Use                       Selection Rationale                                               
  Ed25519             Primary signatures        Small keys (32B), fast, constant-time, no RNG needed for signing  
  SLH-DSA (SPHINCS+)  Post-quantum              Hash-based, conservative security, stateless, FIPS 205            
  ML-DSA (Dilithium)  Post-quantum              Lattice-based, smaller signatures than SLH-DSA, FIPS 204          
  Lamport             Reference implementation  Educational, hash-only security, foundation for SPHINCS+          

Ed25519 is the current standard. Post-quantum migration uses hybrid
signatures (Ed25519 + SLH-DSA or ML-DSA) to preserve security if either
scheme breaks. See pq-crypto.scm for implementation.


9.2 Hash Functions
------------------


  Algorithm  Use                          Selection Rationale                                   
  SHA-512    Object identity, signatures  Conservative choice, 256-bit quantum security         
  BLAKE2b    Content addressing, KDF      Faster than SHA-2, proven design, libsodium native    
  SHAKE256   Post-quantum Merkle          XOF for variable output, SHA-3 family, NIST standard  
  Argon2id   Passphrase stretching        Memory-hard, resists GPU/ASIC, winner of PHC          

Hash functions survive quantum computers. Shor's algorithm (exponential
speedup) breaks signatures and key exchange but not hashes. Grover's
algorithm provides only quadratic speedup against hashes — halving
effective security bits, not destroying them.

SHA-512's 512 bits become 256-bit quantum security. Still beyond brute
force. SHA-256 would drop to 128-bit quantum security — acceptable but
less margin. We chose SHA-512 for the conservative 256-bit post-quantum
level.

BLAKE2b (256-bit output) provides 128-bit quantum security, sufficient
for content addressing where collision resistance matters more than
preimage resistance.


9.3 Symmetric Encryption
------------------------


  Algorithm           Use                Selection Rationale                       
  XSalsa20-Poly1305   Vault encryption   NaCl default, 24-byte nonce, proven AEAD  
  ChaCha20-Poly1305   Object encryption  IETF standard, 12-byte nonce, streaming   
  XChaCha20-Poly1305  Keystore           Extended nonce (24B), random nonce safe   

The Salsa20/ChaCha20 family was chosen over AES: no timing attacks, no
hardware requirements, Poly1305 is provably secure MAC. The 'X' variants
use extended nonces, safe for random generation.


9.4 Key Exchange
----------------


  Algorithm  Use                     Selection Rationale                               
  X25519     Ephemeral key exchange  Curve25519 ECDH, constant-time, small keys        
  HKDF       Key derivation          RFC 5869, extract-then-expand, domain separation  

X25519 provides forward secrecy for CIP channels. Session keys are
derived via HKDF with protocol-specific info strings for domain
separation.


9.5 Secret Sharing
------------------


  Algorithm   Use                             Selection Rationale                                 
  Shamir SSS  Key backup, threshold recovery  Information-theoretic security, GF(2^8) arithmetic  

Shamir's scheme splits secrets into n shares where any k can
reconstruct. Used for master key backup (5-of-9) and threshold
governance.


9.6 Blind Signatures (Chaum)
----------------------------

David Chaum's 1982 blind signature scheme enables anonymous credentials.
The Library holds four Chaum papers:

  * Blind Signatures for Untraceable Payments (1982) — the foundation
  * Untraceable Electronic Cash (1988, with Fiat & Naor)
  * Untraceable Electronic Mail (1981) — mix networks
  * The Dining Cryptographers Problem (1988) — unconditional anonymity

Cyberspace uses Chaum-style blind signatures for bearer capabilities:
prove authorization without revealing identity. The issuer signs a
blinded credential; when unblinded and presented, the signature verifies
but cannot be linked to issuance.

This preserves the choice Bitcoin abandoned: registered capabilities
when you need accountability, bearer capabilities when you need privacy.


9.7 Merkle Trees
----------------

Content authentication via binary hash trees. Current implementation
uses SHA-512; post-quantum migration to SHAKE256 or BLAKE3.

Properties: O(log n) inclusion proofs, streaming verification,
append-only audit logs. Merkle's 1987 paper is in the Library.


9.8 Random Number Generation
----------------------------

All randomness flows through libsodium's randombytes_buf(), which uses:

  * Linux: getrandom(2) syscall (ChaCha20-based since 5.17, Tso (MIT))
  * macOS/BSDs: arc4random_buf() (ChaCha20-based, name is legacy)

All platforms now use ChaCha20 underneath - different APIs, same
algorithm. Hardware entropy (RDRAND/RDSEED) feeds the OS pool. Quantum
RNG (ID Quantique, drand beacons) planned for Phase 3+.


9.9 The TCB Principle
---------------------

The Trusted Computing Base holds only:

  * Ed25519 sign/verify (classical)
  * ML-DSA-65 sign/verify (post-quantum, FIPS 204)
  * SLH-DSA-SHAKE-256s sign/verify (post-quantum, FIPS 205)
  * SHA-512 hash
  * Certificate chain verification

Everything else is policy. The TCB is ~3000 lines of OCaml calling
libsodium and liboqs, with Rocq extraction for core properties. This
minimizes the attack surface: prove the crypto, evolve the rest freely.


------------------------------------------------------------------------
10. RELEASE GATES
------------------------------------------------------------------------

Two formal verification milestones gate Cyberspace releases:


10.0 Version Semantics
----------------------


  Version  Gate      Requirement                               
  v0.9.x   pre-beta  Development, unstable APIs                
  v1.0.0   beta      Rocq proofs complete, extraction working  
  v2.0.0   release   TLA+ model checked, no safety violations  

Semantic versioning with verification gates. No version advances without
passing its gate.


10.1 Beta Gate: Rocq Extraction
-------------------------------

The TCB must be machine-verified before beta. SpkiTcb.v defines the
security model; extraction produces spki_tcb.ml. Hand-written code that
'matches the spec' is not verified — it's aspirational.

The critical property: capability attenuation (tag_intersect only
shrinks permissions). The Rocq proofs establish this mathematically.
Without verified extraction, the trust anchor is unverified.

Beta ships when:

  * All Admitted proofs in SpkiTcb.v are complete
  * Rocq extraction produces working OCaml
  * Extracted code passes test_tcb.ml


10.2 Release Gate: TLA+ Specification
-------------------------------------

Distributed protocols (gossip, federation, consensus) must be
model-checked before release. TLA+ formalizes the state machines; TLC
exhaustively explores state space.

TLA+ is a trailing artifact — you model what you've built, then verify
it handles edge cases. Writing TLA+ for a moving target wastes effort.

Release ships when:

  * Gossip protocol modeled and checked
  * Federation convergence modeled and checked
  * No safety violations in TLC model checker


------------------------------------------------------------------------
11. VMS LINEAGE
------------------------------------------------------------------------


11.1 VMS Security (1984-1994)
-----------------------------

DEC was a family. This was merely one specialty.

The Security Project Team was Derrell Piper, Mark Pilant, Andy
Goldstein. TCSEC C2/B1 certification on VAX/VMS and Alpha VMS. VMS 6.0.

What we built:

  * $CHKPRO - the privilege checking gate, the single point where all privilege decisions were made
  * The entire auditing subsystem (final form), comprehensive privilege and access logging
  * C2/B1 certified security model (Orange Book compliance, proven secure)

Access: The security project team (or anyone we designated) were the
only ones allowed in the kernel group's modules. Dave Cutler's team
begrudgingly accepted this as a mandate from heaven (Ken Olsen //
Maynard). We got in on a mandate. We stayed because the work was good.

Inheritance: When Cutler left for Microsoft, his modules were inherited.
The privilege auditing 'rototill' required fluency in MACRO-32.

Text in the Library of Cyberspace is in the color of phosphor green, the
color of VT100s and reflective of IBM green bar printouts. Not retro.
Not nostalgia. Memory.


11.2 The Road Not Taken
-----------------------

We all built VAX/VMS V6.0 and then we threw it away--literally tossing
our green bar printouts of our respective subsystems into an empty cube
on ZK03/4. The code of what could have been. The end of DEC.

They must have done something similar after PRISM/Mica was cancelled,
ahead of that fateful offer to Gates & Co. that gifted Microsoft
dominance in COTS computing.

PRISM/Mica was being designed for TCSEC B1. That's the legacy--the
mindset, the trust model, and the codebase--that Gates was gifted in an
offer they couldn't refuse.

Of all the people at DEC, Cutler--designer of the MicroVAX--could see
the writing on the wall. The age of PCs had been born. Digital missed
the train.

The weave predates the software. The people who understood trust
architectures kept finding each other:

  * DEC -> Microsoft -> Cisco -> here
  * Peter Lofgren was there. There's a photograph of that meeting floating around in PDP-10 space. He ended up at Cisco--our nexus.

The thread is unbroken. From the people who built it, through the people
who maintained it, to the people who understood what was lost. And now
into the code.

That's provenance you can't fake.


11.3 Languages
--------------

BLISS - Bill Wulf at CMU (1969) created BLISS as an expression language,
not 'DEC's C'. Everything returns a value. Lisp in systems clothing.

MACRO-32 - VAX assembly with rich macros. The kernel was MACRO-32.
Learned it from the privilege auditing rototill.

The VMS Runtime - Had a rich macro wrapper for BLISS. That macro system
was a Lisp. We knew. That's why we used it.

A Lisper who fell in love with BLISS (an expression language, like
home).


11.4 System Service Vocabulary
------------------------------

The VMS system service vocabulary provides the conceptual heritage for
Cyberspace's security primitives.

The security subsystem was written exclusively in BLISS (with MACRO-32
fluency for reading the layers beneath). Now it's Scheme.

Access check pattern:


    $CREATE_USER_PROFILE  →  builds encoded user security profile
            ↓
    $CHKPRO / $CHECK_ACCESS  →  evaluates access using profile + object protection
            ↓
    SS$_NORMAL / SS$_NOPRIV  →  grant or deny

Key item codes (CHP$_*):

  * CHP$_ACCESS → access-mask (requested access type bitmask)
  * CHP$_PROT → protection (SOGW protection mask)
  * CHP$_OWNER → owner (object owner identifier)
  * CHP$_UIC → principal (accessor's identity)
  * CHP$_PRIV → privileges (privilege mask)
  * CHP$_ACL → acl (access control list)
  * CHP$_FLAGS → flags (check options: observe/alter)

Flags: CHP$V_AUDIT → audit?, CHP$V_OBSERVE → read?, CHP$V_ALTER →
write?

Return status: SS$_NORMAL → #t, SS$_NOPRIV → #f, SS$_ACCVIO →
'accvio, SS$_IVACL → 'invalid-acl

Impersonation ($PERSONA_*): Used by DECdfs and distributed file services
to act on behalf of remote clients without re-implementing access
checks.

$PERSONA was designed by the DEC Distributed File System group, not VMS
Engineering.

The original $IMPERSONATION framework was authored by myself with Rich
Bouchard. It was lost during the Mitnick incidents when Andy Goldstein
and I decided we needed to rebuild our compiler chain from known good
offsite backups - with Ken Thompson's 'Reflections on Trusting Trust'
fresh in our minds. In doing so, we lost a year of development during
Alpha, including the original kernel threads implementation and the
$IMPERSONATION framework.


11.5 Syntax Heritage
--------------------

Dylan-style keyword arguments are a tribute to Apple Cambridge and MIT:


    (translate text from: 'en to: 'fr)
    (enroll-request name timeout: 30)

Ada/Dylan/BLISS style - named parameters, self-documenting:

  * Ada: Open(File => "data.txt", Mode => Read_Only)
  * Dylan: open(file: "data.txt", mode: #"read")
  * BLISS: OPEN(FILE = 'data.txt', MODE = READONLY)

Self syntax was weird. Smalltalk doesn't work for math people (2 + 3 * 4
= 20, not 14). Scheme is honest - prefix, unambiguous, mathematical.


11.6 IETF Security Protocols
----------------------------

VMS Security Project Leader → TGV → Cisco → loaned to Microsoft
for IPsec/IKE.

draft-ietf-ipsec-isakmp-gss-auth-07 (1998-2001) defined GSS-API
authentication for IKE, binding Kerberos into Windows 2000's IPsec
implementation. Seven revisions, co-authored with Swander on later
versions.

The draft defined authentication method values:

  * 65001 - GSS-API using Kerberos
  * 65002 - Generic GSS-API
  * 65003 - GSS-API with SPNEGO
  * 65004 - GSS-API using SPKM

Microsoft's IKE implementation shipped with NT5 (Windows 2000) using
this specification. The Windows 2000 compatibility notes in the draft -
the MD5 hash over 'GSSAPI' for Vendor ID - are fingerprints in shipping
code.

The thread: DEC security architecture → IETF protocol specification
→ Microsoft's authenticated IPsec. Same design principles, different
decades.


------------------------------------------------------------------------
12. INTERFACE PHILOSOPHY
------------------------------------------------------------------------


12.1 English on Top, Scheme Underneath
--------------------------------------


    Terminal:    English verbs for mortals
    REPL:        Scheme for hackers
    Commands:    Forever cast in English/Scheme
    Messages:    Multilingual (the command line speaks your tongue)


12.2 For the Uninitiated
------------------------


    (about)      ; What is this place?
    (huh?)       ; Same question, different inflection
    (what?)      ; Still the same
    (describe)   ; For the formal

The answer morphs with the weave. Standing alone, it suggests
enrollment. With peers, it lists them. The description reflects the
current state--not a static brochure but a living mirror of the
constellation.


12.3 Workstations and Terminals
-------------------------------

Workstations and terminals weren't wrong. PCs aren't the answer to
everything. The right interface for the job at hand. Sometimes your
native language is superior.

Cyberspace runs on terminals because that's what operators use.


12.4 The Period as Imperative (Smalltalk Heritage)
--------------------------------------------------

In Smalltalk, the period terminates a statement. It's the moment of
commitment--everything before it is preparation, the period makes it so.

Cyberspace borrows this: any command suffixed with '.' implies execution
and propagation. 'commit.' means commit and sync. 'fix.' means fix and
make it so.


    commit    → stage the intention
    commit.   → stage, execute, propagate to the weave

The period is not punctuation. It's the imperative mood. Smalltalk
understood that the moment of action deserves its own syntax.


12.5 Do All the Th[i,a]nga
--------------------------

The full toolchain invocation: commit, push, regen-all, publish. An idea
isn't complete until it's self-contained and self-documenting in the
weave.


    thinga := commit → push → regen-all → publish

regen-all is the totality of sanity checking before publishing:
recompile all modules, verify types, run tests, regenerate
documentation. Nothing reaches the weave without passing the
scrutinizer--a nod to Felix Winkelmann's CHICKEN Scheme, whose
scrutinizer catches what the programmer misses. It has more inference
because it's in lambda.

The spelling nods to both 'things' and 'thanga' (Tamil: gold). Ideas
forged through the full cycle become permanent--golden artifacts in the
weave.

Partial work stays local. Published work is proven. The toolchain is the
crucible.


------------------------------------------------------------------------
13. THE SOUP
------------------------------------------------------------------------

The vault browser is called 'soup' after Newton's persistent object
store (1993).


    Newton soup:      Persistent frames, automatic storage
    Cyberspace soup:  Vault objects, content-addressed

Apple Newton -> Dylan -> Scheme. The soup survives.


    (soup)              ; browse the vault
    (soup 'keys)        ; list keys
    (soup-stat 'alice)  ; inspect object


------------------------------------------------------------------------
14. THE RAGA FAVICON
------------------------------------------------------------------------

The Library's favicon is a lambda whose color morphs through the day.


14.1 The Prahar (Watches)
-------------------------


  04-06  violet    brahma muhūrta  ब्रह्म मुहूर्त  pre-dawn meditation  
  06-08  gold      prātaḥkāla   प्रातःकाल               dawn                 
  08-11  teal      saṅgava        सङ्गव                           morning              
  11-14  phosphor  madhyāhna       मध्याह्न                  midday               
  14-17  neon      aparāhṇa      अपराह्ण                     afternoon            
  17-19  orange    sāyāhna        सायाह्न                     evening              
  19-22  coral     pradoṣa        प्रदोष                        dusk                 
  22-04  cyan      niśītha        निशीथ                           night                

Devanāgarī (देवनागरी) means 'city of the gods'
(देव deva + नागरी nāgarī). A script sacred enough to
write the Vedas now marks the watches of a lambda breathing in
Cyberspace.


14.2 Why Ragas?
---------------

Indian classical music assigns ragas to specific times of day. A morning
raga played at midnight is wrong--not because of rules, but because it
doesn't fit. The music knows when it should be heard.


14.3 Why a Breathing Lambda?
----------------------------

The lambda isn't just a logo--it's the fundamental unit. What Scheme
computes, what the weave is made of. Every function, every object, every
sealed thing in the vault is lambdas all the way down.

The color morphing isn't decoration--it's the weave breathing. Lambdas
are being gathered, tested, frozen into vaults across time zones. The
color you see is the pulse of that activity. Dawn gold as the eastern
hemisphere wakes and contributes. Phosphor green at peak hours. Cyan in
the quiet night when the squirrels rest.


14.4 The Easter Egg
-------------------

Someone notices their lambda is orange, asks why, and learns: 'You're
seeing sunset. Somewhere, lambdas are being gathered into the weave of
Cyberspace.'

Those who need to ask are in need of enlightenment. The Library is here
to provide it. They came for the RFCs, they left understanding the
lambda.

The brahma muhurta violet isn't just pretty--it's the hour of
enlightenment. If they're seeing violet, they're already up at the right
time.


14.5 Acknowledgment
-------------------

Personal credit to Pepe Ozan--co-founder of )'(, founder of the )'(
Opera with his lingams fashioned from playa clay. My last mentor, who
took me to Banaras to experience Diwali on the banks of Mother Ganga.
The prahar breathe because of him.


------------------------------------------------------------------------
15. LITTLE FLUFFY CLOUDS
------------------------------------------------------------------------

'What were the skies like when you were young?' -- The Orb, 1990

The realms in the weave are clouds--little fluffy clouds drifting in
ambient space. The Orb understood distributed systems before we had the
words: layers of sound, samples from elsewhere, everything floating,
nothing anchored to a single point.

Fluffy leads the weave. The name was never arbitrary.

The skies when we were young were phosphor green, VT100s in machine
rooms, the hum of VAXen. Now the clouds are realms, and the realms are
lambdas, and the lambdas float in the wilderness of mirrors.

Ambient for the ages. Distributed for the future.


------------------------------------------------------------------------
16. DERIVATION VS. DISCOVERY
------------------------------------------------------------------------


16.1 Lamport Time
-----------------

In the absence of global clock synchronization, distributed systems
establish causal ordering through logical clocks (Lamport, 1978). Each
node maintains a local counter incremented on message send/receive,
establishing a happens-before relation that provides partial ordering
without requiring synchronized wall-clock time.

The happens-before relation was always there--Lamport gave it a name and
a notation. That's discovery. Seeing what was already true.


16.2 call/cc
------------

Most language features are about what you can say. call/cc is about what
exists.

call/cc says: the future of the computation is a value you can hold,
store, invoke later. Continuations. Time as a first-class object. That's
not syntax preference--that's ontology.

The continuation exists whether you capture it or not--call/cc just lets
you name it. The future was always there, implicit in every expression.
Scheme made it explicit.

SICP wasn't about parentheses. It was a course in thinking, disguised as
a programming textbook. Streams, lazy evaluation, the environment model,
the metacircular evaluator--and then call/cc, which breaks your brain
the right way.


16.3 The Y Combinator
---------------------

The Y combinator (Y = λf.(λx.f(x x))(λx.f(x x))) is a fixed-point
combinator enabling recursion without explicit self-reference. It's
elegant. It's also just math that falls out of lambda
calculus--derivation, not discovery.

A certain Silicon Valley venture capital firm took the name as borrowed
plumage. Value signaling to people who recognize the symbol but don't
work in the calculus. The firm's founder wrote 'On Lisp', evangelized
the aesthetic--but Arc didn't have call/cc. Common Lisp doesn't have it.
He came from the CL side, where continuations aren't primitive.

Naming the firm 'Y Combinator' signals: I read the cool parts. Not
naming it 'call/cc' signals: I stopped before it got weird.

The Y combinator is page 300 of SICP. call/cc is the last chapter. Most
people don't finish. And those who do often go on to write their own
Scheme dialect. This is mine.


16.4 The Distinction
--------------------

Derivation: The Y combinator. Recursion falling out of self-application.
True but not illuminating.

Discovery: Lamport clocks. call/cc. Seeing structure that was always
there, giving it a name, making it usable.

Cyberspace is built on discoveries: happens-before for distributed time,
continuations for control flow, SPKI for authorization. The derivations
are implementation details.


16.5 Why We (Mostly) Don't Use It
---------------------------------

Search the Cyberspace codebase for call/cc. You'll find it in SRFI
libraries (srfi-1, srfi-18) and one deliberate exception: the debug
inspector's (bt) command uses call/cc to capture the call chain at
throw-site.

That exception proves the rule. Understand the deep machinery, use the
simple tool:

  * Exceptions → guard, handle-exceptions (srfi-34)
  * Generators → srfi-158 (coroutine-like without full continuations)
  * Early exit → explicit returns, not escape continuations
  * Backtracking → explicit state, not captured futures
  * Debug introspection → call/cc (the one legitimate use)

Captured continuations create implicit control flow. Every call/cc is a
potential goto to anywhere the continuation was captured. In a
security-critical codebase, implicit is the enemy.

The condition system covers what most people use call/cc for. The debug
inspector needs actual continuations to show where the exception
occurred. That's the rare case where the ontology matters.

Appreciate the ontology. Deploy the mundane. Know when to break the
rule.


------------------------------------------------------------------------
17. TIMELINE
------------------------------------------------------------------------


    1942  Manhattan Project begins (Los Alamos)
    1945  Trinity test (July 16, Alamogordo)
    1947  Bell Labs invents the transistor (Bardeen, Brattain, Shockley)
    1958  ARPA founded (response to Sputnik)
    1960  DEC PDP-1 (18-bit BE, first minicomputer, TECO, Spacewar!)
    1964  IBM System/360 (32-bit BE, supervisor/problem state)
    1965  Multics development begins (MIT/GE/Bell Labs)
    1969  ARPANET: BBN's IMPs (Honeywell 516, 16-bit BE) connect first four nodes
          UCLA: SDS Sigma 7 (32-bit BE), SRI: SDS 940 (24-bit BE)
          UCSB: IBM 360/75 (32-bit BE), Utah: PDP-10 (36-bit BE)
    1969  Bill Wulf creates BLISS at CMU
    1972  ARPA becomes DARPA (Defense)
    1975  Gasser's password generator (Multics)
    1975  DES adopted (IBM Lucifer + NSA, Feistel)
    1976  TOPS-20 (TWENEX) - BBN's TENEX becomes DEC product
    1984  VAXcluster, VMS security work begins
    1985  DEC MicroVAX II (32-bit LE, VAX on a chip, Cutler)
    1985  VAX/VMS C2 certification (Orange Book)
    1986  NSFnet replaces ARPANET backbone
    1992  Dylan released (Apple Cambridge), Macintosh Common Lisp
    1993  VAX/VMS 6.0, Alpha/VMS 6.0 (C2/B1)
    1994  SDSI proposed at IETF 29 Seattle
    1995  Windows NT 3.51 C2 certified (Alpha, x86)
    1999  SPKI RFC 2693
    1999  Network Alchemy CryptoCluster beta → Mastercard (St. Louis) - 32 nodes, Pentium III/StrongARM, Hi/Fn 7700 + 6500 accelerators
    2000  Windows 2000 (NT5) ships with IPsec/IKE, GSS-API, Policy Manager snap-in
    2026  Cyberspace - synthesis of all the above


------------------------------------------------------------------------
18. RESIDENT MODULES
------------------------------------------------------------------------


18.1 Blade Guards Disengaged
----------------------------

Resident modules extend top-level syntax. They're loaded at startup,
always available, like LSE (Language-Sensitive Editor) on VMS or Emacs
on Unix. The metaphor: blade guards disengaged - full power, no safety
rails.

The REPL tracks residents with the (residents) command:


    Resident Modules
      pencil    [ep-]   Electric Pencil - Michael Shrayer (1976)
      schemacs  [sm-]   Schemacs - ddp & Claude (2026)
      teco      [te-]   TECO - Dan Murphy (1962)
    (blade guards disengaged - top-level syntax extensions)

Each resident declares a prefix to avoid namespace collision. Prefixes
appear in brackets: [ep-] for pencil, [te-] for teco, [sm-] for
schemacs.


18.2 The resident-info Declaration
----------------------------------

Every resident module must contain a resident-info declaration - a
formal acknowledgment that the module knows what it's doing:


    ;;; Resident module declaration (required)
    ;;; "I know what I'm doing" - this module extends top-level
    (define resident-info
      '((name . teco)
        (prefix . "te-")
        (description . "TECO - Dan Murphy (1962)")
        (entry . teco)
        (entry-novice . teco-novice)))

The declaration serves as both documentation and safety check.
(load-resident) verifies the declaration exists before registering.


18.3 Heritage
-------------

The three original residents honor the lineage of text editing:

  * TECO (1962) - Dan Murphy at MIT. Every keystroke a command. EMACS was written in TECO before it was written in anything else.
  * Electric Pencil (1976) - Michael Shrayer. First word processor for microcomputers, predates WordStar by two years.
  * Schemacs (2026) - ddp & Claude, inspired by guenchi/Schemacs (Chez Scheme). Emacs keybindings, Scheme soul. The collaboration continues.

Hemlock (1987) - Bill Chiles and Rob MacLachlan at CMU. An Emacs-like
editor written entirely in Common Lisp for CMU CL. Hemlock proved that a
Lisp implementation could host its own extensible editor, the extension
language and the implementation language being one and the same.
Schemacs follows that tradition - the REPL is the extension language.

The credits in (residents) aren't decoration - they're acknowledgment.
Dan Murphy's TECO ran on PDP-1s. Michael Shrayer's Electric Pencil ran
on 8K Altairs. Now they run on Cyberspace, sixty years of heritage
compressed into lambdas.


------------------------------------------------------------------------
CLOSING
------------------------------------------------------------------------

In Scheme and Dylan with Newton soup.

The Little Schemer finally gets to write Scheme.


------------------------------------------------------------------------
CHANGELOG
------------------------------------------------------------------------

- 2026-01-28 — Added IETF Security Protocols (section 11.6):
draft-ietf-ipsec-isakmp-gss-auth, GSS-API/Kerberos for NT5

- 2026-01-28 — Added Resident Modules section (section 18): blade
guards, resident-info, heritage

- 2026-01-22 — Added version semantics (v0.9.x/v1.0.0/v2.0.0 gates)

- 2026-01-22 — Folded designer-notes.scm into memo (open kimono);
added call/cc rationale

- 2026-01-21 — Added Release Gates (section 10): Rocq for beta, TLA+
for release

- 2026-01-19 — Added Audit Trail Heritage (section 7.7), moved from
Memo-0005

- 2026-01-18 — Expanded Why Scheme with homoiconicity rationale
(section 1.2)

- 2026-01-18 — Added The Koan (section 8.6): complexity serves
simplicity

- 2026-01-17 — Added Cryptographic Selections section (section 9)

- 2026-01-17 — Corrected heritage: SDSI/Rivest, SPKI/Ellison, IETF
merger (section 1.1)

- 2026-01-17 — Added Novice Interface section (section 8)

- 2026-01-15 — Gasser Multics provenance added (section 7.1)

- 2026-01-15 — OSS operational geography framing, 40+ languages
(section 7.3)

- 2026-01-15 — Added cryptographic RNG with boot-time verification
(section 7.6)

- 2026-01-15 — Added forge/smelter heritage (section 7)

- 2026-01-15 — Initial draft, heritage notes

------------------------------------------------------------------------
