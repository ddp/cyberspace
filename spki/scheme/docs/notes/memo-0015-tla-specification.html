<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <title>Memo 0015: TLA+ Formal Specification</title>
  <link rel="icon" id="favicon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27%230f0%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>">
  <script>
(function(){
  var h=new Date().getHours(),c;
  if(h>=4&&h<6)c='%23845EC2';       // brahma muhurta - violet
  else if(h>=6&&h<8)c='%23ffd700';  // dawn - gold
  else if(h>=8&&h<11)c='%2300d4aa'; // morning - teal
  else if(h>=11&&h<14)c='%230f0';   // midday - phosphor
  else if(h>=14&&h<17)c='%2339ff14';// afternoon - neon
  else if(h>=17&&h<19)c='%23ff6600';// sunset - orange
  else if(h>=19&&h<22)c='%23ff3366';// evening - coral
  else c='%2300ffff';               // night - cyan
  document.getElementById('favicon').href='data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27'+c+'%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>';
})();
</script>
  <link rel="stylesheet" href="memo.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<h1>Memo 0015: TLA+ Formal Specification</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This Memo specifies the use of TLA+ (Temporal Logic of Actions) for formal specification and model checking of Cyberspace protocols, ensuring correctness before implementation.</p>
</section>
<section>
<h2>Motivation</h2>
<p>Running code is necessary but not sufficient:</p>
<ul>
<li>Tests check examples: Not all possible executions</li>
<li>Reviews check logic: Not all interleavings</li>
<li>Bugs hide in corners: Race conditions, edge cases</li>
</ul>
<p>Distributed systems have exponentially many execution paths; exhaustive testing is impossible, but exhaustive specification checking is not.</p>
<p>TLA+ provides:</p>
<ul>
<li>Precise specification: Mathematical description of behavior</li>
<li>Model checking: Exhaustive state space exploration</li>
<li>Proof capability: Formal verification of properties</li>
<li>Design tool: Find bugs before writing code</li>
</ul>
<p>Formal specification forces clarity of thought; ambiguities that hide in prose become contradictions in mathematics.</p>
<p>From Lamport:</p>
<blockquote>
<p>If you're thinking without writing, you only think you're thinking.</p>
</blockquote>
</section>
<section>
<h2>Specification</h2>
<h3>TLA+ Overview</h3>
<p>TLA+ describes systems as state machines:</p>
<pre class="language-tla">
VARIABLES state, messages, decisions

Init ==
  /\ state = [n \in Nodes |-&gt; "idle"]
  /\ messages = {}
  /\ decisions = {}

Next ==
  \/ Propose(...)
  \/ Prepare(...)
  \/ Commit(...)
  \/ Decide(...)

Spec == Init /\ [][Next]_&lt;&lt;state, messages, decisions&gt;&gt;
</pre>
<h3>Safety Properties</h3>
<p>Invariants that must always hold:</p>
<pre class="language-tla">
TypeOK ==
  /\ state \in [Nodes -&gt; {"idle", "prepared", "committed"}]
  /\ messages \subseteq Message
  /\ decisions \subseteq Value

Agreement ==
  \A n1, n2 \in Nodes:
    (decisions[n1] # {} /\ decisions[n2] # {}) =&gt;
      decisions[n1] = decisions[n2]
</pre>
<h3>Liveness Properties</h3>
<p>Temporal properties about progress:</p>
<pre class="language-tla">
Termination ==
  &lt;&gt;(\A n \in Nodes: decisions[n] # {})

EventualConsistency ==
  []&lt;&gt;(\A n1, n2 \in Nodes: state[n1] = state[n2])
</pre>
</section>
<section>
<h2>Cyberspace Protocol Specifications</h2>
<h3>Threshold Signatures (Memo-008)</h3>
<pre class="language-tla">
--------------------------- MODULE ThresholdSig ---------------------------
EXTENDS Integers, FiniteSets

CONSTANTS Signers, Threshold, Script

VARIABLES signatures, verified

Init ==
  /\ signatures = {}
  /\ verified = FALSE

Sign(s) ==
  /\ s \in Signers
  /\ s \notin {sig.signer : sig \in signatures}
  /\ signatures' = signatures \union
       {[signer |-&gt; s, script |-&gt; Script, valid |-&gt; TRUE]}
  /\ verified' = verified

Verify ==
  /\ Cardinality({sig \in signatures : sig.valid}) &gt;= Threshold
  /\ verified' = TRUE
  /\ UNCHANGED signatures

Next ==
  \/ \E s \in Signers: Sign(s)
  \/ Verify

\ Safety: Never verify with insufficient signatures
Safety ==
  verified =&gt; Cardinality({sig \in signatures : sig.valid}) &gt;= Threshold

\ Liveness: If enough sign, eventually verify
Liveness ==
  (Cardinality(Signers) &gt;= Threshold) =&gt; &lt;&gt;(verified)

=============================================================================
</pre>
<h3>Audit Trail (Memo-003)</h3>
<pre class="language-tla">
--------------------------- MODULE AuditTrail ---------------------------
EXTENDS Integers, Sequences

CONSTANTS Actors, Actions

VARIABLES log, sequence

Init ==
  /\ log = &lt;&lt;&gt;&gt;
  /\ sequence = 0

Append(actor, action) ==
  /\ actor \in Actors
  /\ action \in Actions
  /\ sequence' = sequence + 1
  /\ log' = Append(log, [
       seq |-&gt; sequence',
       actor |-&gt; actor,
       action |-&gt; action,
       parent |-&gt; IF sequence = 0 THEN "genesis" ELSE log[sequence].hash
     ])

\ Invariant: Chain integrity
ChainIntegrity ==
  \A i \in 1..Len(log)-1:
    log[i+1].parent = log[i].hash

\ Invariant: Monotonic sequence
MonotonicSequence ==
  \A i \in 1..Len(log)-1:
    log[i+1].seq = log[i].seq + 1

=============================================================================
</pre>
<h3>Byzantine Consensus (Memo-011)</h3>
<pre class="language-tla">
--------------------------- MODULE PBFT ---------------------------
EXTENDS Integers, FiniteSets

CONSTANTS Nodes, f, Values

ASSUME Cardinality(Nodes) &gt;= 3f + 1

VARIABLES
  view,
  prepares,
  commits,
  decisions

Init ==
  /\ view = 0
  /\ prepares = [n \in Nodes |-&gt; {}]
  /\ commits = [n \in Nodes |-&gt; {}]
  /\ decisions = [n \in Nodes |-&gt; {}]

PrePrepare(primary, v) ==
  /\ primary = Leader(view)
  /\ v \in Values
  /\ \A n \in Nodes:
       prepares' = [prepares EXCEPT ![n] = @ \union {[view |-&gt; view, value |-&gt; v]}]
  /\ UNCHANGED &lt;&lt;view, commits, decisions&gt;&gt;

Prepare(n, v) ==
  /\ [view |-&gt; view, value |-&gt; v] \in prepares[n]
  /\ Cardinality({m \in Nodes : [view |-&gt; view, value |-&gt; v] \in prepares[m]}) &gt;= 2f + 1
  /\ commits' = [commits EXCEPT ![n] = @ \union {[view |-&gt; view, value |-&gt; v]}]
  /\ UNCHANGED &lt;&lt;view, prepares, decisions&gt;&gt;

Commit(n, v) ==
  /\ [view |-&gt; view, value |-&gt; v] \in commits[n]
  /\ Cardinality({m \in Nodes : [view |-&gt; view, value |-&gt; v] \in commits[m]}) &gt;= 2f + 1
  /\ decisions' = [decisions EXCEPT ![n] = {v}]
  /\ UNCHANGED &lt;&lt;view, prepares, commits&gt;&gt;

\ Safety: Agreement
Agreement ==
  \A n1, n2 \in Nodes:
    (decisions[n1] # {} /\ decisions[n2] # {}) =&gt;
      decisions[n1] = decisions[n2]

=============================================================================
</pre>
</section>
<section>
<h2>Model Checking Process</h2>
<h3>1. Write Specification</h3>
<p>Define state machine and properties.</p>
<h3>2. Configure Model</h3>
<pre class="language-tla">
CONSTANTS
  Nodes = {n1, n2, n3, n4}
  f = 1
  Values = {v1, v2}
</pre>
<h3>3. Run TLC Model Checker</h3>
<pre class="language-bash">
$ tlc PBFT.tla
TLC2 Version 2.18
...
Model checking completed. No errors found.
  States explored: 847293
  Distinct states: 12847
</pre>
<h3>4. Analyze Counterexamples</h3>
<p>If property violated, TLC shows trace:</p>
<pre>
Error: Invariant Agreement is violated.
Trace:
  State 1: &lt;Initial&gt;
  State 2: PrePrepare(n1, v1)
  State 3: Prepare(n2, v1)
  ...
  State 12: decisions = [n1 |-&gt; {v1}, n2 |-&gt; {v2}]  &lt;&lt; VIOLATION
</pre>
</section>
<section>
<h2>Integration with Implementation</h2>
<h3>Specification → Implementation</h3>
<pre>
TLA+ Spec          Scheme Implementation
-----------        ---------------------
VARIABLES state    (define-record-type &lt;state&gt; ...)
Init ==            (define (init) ...)
Action(x) ==       (define (action x) ...)
Invariant          (assert (invariant? state))
</pre>
<h3>Runtime Assertions</h3>
<pre class="language-scheme">
(define (append-audit! entry)
  ;; TLA+ invariant: MonotonicSequence
  (assert (&gt; (entry-sequence entry)
             (entry-sequence (last-entry))))
  ;; TLA+ invariant: ChainIntegrity
  (assert (equal? (entry-parent entry)
                  (entry-hash (last-entry))))
  ;; Proceed with append
  ...)
</pre>
</section>
<section>
<h2>PlusCal (Algorithmic TLA+)</h2>
<p>Higher-level syntax that compiles to TLA+:</p>
<pre class="language-tla">
--algorithm ThresholdSign {
  variables signatures = {}, verified = FALSE;

  process (signer \in Signers)
  {
    sign:
      signatures := signatures \union {self};
  }

  process (verifier = "v")
  {
    verify:
      await Cardinality(signatures) &gt;= Threshold;
      verified := TRUE;
  }
}
</pre>
</section>
<section>
<h2>Benefits</h2>
<table>
<tr><th>Aspect </th><th>Without TLA+ </th><th>With TLA+ </th></tr>
<tr><td>Design </td><td>Informal, ambiguous </td><td>Precise, mathematical </td></tr>
<tr><td>Bugs </td><td>Found in testing/production </td><td>Found before coding </td></tr>
<tr><td>Confidence </td><td>"Seems to work" </td><td>"Proven correct" </td></tr>
<tr><td>Documentation </td><td>Natural language </td><td>Executable specification </td></tr>
<tr><td>Maintenance </td><td>Risky changes </td><td>Verify changes </td></tr>
</table>
</section>
<section>
<h2>Limitations</h2>
<ul>
<li>State explosion: Large state spaces take time</li>
<li>Learning curve: TLA+ is different</li>
<li>Abstraction gap: Spec ≠ implementation</li>
<li>Finite models: Cannot check infinite systems directly</li>
</ul>
<p>Mitigations: - Symmetry reduction - Abstraction - Proof for infinite cases</p>
</section>
<section>
<h2>References</h2>
<ul>
<li>Lamport, L. (2002). Specifying Systems: The TLA+ Language.</li>
<li>Lamport, L. (2009). The PlusCal Algorithm Language.</li>
<li>Newcombe, C., et al. (2015). How Amazon Web Services Uses Formal Methods.</li>
<li>TLA+ Tools: https://lamport.azurewebsites.net/tla/tools.html</li>
</ul>
</section>
<section>
<h2>Changelog</h2>
<ul>
<li>2026-01-06</li>
<li>Initial specification</li>
</ul>
</section>
<script>
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
}
(function() {
  // Query param override (for REPL: ?theme=dark or ?theme=light)
  const params = new URLSearchParams(window.location.search);
  const param = params.get('theme');
  if (param === 'dark' || param === 'light') {
    document.documentElement.setAttribute('data-theme', param);
    localStorage.setItem('theme', param);
    return;
  }
  // localStorage preference
  const saved = localStorage.getItem('theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
  } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script>
</body>
</html>
