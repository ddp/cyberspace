Memo 0015: Coq Verification of the Authorization TCB

Date: January 2026 (2026-01-22T05:17:00Z)
Author: Derrell Piper <ddp@eludom.net>

------------------------------------------------------------------------

ABSTRACT

This memo specifies the formal verification approach for the SPKI
authorization Trusted Computing Base using the Coq proof assistant. We
prove authorization correctness, not cryptographic hardness - libsodium
handles the latter. The extraction pipeline generates OCaml code that is
called from Scheme via FFI.


------------------------------------------------------------------------
MOTIVATION
------------------------------------------------------------------------

The Prime Directive (Memo-0001):


    "If it's in the TCB, it's in OCaml. Otherwise it's in Chicken Scheme."

But even OCaml can have bugs. The TCB handles signature chain
verification and authorization decisions. A single bug breaks
everything.

Coq provides:

  * Machine-checked proofs: Theorems verified by computer
  * Extraction: Generate OCaml from proofs
  * Correctness by construction: Implementation matches specification

We prove the authorization logic correct; we trust libsodium for
cryptographic primitives.


------------------------------------------------------------------------
ARCHITECTURE
------------------------------------------------------------------------


    ┌───────────────────────────────────────────────────────────┐
    │                      CYBERSPACE TCB                       │
    │                                                           │
    │  ┌─────────────────────────────────────────────────────┐  │
    │  │              SpkiTcb.v (Coq Proofs)                 │  │
    │  │                                                     │  │
    │  │  Types: principal, tag, cert, auth_request          │  │
    │  │  Algorithms: tag_intersect, verify_chain, authorize │  │
    │  │  Theorems: authorize_requester_match, etc.          │  │
    │  └──────────────────────┬──────────────────────────────┘  │
    │                         │ Extraction                      │
    │  ┌──────────────────────v──────────────────────────────┐  │
    │  │         spki_tcb_extracted.ml (generated)           │  │
    │  └──────────────────────┬──────────────────────────────┘  │
    │                         │ Bridge                          │
    │  ┌──────────────────────v──────────────────────────────┐  │
    │  │              spki_tcb.ml + tcb_stubs.c              │  │
    │  │         (bytes conversion, libsodium FFI)           │  │
    │  └──────────────────────┬──────────────────────────────┘  │
    │                         │                                 │
    │                  ┌──────v──────┐                          │
    │                  │  libsodium  │                          │
    │                  │  (trusted)  │                          │
    │                  └─────────────┘                          │
    └───────────────────────────────────────────────────────────┘

The extraction pipeline: SpkiTcb.v → spki_tcb_extracted.ml → OCaml
library → Scheme FFI.


------------------------------------------------------------------------
WHAT WE PROVE
------------------------------------------------------------------------


Fully Proven Theorems
---------------------

Security-critical theorems with complete proofs (no admits):


  Theorem                    Property                                                
  principal_equal_refl       Reflexivity: p = p                                      
  principal_equal_sym        Symmetry: p = q → q = p                               
  principal_equal_trans      Transitivity: p = q ∧ q = r → p = r                 
  authorize_requester_match  If authorized, requester is named by leaf cert          
  authorize_complete         All preconditions satisfied → authorization succeeds  

The authorize_requester_match theorem is the key security property: it
guarantees that authorization only succeeds when the requester is
actually named in the certificate chain.


Partially Proven Theorems
-------------------------


  Theorem                    Proven Cases                         Admitted Cases                     
  tag_intersect_idemp        TagAll, TagSet, TagPrefix, TagRange  TagThreshold                       
  tag_intersect_subset_left  Most combinations                    TagPrefix recursive, TagThreshold  

The admitted cases stem from design limitations documented below.


Partially Proven: tag_intersect_comm
------------------------------------


  Case          Status                                    
  TagAll        Proven                                    
  TagSet        Proven (via filter_intersect_comm lemma)  
  TagRange      Proven                                    
  TagPrefix     Admitted (recursive structure)            
  TagThreshold  Admitted (Cartesian product ordering)     

The TagSet case required proving that filter intersection produces the
same elements regardless of operand order, then applying
canonicalize_strings to ensure structural equality.


Admitted Theorems
-----------------


  Theorem                  Reason                                  
  verify_chain_sound       Complex induction over chain structure  
  verify_chain_attenuates  Depends on verify_chain_sound           

These are design debt, not security holes. The algorithms are correct;
the proofs are incomplete.


------------------------------------------------------------------------
WHAT WE ASSUME
------------------------------------------------------------------------

Cryptographic operations are axiomatized - we trust libsodium:


    Axiom sha512 : bytes -> bytes.
    Axiom ed25519_verify : bytes -> bytes -> bytes -> bool.

Trust assumptions:

  * libsodium correctness: Ed25519, SHA-512 implementations
  * OCaml runtime: Extraction target executes correctly
  * Hardware: CPU executes instructions correctly


------------------------------------------------------------------------
DESIGN LIMITATIONS
------------------------------------------------------------------------


TagSet Canonical Ordering
-------------------------

Tag intersection commutativity requires canonical representation:


    (tag_intersect (TagSet ["read" "write"]) (TagSet ["write" "read"]))
    ;; Result order depends on input order without canonicalization

Solution implemented: sort and deduplicate TagSet contents. The
canonicalize_canonical lemma bridges structural and semantic equality.


TagThreshold Cartesian Product
------------------------------

Intersection of thresholds produces Cartesian product of subtags:


    (tag_intersect (TagThreshold 2 [A B C]) (TagThreshold 2 [A B C]))
    ;; Produces 9 subtags: [A∩A, A∩B, A∩C, B∩A, B∩B, ...]

This is semantically correct but not structurally idempotent. Options:

  * Require disjoint subtags
  * Normalize after intersection
  * Accept semantic rather than structural idempotence


------------------------------------------------------------------------
EXTRACTION PIPELINE
------------------------------------------------------------------------

Build and extract:


    cd tcb/coq
    coqc SpkiTcb.v              # Type-check proofs, extract OCaml
    dune build                   # Compile extracted + bridge code

The extraction directive:


    Extraction Language OCaml.
    Extraction "spki_tcb_extracted.ml"
      authorize verify_chain tag_intersect principal_equal ...

The bridge module (spki_tcb.ml) converts between Coq's int list
representation and OCaml's native bytes, calling libsodium for
cryptographic operations.


------------------------------------------------------------------------
TEST COVERAGE
------------------------------------------------------------------------


  Suite               Tests  Coverage                                    
  test_extracted.ml   16     Unit tests: principals, tags, chains        
  test_properties.ml  11     Property-based: QCheck random testing       
  test_tcb.exe        62     Full TCB: crypto, cookies, audit, FIPS-181  

All tests pass. The property-based tests validate Coq theorems at
runtime:


  Property                                        Generator Constraints             
  principal_equal reflexive/symmetric/transitive  Random principals                 
  tag_intersect commutative                       Non-threshold tags only           
  tag_intersect idempotent                        Non-threshold, non-empty TagSets  
  tag_intersect TagAll identity                   All tag types                     
  tag_subset reflexive                            Non-threshold tags only           
  TagRange subset containment                     Random ranges                     

TagThreshold is excluded from commutativity/idempotence tests due to
documented structural limitations (Cartesian product ordering).


------------------------------------------------------------------------
FUTURE WORK
------------------------------------------------------------------------

  * Complete tag_intersect_comm for TagPrefix (recursive induction)
  * Prove verify_chain_sound with custom induction principle
  * Consider CompCert or Fiat-Crypto for deeper verification

Current proof coverage is sufficient for beta. The admitted theorems are
proof obligations, not security vulnerabilities.


------------------------------------------------------------------------
REFERENCES
------------------------------------------------------------------------

  [Coq, 2024] The Coq Proof Assistant. https://coq.inria.fr/
  [SPKI, 1999] RFC 2693: SPKI Certificate Theory
  [Memo-045, 2026] Security Architecture
  [libsodium, 2024] https://libsodium.org/

------------------------------------------------------------------------
