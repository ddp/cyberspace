<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <title>Memo 0004: Replication Layer for Library of Cyberspace</title>
  <link rel="icon" id="favicon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27%230f0%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>">
  <script>
(function(){
  var h=new Date().getHours(),c;
  if(h>=4&&h<6)c='%23845EC2';       // brahma muhurta - violet
  else if(h>=6&&h<8)c='%23ffd700';  // dawn - gold
  else if(h>=8&&h<11)c='%2300d4aa'; // morning - teal
  else if(h>=11&&h<14)c='%230f0';   // midday - phosphor
  else if(h>=14&&h<17)c='%2339ff14';// afternoon - neon
  else if(h>=17&&h<19)c='%23ff6600';// sunset - orange
  else if(h>=19&&h<22)c='%23ff3366';// evening - coral
  else c='%2300ffff';               // night - cyan
  document.getElementById('favicon').href='data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27'+c+'%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>';
})();
</script>
  <link rel="stylesheet" href="memo.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<h1>Memo 0004: Replication Layer for Library of Cyberspace</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This Memo specifies a replication layer for the Library of Cyberspace preservation architecture, enabling cryptographically sealed releases to be published, subscribed to, and synchronized across distributed locations while maintaining tamper-evident audit trails.</p>
</section>
<section>
<h2>Motivation</h2>
<h3>Heritage: "Behave as One"</h3>
<p>The VAXcluster principle (1984): N nodes must behave as one. Not eventually consistent. Not loosely coupled. Identical. One security domain, one namespace, one view of the world.</p>
<p>DECnet Phase IV's 24-bit addressing was fatal for internet scale. Cyberspace applies the same principle to IPv6's 128-bit address space. Federated nodes, behaving as one.</p>
<h3>Requirements</h3>
<p>The Library of Cyberspace requires a distribution mechanism that:</p>
<ul>
<li>Preserves cryptographic authenticity - Signatures travel with artifacts</li>
<li>Enables offline verification - No centralized authority required</li>
<li>Records provenance - All publication events are audited</li>
<li>Supports multiple transports - Git, HTTP, filesystem</li>
<li>Maintains loose coupling - Works for confederations of friends</li>
</ul>
<p>These requirements reflect the reality of distributed archival: networks partition, authorities disappear, and trust must be verifiable without phoning home.</p>
<p>Traditional package managers and distribution systems assume centralized registries and online verification. This replication layer is designed for decentralized, long-term preservation where trust is established through Simple Public Key Infrastructure (SPKI) certificates and cryptographic seals.</p>
</section>
<section>
<h2>Design Principles</h2>
<ul>
<li>Sealed Releases - Only cryptographically signed releases can be published</li>
<li>Transport Agnostic - Same API works for git, HTTP, filesystem</li>
<li>Audit Everything - All replication events are recorded in tamper-evident log</li>
<li>Verify Before Trust - Subscribers must verify cryptographic seals</li>
<li>Explicit Authorization - SPKI certificates determine who can publish</li>
</ul>
<p>These principles ensure that trust is established cryptographically rather than administratively, and that the system works regardless of network topology or transport mechanism.</p>
</section>
<section>
<h2>Specification</h2>
<h3>Three Core Operations</h3>
<p>#### 1. seal-publish</p>
<p>Publish a sealed release to a remote location.</p>
<pre class="language-scheme">
(seal-publish version
              remote: target
              archive-format: format
              message: notes)
</pre>
<p>Parameters: - version - Semantic version string (e.g., "1.0.0") - remote - Publication target (git remote, URL, or directory path) - archive-format - 'tarball, 'bundle, or 'cryptographic (default) - message - Release notes (optional)</p>
<p>Behavior:</p>
<ul>
<li>Verify release exists (creates if needed via seal-release)</li>
<li>Create cryptographic archive with: tarball of repository at version tag, SHA-512 hash of tarball, Ed25519 signature of hash, manifest with version, hash, signature</li>
<li>Publish to remote based on type: Git remote (push tag, optionally upload archive), HTTP URL (POST archive to endpoint), Filesystem (copy archive to directory)</li>
<li>Record publication in audit trail with: actor (public key from signing key), action (seal-publish version remote), motivation (release notes), cryptographic seal (signature)</li>
</ul>
<p>Audit Entry Format:</p>
<pre class="language-scheme">
(audit-entry
  (id "sha512:...")
  (timestamp "Mon Jan 5 23:38:20 2026")
  (sequence 1)
  (actor
    (principal #${public-key-blob})
    (authorization-chain))
  (action
    (verb seal-publish)
    (object "1.0.0")
    (parameters "/path/to/remote"))
  (context
    (motivation "Published to filesystem")
    (language "en"))
  (environment
    (platform "unknown")
    (timestamp 1767685100))
  (seal
    (algorithm "ed25519-sha512")
    (content-hash "...")
    (signature "...")))
</pre>
<p>#### 2. seal-subscribe</p>
<p>Subscribe to sealed releases from a remote source.</p>
<pre class="language-scheme">
(seal-subscribe remote
                target: local-path
                verify-key: public-key)
</pre>
<p>Parameters: - remote - Source location (git remote, URL, or directory) - target - Local path for downloaded archives (optional) - verify-key - Public key for signature verification (optional)</p>
<p>Behavior:</p>
<ul>
<li>Discover available releases from remote: Git remote (list tags), HTTP URL (GET /releases endpoint), Filesystem (list .archive files)</li>
<li>Download cryptographic archives</li>
<li>Verify each archive: check manifest structure, verify SHA-512 hash of tarball, verify Ed25519 signature (if verify-key provided)</li>
<li>Extract verified archives to target directory</li>
<li>Record subscription in audit trail: count of releases downloaded, source location, verification status</li>
</ul>
<p>Security Consideration: Without verify-key, subscription downloads archives but cannot verify authenticity. SPKI certificate chains should be used to establish trust.</p>
<p>#### 3. seal-synchronize</p>
<p>Bidirectional synchronization of sealed releases.</p>
<pre class="language-scheme">
(seal-synchronize remote
                  direction: 'both
                  verify-key: public-key)
</pre>
<p>Parameters: - remote - Sync target (git remote, URL, or directory) - direction - 'both (default), 'push-only, or 'pull-only - verify-key - Public key for signature verification (optional)</p>
<p>Behavior:</p>
<ul>
<li>Discover local and remote releases</li>
<li>Compare versions to determine: releases to push (local but not remote), releases to pull (remote but not local)</li>
<li>Execute publication for new local releases</li>
<li>Execute subscription for new remote releases</li>
<li>Record synchronization in audit trail: count pushed and pulled, remote location, direction</li>
</ul>
<p>Use Case: Periodic sync between trusted peers in a confederation.</p>
</section>
<section>
<h2>Archive Format</h2>
<h3>Cryptographic Archive Structure</h3>
<pre>
vault-1.0.0.archive          # Manifest file
vault-1.0.0.archive.tar.gz   # Actual tarball
</pre>
<p>Manifest S-expression:</p>
<pre class="language-scheme">
(sealed-archive
  (version "1.0.0")
  (format cryptographic)
  (tarball "vault-1.0.0.archive.tar.gz")
  (hash "sha512:...")
  (signature "ed25519:...")
  (timestamp 1767685100)
  (sealer #${public-key-blob}))
</pre>
<p>Verification Steps:</p>
<ul>
<li>Read manifest</li>
<li>Hash tarball with SHA-512</li>
<li>Verify hash matches manifest</li>
<li>Verify Ed25519 signature on hash</li>
<li>Check SPKI authorization (optional)</li>
</ul>
</section>
<section>
<h2>Transport Implementations</h2>
<h3>Git Remote</h3>
<ul>
<li>Uses git push to share tags</li>
<li>Optionally uploads archives as release assets (GitHub, GitLab)</li>
<li>Fetch uses git fetch + git tag -l</li>
</ul>
<h3>HTTP Endpoint</h3>
<ul>
<li>POST to /releases/&lt;version&gt; for publication</li>
<li>GET /releases for discovery</li>
<li>Content-Type: application/x-sealed-archive</li>
</ul>
<h3>Filesystem</h3>
<ul>
<li>Copy archives to shared directory</li>
<li>Directory structure: &lt;remote&gt;/&lt;archive-name&gt;</li>
<li>No network required, works with NFS, USB drives, etc.</li>
</ul>
</section>
<section>
<h2>Audit Integration</h2>
<p>Every replication operation creates an audit entry with:</p>
<ul>
<li>Content-addressed ID - SHA-512 hash of entry</li>
<li>Chained structure - References parent entry</li>
<li>SPKI principal - Public key of actor</li>
<li>Dual context - Human motivation + machine environment</li>
<li>Cryptographic seal - Ed25519 signature</li>
</ul>
<p>This provides: - Non-repudiation - Cannot deny publication - Tamper evidence - Changes are detectable - Causality - Chain shows temporal order - Accountability - Know who published what when</p>
</section>
<section>
<h2>Security Considerations</h2>
<h3>Threat Model</h3>
<p>Trusted: - Local filesystem and vault - SPKI private keys - Cryptographic primitives (libsodium)</p>
<p>Untrusted: - Remote repositories - Network transport - Downloaded archives - Remote publishers (until SPKI verified)</p>
<h3>Attack Scenarios</h3>
<ul>
<li>Malicious Archive Substitution - Attacker replaces archive on remote - Mitigation: Signature verification fails</li>
<li>Version Rollback Attack - Attacker removes newer releases - Mitigation: Audit trail shows previous versions</li>
<li>Unauthorized Publication - Attacker publishes fake release - Mitigation: SPKI authorization chain required</li>
<li>Transport Tampering - Network attacker modifies download - Mitigation: Hash and signature verification</li>
</ul>
<p>Each attack is addressed at the cryptographic layer rather than the transport layer, ensuring protection regardless of network conditions.</p>
<h3>Best Practices</h3>
<ul>
<li>Always verify signatures - Use verify-key parameter</li>
<li>Check SPKI certificates - Verify authorization chain</li>
<li>Maintain audit trail - Detect suspicious patterns</li>
<li>Use HTTPS for HTTP transport - Prevent network attacks</li>
<li>Backup signing keys - Use Shamir secret sharing</li>
</ul>
<p>Defense in depth: cryptographic verification is primary, but transport security and operational practices add additional layers.</p>
</section>
<section>
<h2>Implementation Notes</h2>
<h3>Helper Functions</h3>
<pre class="language-scheme">
(tag-exists? tag-name)        ; Check if git tag exists
(git-remote? str)             ; Detect git remote format
(http-url? str)               ; Detect HTTP/HTTPS URL
(publish-filesystem remote version archive)  ; Copy to directory
(publish-http url version archive)           ; POST to endpoint
</pre>
<h3>Dependencies</h3>
<ul>
<li>Git</li>
<li>For version control and tag management - libsodium</li>
<li>Ed25519 signatures, SHA-512 hashing</li>
<li>Chicken Scheme modules:   - (chicken process)</li>
<li>Run git commands   - (chicken file)</li>
<li>Filesystem operations   - (chicken irregex)</li>
<li>URL/remote detection</li>
</ul>
</section>
<section>
<h2>Compatibility</h2>
<p>This specification is compatible with:</p>
<ul>
<li>Git tags</li>
<li>Standard git operations</li>
<li>Git bundles</li>
<li>Portable repository format</li>
<li>Tarball archives</li>
<li>Universal archive format</li>
<li>S-expressions</li>
<li>LISP/Scheme readable format</li>
<li>SDSI/SPKI</li>
<li>Authorization certificates</li>
</ul>
<p>Future extensions may add: - IPFS transport - Content-addressed distribution - Tor hidden services - Anonymous publication - Encrypted archives - Confidential distribution - Multi-signature releases - Threshold authorization</p>
</section>
<section>
<h2>Test Coverage</h2>
<p>See test-replication.scm:</p>
<pre class="language-scheme">
;; Test seal-publish to filesystem
(seal-publish "1.0.0"
              remote: "/tmp/cyberspace-publish-test"
              message: "Published to filesystem")

;; Verify archive exists
(file-exists? "/tmp/cyberspace-publish-test/vault-1.0.0.archive")

;; Verify audit entry created
(audit-read sequence: 1)
</pre>
</section>
<section>
<h2>References</h2>
<ul>
<li>SDSI/SPKI - RFC 2693, RFC 2692</li>
<li>Content-Addressed Storage - Git internals, IPFS</li>
<li>Semantic Versioning - semver.org</li>
<li>Ed25519 - Bernstein et al.</li>
<li>Audit Trails - Memo-002 (Cryptographic Audit Trail)</li>
</ul>
</section>
<section>
<h2>Changelog</h2>
<ul>
<li>2026-01-05</li>
<li>Initial implementation and specification   - seal-publish with git/HTTP/filesystem support   - seal-subscribe with signature verification   - seal-synchronize with bidirectional sync  </li>
<li>Full audit trail integration  </li>
<li>Cryptographic archive format</li>
</ul>
</section>
<script>
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
}
(function() {
  // Query param override (for REPL: ?theme=dark or ?theme=light)
  const params = new URLSearchParams(window.location.search);
  const param = params.get('theme');
  if (param === 'dark' || param === 'light') {
    document.documentElement.setAttribute('data-theme', param);
    localStorage.setItem('theme', param);
    return;
  }
  // localStorage preference
  const saved = localStorage.getItem('theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
  } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script>
</body>
</html>
