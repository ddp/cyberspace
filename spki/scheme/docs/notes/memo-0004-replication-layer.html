<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <title>Memo 0004: Replication Layer for Library of Cyberspace</title>
  <link rel="icon" id="favicon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27%230f0%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>">
  <script>
(function(){
  var h=new Date().getHours(),c;
  if(h>=4&&h<6)c='%23845EC2';       // brahma muhurta - violet
  else if(h>=6&&h<8)c='%23ffd700';  // dawn - gold
  else if(h>=8&&h<11)c='%2300d4aa'; // morning - teal
  else if(h>=11&&h<14)c='%230f0';   // midday - phosphor
  else if(h>=14&&h<17)c='%2339ff14';// afternoon - neon
  else if(h>=17&&h<19)c='%23ff6600';// sunset - orange
  else if(h>=19&&h<22)c='%23ff3366';// evening - coral
  else c='%2300ffff';               // night - cyan
  document.getElementById('favicon').href='data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27'+c+'%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>';
})();
</script>
  <link rel="stylesheet" href="memo.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<h1>Memo 0004: Replication Layer for Library of Cyberspace</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This Memo specifies a replication layer for the Library of Cyberspace preservation architecture, enabling cryptographically sealed releases to be published, subscribed to, and synchronized across distributed locations while maintaining tamper-evident audit trails.</p>
</section>
<section>
<h2>Motivation</h2>
<blockquote>
<p>The network is the computer. — John Gage, Sun Microsystems</p>
</blockquote>
<h3>Heritage: "Behave as One"</h3>
<p>The VAXcluster principle (1984): N nodes must behave as one. Not eventually consistent. Not loosely coupled. Identical. One security domain, one namespace, one view of the world.</p>
<p>DECnet Phase IV's 24-bit addressing was fatal for internet scale. Cyberspace applies the same principle to IPv6's 128-bit address space. Federated nodes, behaving as one.</p>
<p>But unlike VAXcluster's tight coupling over CI bus, Cyberspace replication works over any transport: git pushes, HTTP posts, USB drives carried across air gaps. The cryptography travels with the data.</p>
<h3>Requirements</h3>
<p>The Library of Cyberspace requires a distribution mechanism that:</p>
<ul>
<li>Preserves cryptographic authenticity - Signatures travel with artifacts</li>
<li>Enables offline verification - No centralized authority required</li>
<li>Records provenance - All publication events are audited</li>
<li>Supports multiple transports - Git, HTTP, filesystem</li>
<li>Maintains loose coupling - Works for confederations of friends</li>
</ul>
<p>These requirements reflect the reality of distributed archival: networks partition, authorities disappear, and trust must be verifiable without phoning home.</p>
<p>Traditional package managers and distribution systems assume centralized registries and online verification. This replication layer is designed for decentralized, long-term preservation where trust is established through Simple Public Key Infrastructure (SPKI) certificates and cryptographic seals.</p>
</section>
<section>
<h2>Design Principles</h2>
<ul>
<li>Sealed Releases - Only cryptographically signed releases can be published</li>
<li>Transport Agnostic - Same API works for git, HTTP, filesystem</li>
<li>Audit Everything - All replication events are recorded in tamper-evident log</li>
<li>Verify Before Trust - Subscribers must verify cryptographic seals</li>
<li>Explicit Authorization - SPKI certificates determine who can publish</li>
</ul>
<p>These principles ensure that trust is established cryptographically rather than administratively, and that the system works regardless of network topology or transport mechanism.</p>
</section>
<section>
<h2>Specification</h2>
<h3>seal-publish</h3>
<p>Publish a sealed release to a remote location. The fundamental operation: take what's been cryptographically sealed locally and make it available elsewhere.</p>
<pre class="language-scheme">
(seal-publish version
              remote: target
              archive-format: format
              message: notes)
</pre>
<p>Parameters:</p>
<table>
<tr><th>Parameter </th><th>Description </th></tr>
<tr><td>version </td><td>Semantic version string (e.g., "1.0.0") </td></tr>
<tr><td>remote </td><td>Publication target: git remote, URL, or directory path </td></tr>
<tr><td>archive-format </td><td>'tarball, 'bundle, or 'cryptographic (default) </td></tr>
<tr><td>message </td><td>Release notes (optional) </td></tr>
</table>
<p>Behavior:</p>
<ul>
<li>Verify release exists (creates if needed via seal-release)</li>
<li>Create cryptographic archive with: tarball of repository at version tag, SHA-512 hash of tarball, Ed25519 signature of hash, manifest with version, hash, signature</li>
<li>Publish to remote based on type: Git remote (push tag, optionally upload archive), HTTP URL (POST archive to endpoint), Filesystem (copy archive to directory)</li>
<li>Record publication in audit trail with: actor (public key from signing key), action (seal-publish version remote), motivation (release notes), cryptographic seal (signature)</li>
</ul>
<p>Audit Entry Format:</p>
<pre class="language-scheme">
(audit-entry
  (id "sha512:...")
  (timestamp "Mon Jan 5 23:38:20 2026")
  (sequence 1)
  (actor
    (principal #${public-key-blob})
    (authorization-chain))
  (action
    (verb seal-publish)
    (object "1.0.0")
    (parameters "/path/to/remote"))
  (context
    (motivation "Published to filesystem")
    (language "en"))
  (environment
    (platform "unknown")
    (timestamp 1767685100))
  (seal
    (algorithm "ed25519-sha512")
    (content-hash "...")
    (signature "...")))
</pre>
<h3>seal-subscribe</h3>
<p>Subscribe to sealed releases from a remote source. Pull what others have published, verify it cryptographically, trust nothing until proven.</p>
<pre class="language-scheme">
(seal-subscribe remote
                target: local-path
                verify-key: public-key)
</pre>
<p>Parameters:</p>
<table>
<tr><th>Parameter </th><th>Description </th></tr>
<tr><td>remote </td><td>Source location: git remote, URL, or directory </td></tr>
<tr><td>target </td><td>Local path for downloaded archives (optional) </td></tr>
<tr><td>verify-key </td><td>Public key for signature verification (optional) </td></tr>
</table>
<p>Behavior:</p>
<ul>
<li>Discover available releases from remote: Git remote (list tags), HTTP URL (GET /releases endpoint), Filesystem (list .archive files)</li>
<li>Download cryptographic archives</li>
<li>Verify each archive: check manifest structure, verify SHA-512 hash of tarball, verify Ed25519 signature (if verify-key provided)</li>
<li>Extract verified archives to target directory</li>
<li>Record subscription in audit trail: count of releases downloaded, source location, verification status</li>
</ul>
<p>Security Consideration: Without verify-key, subscription downloads archives but cannot verify authenticity. SPKI certificate chains should be used to establish trust.</p>
<h3>seal-synchronize</h3>
<p>Bidirectional synchronization of sealed releases. For peers who trust each other: what you have that I don't, what I have that you don't, reconcile.</p>
<pre class="language-scheme">
(seal-synchronize remote
                  direction: 'both
                  verify-key: public-key)
</pre>
<p>Parameters:</p>
<table>
<tr><th>Parameter </th><th>Description </th></tr>
<tr><td>remote </td><td>Sync target: git remote, URL, or directory </td></tr>
<tr><td>direction </td><td>'both (default), 'push-only, or 'pull-only </td></tr>
<tr><td>verify-key </td><td>Public key for signature verification (optional) </td></tr>
</table>
<p>Behavior:</p>
<ul>
<li>Discover local and remote releases</li>
<li>Compare versions to determine: releases to push (local but not remote), releases to pull (remote but not local)</li>
<li>Execute publication for new local releases</li>
<li>Execute subscription for new remote releases</li>
<li>Record synchronization in audit trail: count pushed and pulled, remote location, direction</li>
</ul>
<p>Use Case: Periodic sync between trusted peers in a confederation.</p>
<h2>Archive Format</h2>
<h3>Cryptographic Archive Structure</h3>
<pre>
vault-1.0.0.archive          # Manifest file
vault-1.0.0.archive.tar.gz   # Actual tarball
</pre>
<p>Manifest S-expression:</p>
<pre class="language-scheme">
(sealed-archive
  (version "1.0.0")
  (format cryptographic)
  (tarball "vault-1.0.0.archive.tar.gz")
  (hash "sha512:...")
  (signature "ed25519:...")
  (timestamp 1767685100)
  (sealer #${public-key-blob}))
</pre>
<p>Verification Steps:</p>
<ul>
<li>Read manifest</li>
<li>Hash tarball with SHA-512</li>
<li>Verify hash matches manifest</li>
<li>Verify Ed25519 signature on hash</li>
<li>Check SPKI authorization (optional)</li>
</ul>
<h2>Transport Implementations</h2>
<h3>Git Remote</h3>
<ul>
<li>Uses git push to share tags</li>
<li>Optionally uploads archives as release assets (GitHub, GitLab)</li>
<li>Fetch uses git fetch + git tag -l</li>
</ul>
<h3>HTTP Endpoint</h3>
<ul>
<li>POST to /releases/&lt;version&gt; for publication</li>
<li>GET /releases for discovery</li>
<li>Content-Type: application/x-sealed-archive</li>
</ul>
<h3>Filesystem</h3>
<ul>
<li>Copy archives to shared directory</li>
<li>Directory structure: &lt;remote&gt;/&lt;archive-name&gt;</li>
<li>No network required, works with NFS, USB drives, etc.</li>
</ul>
<h2>Audit Integration</h2>
<p>Every replication operation creates an audit entry. No silent operations. No unattributed changes. See Memo-005 for the full audit trail specification.</p>
<p>Each entry contains:</p>
<ul>
<li>Content-addressed ID: SHA-512 hash of entry</li>
<li>Chained structure: References parent entry</li>
<li>SPKI principal: Public key of actor</li>
<li>Dual context: Human motivation + machine environment</li>
<li>Cryptographic seal: Ed25519 signature</li>
</ul>
<p>This provides:</p>
<ul>
<li>Non-repudiation: Cannot deny publication</li>
<li>Tamper evidence: Changes are detectable</li>
<li>Causality: Chain shows temporal order</li>
<li>Accountability: Know who published what, when, and why</li>
</ul>
<h2>Security Considerations</h2>
<h3>Threat Model</h3>
<p>Trusted:</p>
<ul>
<li>Local filesystem and vault</li>
<li>SPKI private keys (your responsibility)</li>
<li>Cryptographic primitives (libsodium, audited)</li>
</ul>
<p>Untrusted:</p>
<ul>
<li>Remote repositories (anyone can host anything)</li>
<li>Network transport (assume hostile)</li>
<li>Downloaded archives (verify before use)</li>
<li>Remote publishers (until SPKI chain verified)</li>
</ul>
<p>The key insight: trust the math, not the infrastructure. A verified signature is proof regardless of how it arrived.</p>
<h3>Attack Scenarios</h3>
<ul>
<li>Malicious Archive Substitution - Attacker replaces archive on remote - Mitigation: Signature verification fails</li>
<li>Version Rollback Attack - Attacker removes newer releases - Mitigation: Audit trail shows previous versions</li>
<li>Unauthorized Publication - Attacker publishes fake release - Mitigation: SPKI authorization chain required</li>
<li>Transport Tampering - Network attacker modifies download - Mitigation: Hash and signature verification</li>
</ul>
<p>Each attack is addressed at the cryptographic layer rather than the transport layer, ensuring protection regardless of network conditions.</p>
<h3>Best Practices</h3>
<ul>
<li>Always verify signatures - Use verify-key parameter</li>
<li>Check SPKI certificates - Verify authorization chain</li>
<li>Maintain audit trail - Detect suspicious patterns</li>
<li>Use HTTPS for HTTP transport - Prevent network attacks</li>
<li>Backup signing keys - Use Shamir secret sharing</li>
</ul>
<p>Defense in depth: cryptographic verification is primary, but transport security and operational practices add additional layers.</p>
<h2>Implementation Notes</h2>
<h3>Helper Functions</h3>
<pre class="language-scheme">
(tag-exists? tag-name)        ; Check if git tag exists
(git-remote? str)             ; Detect git remote format
(http-url? str)               ; Detect HTTP/HTTPS URL
(publish-filesystem remote version archive)  ; Copy to directory
(publish-http url version archive)           ; POST to endpoint
</pre>
<h3>Dependencies</h3>
<ul>
<li>Git: Version control and tag management</li>
<li>libsodium: Ed25519 signatures, SHA-512 hashing</li>
<li>(chicken process): Run git commands</li>
<li>(chicken file): Filesystem operations</li>
<li>(chicken irregex): URL/remote detection</li>
</ul>
<h2>Compatibility</h2>
<p>This specification builds on existing standards rather than inventing new ones:</p>
<table>
<tr><th>Technology </th><th>Role </th></tr>
<tr><td>Git tags </td><td>Standard version control operations </td></tr>
<tr><td>Git bundles </td><td>Portable repository format </td></tr>
<tr><td>Tarball archives </td><td>Universal archive format </td></tr>
<tr><td>S-expressions </td><td>LISP/Scheme readable manifests </td></tr>
<tr><td>SDSI/SPKI </td><td>Authorization certificates </td></tr>
</table>
<p>Future extensions may add:</p>
<ul>
<li>IPFS transport: Content-addressed distribution</li>
<li>Tor hidden services: Anonymous publication</li>
<li>Encrypted archives: Confidential distribution</li>
<li>Multi-signature releases: Threshold authorization</li>
</ul>
<h2>Test Coverage</h2>
<p>See test-replication.scm:</p>
<pre class="language-scheme">
;; Test seal-publish to filesystem
(seal-publish "1.0.0"
              remote: "/tmp/cyberspace-publish-test"
              message: "Published to filesystem")

;; Verify archive exists
(file-exists? "/tmp/cyberspace-publish-test/vault-1.0.0.archive")

;; Verify audit entry created
(audit-read sequence: 1)
</pre>
<h2>References</h2>
<ul>
<li>SDSI/SPKI: RFC 2693, RFC 2692</li>
<li>Content-Addressed Storage: Git internals, IPFS</li>
<li>Semantic Versioning: semver.org</li>
<li>Ed25519: Bernstein et al., 2006</li>
<li>Audit Trails: Memo-005 (Cryptographic Audit Trail)</li>
</ul>
<h2>Changelog</h2>
<p>2026-01-19 - Expanded narrative, fixed formatting</p>
<p>2026-01-05 - Initial specification: seal-publish, seal-subscribe, seal-synchronize with full audit trail integration</p>
</section>
<script>
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
}
(function() {
  // Query param override (for REPL: ?theme=dark or ?theme=light)
  const params = new URLSearchParams(window.location.search);
  const param = params.get('theme');
  if (param === 'dark' || param === 'light') {
    document.documentElement.setAttribute('data-theme', param);
    localStorage.setItem('theme', param);
    return;
  }
  // localStorage preference
  const saved = localStorage.getItem('theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
  } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script>
</body>
</html>
