<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <title>Memo 0014: Lamport Logical Clocks</title>
  <link rel="icon" id="favicon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27%230f0%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>">
  <script>
(function(){
  var h=new Date().getHours(),c;
  if(h>=4&&h<6)c='%23845EC2';       // brahma muhurta - violet
  else if(h>=6&&h<8)c='%23ffd700';  // dawn - gold
  else if(h>=8&&h<11)c='%2300d4aa'; // morning - teal
  else if(h>=11&&h<14)c='%230f0';   // midday - phosphor
  else if(h>=14&&h<17)c='%2339ff14';// afternoon - neon
  else if(h>=17&&h<19)c='%23ff6600';// sunset - orange
  else if(h>=19&&h<22)c='%23ff3366';// evening - coral
  else c='%2300ffff';               // night - cyan
  document.getElementById('favicon').href='data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27'+c+'%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>';
})();
</script>
  <link rel="stylesheet" href="memo.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<h1>Memo 0014: Lamport Logical Clocks</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This Memo specifies Lamport logical clocks for Cyberspace distributed ordering, providing a happened-before relation across federated vaults without synchronized physical clocks.</p>
</section>
<section>
<h2>Motivation</h2>
<p>Physical clocks lie:</p>
<p>- Clock skew: Machines disagree on time - Clock drift: Skew grows over time - NTP failures: Synchronization breaks - Relativity: No global "now" anyway</p>
<p>Lamport clocks provide:</p>
<p>1. Logical ordering: a → b means a happened before b 2. No synchronization: No NTP, no GPS, no trusted time 3. Causality tracking: If a caused b, then C(a) &lt; C(b) 4. Consistency: All nodes agree on partial order</p>
<p>From Lamport (1978):</p>
<blockquote>
<p>Time, Clocks, and the Ordering of Events in a Distributed System</p>
</blockquote>
</section>
<section>
<h2>Specification</h2>
<h3>The Happened-Before Relation</h3>
<p>Definition: a → b (a happened before b) if:</p>
<p>1. a and b are in same process and a comes before b, or 2. a is sending a message and b is receiving it, or 3. ∃c such that a → c and c → b (transitivity)</p>
<h3>Lamport Clock Rules</h3>
<p>Each process P maintains counter C(P):</p>
<pre>
Rule 1: Before each event, increment C(P)
         C(P) := C(P) + 1

Rule 2: When sending message m, attach C(P)
         send(m, C(P))

Rule 3: When receiving message (m, T), update clock
         C(P) := max(C(P), T) + 1
</pre>
<h3>Clock Condition</h3>
<p>If a → b then C(a) &lt; C(b).</p>
<p>Note: Converse is not guaranteed. C(a) &lt; C(b) does not imply a → b.</p>
</section>
<section>
<h2>Data Structures</h2>
<h3>Logical Timestamp</h3>
<pre class="language-scheme">
(define-record-type &lt;lamport-clock&gt;
  (make-lamport-clock counter node-id)
  lamport-clock?
  (counter clock-counter)
  (node-id clock-node-id))
</pre>
<h3>Timestamped Event</h3>
<pre class="language-scheme">
(define-record-type &lt;timestamped-event&gt;
  (make-timestamped-event clock event)
  timestamped-event?
  (clock event-clock)
  (event event-data))
</pre>
</section>
<section>
<h2>Operations</h2>
<h3>Increment (Local Event)</h3>
<pre class="language-scheme">
(define (clock-tick! clock)
  "Increment clock for local event"
  (set! (clock-counter clock)
        (+ 1 (clock-counter clock)))
  clock)
</pre>
<h3>Send (Message Departure)</h3>
<pre class="language-scheme">
(define (clock-send clock message)
  "Attach timestamp to outgoing message"
  (clock-tick! clock)
  (make-timestamped-message
    (clock-counter clock)
    (clock-node-id clock)
    message))
</pre>
<h3>Receive (Message Arrival)</h3>
<pre class="language-scheme">
(define (clock-receive! clock timestamped-message)
  "Update clock on message receipt"
  (let ((remote-time (message-timestamp timestamped-message)))
    (set! (clock-counter clock)
          (+ 1 (max (clock-counter clock) remote-time)))
    (message-payload timestamped-message)))
</pre>
</section>
<section>
<h2>Total Ordering</h2>
<p>Lamport clocks give partial order. For total order, break ties with node ID:</p>
<pre class="language-scheme">
(define (lamport-compare a b)
  "Total order: compare by timestamp, then by node-id"
  (let ((ta (clock-counter (event-clock a)))
        (tb (clock-counter (event-clock b)))
        (na (clock-node-id (event-clock a)))
        (nb (clock-node-id (event-clock b))))
    (cond
      ((&lt; ta tb) -1)
      ((&gt; ta tb) 1)
      ((string&lt;? na nb) -1)
      ((string&gt;? na nb) 1)
      (else 0))))
</pre>
</section>
<section>
<h2>Application to Cyberspace</h2>
<h3>Audit Trail Ordering</h3>
<pre class="language-scheme">
(audit-entry
  (lamport-clock 1042 "alice-vault")
  (timestamp "2026-01-06T15:30:00Z")  ; Physical (advisory)
  (action (seal-commit "abc123"))
  ...)
</pre>
<p>Logical clock provides causal ordering even if physical clocks differ.</p>
<h3>Federation Message Ordering</h3>
<pre class="language-scheme">
(federation-message
  (logical-time 573)
  (from "bob-vault")
  (type announcement)
  (payload ...))
</pre>
<p>Receivers update their clocks, ensuring consistent view of causality.</p>
<h3>Conflict Detection</h3>
<p>If events are concurrent (neither a → b nor b → a):</p>
<pre class="language-scheme">
(define (concurrent? a b)
  "True if neither event happened before the other"
  (let ((ta (clock-counter (event-clock a)))
        (tb (clock-counter (event-clock b))))
    ;; If timestamps equal and different nodes, concurrent
    ;; More sophisticated: use vector clocks for accurate detection
    (and (= ta tb)
         (not (equal? (clock-node-id (event-clock a))
                      (clock-node-id (event-clock b)))))))
</pre>
</section>
<section>
<h2>Vector Clocks (Extension)</h2>
<p>For precise concurrency detection, use vector clocks:</p>
<div class="diagram-container">
<svg class="diagram" viewBox="0 0 660 120" width="660" height="120" xmlns="http://www.w3.org/2000/svg">
<style>
  .diagram line { stroke: currentColor; stroke-width: 1.5; stroke-linecap: square; }
  .diagram rect { fill: currentColor; }
  .diagram text { font-family: monospace; font-size: 14px; fill: currentColor; text-anchor: middle; dominant-baseline: central; }
</style>
<text x="5" y="10">(</text>
<text x="15" y="10">d</text>
<text x="25" y="10">e</text>
<text x="35" y="10">f</text>
<text x="45" y="10">i</text>
<text x="55" y="10">n</text>
<text x="65" y="10">e</text>
<text x="75" y="10">-</text>
<text x="85" y="10">r</text>
<text x="95" y="10">e</text>
<text x="105" y="10">c</text>
<text x="115" y="10">o</text>
<text x="125" y="10">r</text>
<text x="135" y="10">d</text>
<text x="145" y="10">-</text>
<text x="155" y="10">t</text>
<text x="165" y="10">y</text>
<text x="175" y="10">p</text>
<text x="185" y="10">e</text>
<text x="205" y="10">&lt;</text>
<text x="215" y="10">v</text>
<text x="225" y="10">e</text>
<text x="235" y="10">c</text>
<text x="245" y="10">t</text>
<text x="255" y="10">o</text>
<text x="265" y="10">r</text>
<text x="275" y="10">-</text>
<text x="285" y="10">c</text>
<text x="295" y="10">l</text>
<text x="305" y="10">o</text>
<text x="315" y="10">c</text>
<text x="325" y="10">k</text>
<text x="335" y="10">&gt;</text>
<text x="25" y="30">(</text>
<text x="35" y="30">m</text>
<text x="45" y="30">a</text>
<text x="55" y="30">k</text>
<text x="65" y="30">e</text>
<text x="75" y="30">-</text>
<text x="85" y="30">v</text>
<text x="95" y="30">e</text>
<text x="105" y="30">c</text>
<text x="115" y="30">t</text>
<text x="125" y="30">o</text>
<text x="135" y="30">r</text>
<text x="145" y="30">-</text>
<text x="155" y="30">c</text>
<text x="165" y="30">l</text>
<text x="175" y="30">o</text>
<text x="185" y="30">c</text>
<text x="195" y="30">k</text>
<text x="215" y="30">e</text>
<text x="225" y="30">n</text>
<text x="235" y="30">t</text>
<text x="245" y="30">r</text>
<text x="255" y="30">i</text>
<text x="265" y="30">e</text>
<text x="275" y="30">s</text>
<text x="285" y="30">)</text>
<text x="25" y="50">v</text>
<text x="35" y="50">e</text>
<text x="45" y="50">c</text>
<text x="55" y="50">t</text>
<text x="65" y="50">o</text>
<text x="75" y="50">r</text>
<text x="85" y="50">-</text>
<text x="95" y="50">c</text>
<text x="105" y="50">l</text>
<text x="115" y="50">o</text>
<text x="125" y="50">c</text>
<text x="135" y="50">k</text>
<text x="145" y="50">?</text>
<text x="25" y="70">(</text>
<text x="35" y="70">e</text>
<text x="45" y="70">n</text>
<text x="55" y="70">t</text>
<text x="65" y="70">r</text>
<text x="75" y="70">i</text>
<text x="85" y="70">e</text>
<text x="95" y="70">s</text>
<text x="115" y="70">v</text>
<text x="125" y="70">c</text>
<text x="135" y="70">-</text>
<text x="145" y="70">e</text>
<text x="155" y="70">n</text>
<text x="165" y="70">t</text>
<text x="175" y="70">r</text>
<text x="185" y="70">i</text>
<text x="195" y="70">e</text>
<text x="205" y="70">s</text>
<text x="215" y="70">)</text>
<text x="225" y="70">)</text>
<text x="255" y="70">;</text>
<text x="275" y="70">H</text>
<text x="285" y="70">a</text>
<text x="295" y="70">s</text>
<text x="305" y="70">h</text>
<text x="315" y="70">:</text>
<text x="335" y="70">n</text>
<text x="345" y="70">o</text>
<text x="355" y="70">d</text>
<text x="365" y="70">e</text>
<text x="375" y="70">-</text>
<text x="385" y="70">i</text>
<text x="395" y="70">d</text>
<text x="415" y="70">→</text>
<text x="435" y="70">c</text>
<text x="445" y="70">o</text>
<text x="455" y="70">u</text>
<text x="465" y="70">n</text>
<text x="475" y="70">t</text>
<text x="485" y="70">e</text>
<text x="495" y="70">r</text>
<text x="5" y="90">;</text>
<text x="15" y="90">;</text>
<text x="35" y="90">a</text>
<text x="55" y="90">→</text>
<text x="75" y="90">b</text>
<text x="95" y="90">i</text>
<text x="105" y="90">f</text>
<text x="115" y="90">f</text>
<text x="135" y="90">V</text>
<text x="145" y="90">C</text>
<text x="155" y="90">(</text>
<text x="165" y="90">a</text>
<text x="175" y="90">)</text>
<text x="195" y="90">&lt;</text>
<text x="215" y="90">V</text>
<text x="225" y="90">C</text>
<text x="235" y="90">(</text>
<text x="245" y="90">b</text>
<text x="255" y="90">)</text>
<text x="275" y="90">(</text>
<text x="285" y="90">c</text>
<text x="295" y="90">o</text>
<text x="305" y="90">m</text>
<text x="315" y="90">p</text>
<text x="325" y="90">o</text>
<text x="335" y="90">n</text>
<text x="345" y="90">e</text>
<text x="355" y="90">n</text>
<text x="365" y="90">t</text>
<text x="375" y="90">-</text>
<text x="385" y="90">w</text>
<text x="395" y="90">i</text>
<text x="405" y="90">s</text>
<text x="415" y="90">e</text>
<text x="425" y="90">)</text>
<text x="5" y="110">;</text>
<text x="15" y="110">;</text>
<text x="35" y="110">a</text>
<text x="55" y="110">|</text>
<text x="65" y="110">|</text>
<text x="85" y="110">b</text>
<text x="105" y="110">(</text>
<text x="115" y="110">c</text>
<text x="125" y="110">o</text>
<text x="135" y="110">n</text>
<text x="145" y="110">c</text>
<text x="155" y="110">u</text>
<text x="165" y="110">r</text>
<text x="175" y="110">r</text>
<text x="185" y="110">e</text>
<text x="195" y="110">n</text>
<text x="205" y="110">t</text>
<text x="215" y="110">)</text>
<text x="235" y="110">i</text>
<text x="245" y="110">f</text>
<text x="255" y="110">f</text>
<text x="275" y="110">n</text>
<text x="285" y="110">e</text>
<text x="295" y="110">i</text>
<text x="305" y="110">t</text>
<text x="315" y="110">h</text>
<text x="325" y="110">e</text>
<text x="335" y="110">r</text>
<text x="355" y="110">V</text>
<text x="365" y="110">C</text>
<text x="375" y="110">(</text>
<text x="385" y="110">a</text>
<text x="395" y="110">)</text>
<text x="415" y="110">&lt;</text>
<text x="435" y="110">V</text>
<text x="445" y="110">C</text>
<text x="455" y="110">(</text>
<text x="465" y="110">b</text>
<text x="475" y="110">)</text>
<text x="495" y="110">n</text>
<text x="505" y="110">o</text>
<text x="515" y="110">r</text>
<text x="535" y="110">V</text>
<text x="545" y="110">C</text>
<text x="555" y="110">(</text>
<text x="565" y="110">b</text>
<text x="575" y="110">)</text>
<text x="595" y="110">&lt;</text>
<text x="615" y="110">V</text>
<text x="625" y="110">C</text>
<text x="635" y="110">(</text>
<text x="645" y="110">a</text>
<text x="655" y="110">)</text>
</svg>
</div>
<p>Trade-off: O(N) space vs O(1) for Lamport clocks.</p>
</section>
<section>
<h2>Integration Points</h2>
<h3>With Audit Trail (Memo-003)</h3>
<pre class="language-scheme">
(audit-entry
  (sequence 42)           ; Local sequence
  (lamport-clock 1042)    ; Logical timestamp
  (physical-time "...")   ; Advisory only
  ...)
</pre>
<h3>With Consensus (Memo-011)</h3>
<pre class="language-scheme">
(consensus-message
  (sequence 573)          ; Consensus sequence
  (lamport-clock 2891)    ; Causal context
  ...)
</pre>
<h3>With Replication (Memo-0002)</h3>
<pre class="language-scheme">
(seal-publish "2.0.0"
  (logical-time 892)
  ...)
</pre>
</section>
<section>
<h2>Security Considerations</h2>
<h3>Clock Manipulation</h3>
<p>A Byzantine node could: - Report artificially high clock values - Attempt to order events incorrectly</p>
<p>Mitigations: - Clock values bounded by received values + margin - Signatures prevent retroactive tampering - Audit trails detect anomalies</p>
<h3>Denial of Service</h3>
<p>Flooding with high-timestamped messages forces clock advancement.</p>
<p>Mitigation: Rate limiting, reputation systems.</p>
</section>
<section>
<h2>Implementation Notes</h2>
<h3>Thread Safety</h3>
<p>Clock updates must be atomic:</p>
<pre class="language-scheme">
(define (atomic-tick! clock)
  (mutex-lock! clock-mutex)
  (clock-tick! clock)
  (mutex-unlock! clock-mutex))
</pre>
<h3>Persistence</h3>
<p>Clock state survives restarts:</p>
<pre class="language-scheme">
(define (save-clock clock path)
  (with-output-to-file path
    (lambda ()
      (write `(lamport-clock
                (counter ,(clock-counter clock))
                (node-id ,(clock-node-id clock)))))))
</pre>
</section>
<section>
<h2>References</h2>
<p>1. Lamport, L. (1978). Time, Clocks, and the Ordering of Events in a Distributed System. 2. Fidge, C. J. (1988). Timestamps in Message-Passing Systems. 3. Mattern, F. (1989). Virtual Time and Global States of Distributed Systems. 4. Memo-003: Cryptographic Audit Trail 5. Memo-010: Federation Protocol</p>
</section>
<section>
<h2>Changelog</h2>
<ul>
<li>2026-01-06</li>
<li>Initial specification</li>
</ul>
</section>
<script>
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
}
(function() {
  // Query param override (for REPL: ?theme=dark or ?theme=light)
  const params = new URLSearchParams(window.location.search);
  const param = params.get('theme');
  if (param === 'dark' || param === 'light') {
    document.documentElement.setAttribute('data-theme', param);
    localStorage.setItem('theme', param);
    return;
  }
  // localStorage preference
  const saved = localStorage.getItem('theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
  } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script>
</body>
</html>
