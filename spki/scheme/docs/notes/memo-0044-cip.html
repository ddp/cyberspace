<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <title>Memo 0044: Cryptographic Imprint Protocol (CIP)</title>
  <link rel="icon" id="favicon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27%230f0%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>">
  <script>
(function(){
  var h=new Date().getHours(),c;
  if(h>=4&&h<6)c='%23845EC2';       // brahma muhurta - violet
  else if(h>=6&&h<8)c='%23ffd700';  // dawn - gold
  else if(h>=8&&h<11)c='%2300d4aa'; // morning - teal
  else if(h>=11&&h<14)c='%230f0';   // midday - phosphor
  else if(h>=14&&h<17)c='%2339ff14';// afternoon - neon
  else if(h>=17&&h<19)c='%23ff6600';// sunset - orange
  else if(h>=19&&h<22)c='%23ff3366';// evening - coral
  else c='%2300ffff';               // night - cyan
  document.getElementById('favicon').href='data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27'+c+'%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>';
})();
</script>
  <link rel="stylesheet" href="memo.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<h1>Memo 0044: Cryptographic Imprint Protocol (CIP)</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>CIP establishes secure channels between Cyberspace nodes using stateless cookies for DoS resistance, ephemeral key exchange for forward secrecy, and capability attestation for authorization. Each imprint is an authoritative affirmation of trust - signed and sealed by the issuing principal in their realm. No X.509. No CA hierarchy. No algorithm negotiation.</p>
</section>
<section>
<h2>Motivation</h2>
<p>TLS is complex: - Certificate chains require PKI - Algorithm negotiation invites downgrade attacks - State allocated before client proven real - Identity exposed before encryption</p>
<p>PHOTURIS (1995) had better ideas: - Cookies before crypto - Identity under encryption - Simple state machine</p>
<p>CIP resurrects these ideas with modern primitives.</p>
</section>
<section>
<h2>Protocol Overview</h2>
<pre>
Initiator                          Responder
    |                                   |
    |-------- KNOCK (version) --------&gt;|  Stateless
    |&lt;-------- COOKIE -----------------|  Stateless
    |                                   |
    |-------- EXCHANGE (eph key) -----&gt;|  State committed
    |&lt;------- EXCHANGE (eph key) ------|
    |                                   |
    |========= encrypted below ========|
    |                                   |
    |-------- ATTEST (identity) ------&gt;|
    |&lt;------- ATTEST (identity) -------|
    |                                   |
    |-------- OFFER (capabilities) ---&gt;|
    |&lt;------- OFFER (capabilities) ----|
    |                                   |
    |-------- CONFIRM (transcript) ---&gt;|
    |&lt;------- CONFIRM (transcript) ----|
    |                                   |
    |========= CHANNEL OPEN ===========|
    |                                   |
    |&lt;----------- DATA --------------&gt;|
</pre>
<p>10 messages to establish. Unlimited encrypted DATA after.</p>
</section>
<section>
<h2>Message Format</h2>
<p>All messages use TLV encoding:</p>
<pre>
+------+--------+------------------+
| Type | Length | Payload          |
| 1B   | 4B BE  | variable         |
+------+--------+------------------+
</pre>
<h3>Message Types</h3>
<table>
<tr><th>Type </th><th>Name </th><th>Direction </th></tr>
<tr><td>0x01 </td><td>KNOCK </td><td>I → R </td></tr>
<tr><td>0x02 </td><td>COOKIE </td><td>R → I </td></tr>
<tr><td>0x03 </td><td>EXCHANGE </td><td>bidirectional </td></tr>
<tr><td>0x04 </td><td>ATTEST </td><td>bidirectional </td></tr>
<tr><td>0x05 </td><td>OFFER </td><td>bidirectional </td></tr>
<tr><td>0x06 </td><td>CONFIRM </td><td>bidirectional </td></tr>
<tr><td>0x10 </td><td>DATA </td><td>bidirectional </td></tr>
<tr><td>0xFF </td><td>CLOSE </td><td>bidirectional </td></tr>
</table>
</section>
<section>
<h2>Phase 1: KNOCK</h2>
<p>Initiator announces intent and protocol version.</p>
<pre>
KNOCK payload:
  "CIP/" VERSIONMAJOR "." VERSIONMINOR

Example: "CIP/1.0"
</pre>
<p>Responder checks version compatibility: - Major mismatch: reject (incompatible suites) - Minor mismatch: accept (backward compatible)</p>
<p>Responder allocates no state.</p>
</section>
<section>
<h2>Phase 2: COOKIE</h2>
<p>Responder returns stateless cookie.</p>
<pre class="language-scheme">
(define (make-cookie remote-addr remote-port)
  (let ((data (string-append
                (blob-&gt;string cookie-secret)
                remote-addr
                (number-&gt;string remote-port)
                (number-&gt;string cookie-epoch*)))
         (hash (blake2b-hash (string-&gt;blob data))))
    (substring hash 0 16)))
</pre>
<p>Cookie properties: - Stateless: Responder doesn't store it - Unforgeable: Requires server secret - Expiring: Epoch rotation invalidates old cookies - Address-bound: Different address = different cookie</p>
<p>Responder still allocates no state.</p>
</section>
<section>
<h2>Phase 3: EXCHANGE</h2>
<p>Both parties exchange ephemeral public keys.</p>
<p>Initiator sends:</p>
<pre>
EXCHANGE payload:
  cookie-r "|" cookie-i "|" ephemeral-public-hex
</pre>
<p>- cookie-r: Echo of responder's cookie (proves receipt) - cookie-i: Initiator's random cookie (for key derivation) - ephemeral-public: X25519 public key</p>
<p>Responder verifies cookie echo, then responds with same format.</p>
<p>State now committed. Keys derived.</p>
<h3>Key Derivation</h3>
<pre class="language-scheme">
(define (derive-session-keys shared-secret cookie-i cookie-r)
  (let* ((ikm (blob-append shared-secret
                           (string-&gt;blob cookie-i)
                           (string-&gt;blob cookie-r)))
         (prk (blake2b-hash ikm))
         (k-ir (blake2b-hash (blob-append prk "initiator-&gt;responder")))
         (k-ri (blake2b-hash (blob-append prk "responder-&gt;initiator"))))
    (values (take k-ir 32) (take k-ri 32))))
</pre>
<p>Directional keys prevent reflection attacks.</p>
</section>
<section>
<h2>Phase 4: ATTEST</h2>
<p>All subsequent messages encrypted.</p>
<p>Both parties prove identity using SPKI principals.</p>
<pre>
ATTEST payload (encrypted):
  principal-hash "|" signature
</pre>
<p>- principal-hash: SPKI principal (hex-encoded public key hash) - signature: Ed25519 signature over transcript</p>
<p>Identity is cryptographic, not nominal. A principal is identified solely by its public key hash, never by a human-readable name. This is a prime directive.</p>
<p>The attestation is the principal's authoritative affirmation of their own trust: I vouch for this channel. This is not a bearer token - it is my sealed declaration, bound to my realm.</p>
<p>Transcript for signing:</p>
<pre>
cookie-i || cookie-r || ephemeral-public
</pre>
<h3>Anonymous Attestation (Optional)</h3>
<p>For privacy, use Chaum-style blind signatures:</p>
<pre class="language-scheme">
(define (blind-attest capability-hash)
  ;; Prove authorization without revealing identity
  (blind-sign capability-hash (blind-factor)))
</pre>
</section>
<section>
<h2>Phase 5: OFFER</h2>
<p>Exchange authorized capabilities as SPKI tags.</p>
<pre>
OFFER payload (encrypted):
  (tag ( set capability ...))

Example: "(tag ( set read write replicate))"
</pre>
<p>Capabilities follow Memo-021 (Capability Delegation): - Only offer what you hold - Attenuation only, no amplification - Explicit, not ambient - Expressed as SPKI tag s-expressions</p>
<p>Future: Full SPKI auth-certs with issuer signatures.</p>
</section>
<section>
<h2>Phase 6: CONFIRM</h2>
<p>Bind entire transcript.</p>
<pre>
CONFIRM payload (encrypted):
  BLAKE2b(cookie-i || cookie-r || their-principal)
</pre>
<p>Both parties must produce matching hashes. Any tampering detected.</p>
</section>
<section>
<h2>DATA Phase</h2>
<p>Channel open. Encrypted messaging.</p>
<pre>
DATA payload:
  ChaCha20-Poly1305(key, nonce, plaintext)
</pre>
<p>Nonce construction:</p>
<pre>
nonce = sequence-number (8 bytes) || 0x00000000 (4 bytes)
</pre>
<p>Sequence numbers: - Start at 0 - Increment per message - Prevent replay - Separate counters per direction</p>
</section>
<section>
<h2>Algorithm Suites</h2>
<p>No runtime negotiation. Version determines suite.</p>
<h3>CIP/1.x (Current)</h3>
<table>
<tr><th>Function </th><th>Algorithm </th></tr>
<tr><td>Key Exchange </td><td>X25519 </td></tr>
<tr><td>Signatures </td><td>Ed25519 </td></tr>
<tr><td>AEAD </td><td>ChaCha20-Poly1305 </td></tr>
<tr><td>Hash </td><td>BLAKE2b </td></tr>
<tr><td>KDF </td><td>HKDF-BLAKE2b </td></tr>
</table>
<h3>CIP/2.x (Reserved: Post-Quantum)</h3>
<table>
<tr><th>Function </th><th>Algorithm </th></tr>
<tr><td>Key Exchange </td><td>Kyber-1024 </td></tr>
<tr><td>Signatures </td><td>Dilithium3 </td></tr>
<tr><td>AEAD </td><td>ChaCha20-Poly1305 </td></tr>
<tr><td>Hash </td><td>BLAKE2b </td></tr>
</table>
<h3>CIP/3.x (Reserved: Hybrid)</h3>
<table>
<tr><th>Function </th><th>Algorithm </th></tr>
<tr><td>Key Exchange </td><td>X25519 + Kyber </td></tr>
<tr><td>Signatures </td><td>Ed25519 + Dilithium </td></tr>
</table>
</section>
<section>
<h2>Security Properties</h2>
<h3>DoS Resistance</h3>
<table>
<tr><th>Attack </th><th>Defense </th></tr>
<tr><td>SYN flood </td><td>Cookie proves return path </td></tr>
<tr><td>Amplification </td><td>No response until cookie echo </td></tr>
<tr><td>State exhaustion </td><td>No state until Phase 3 </td></tr>
</table>
<h3>Forward Secrecy</h3>
<p>Ephemeral X25519 keys: - Generated per session - Destroyed after key derivation - Compromise of long-term key doesn't expose past sessions</p>
<h3>Identity Protection (SPKI Native)</h3>
<p>Principal identity: - Is the public key hash (not a name, not a certificate) - Only revealed after encryption established - Only revealed to authenticated peer - Never in plaintext on wire - Self-certifying: principal = hash(public_key)</p>
<h3>Replay Protection</h3>
<ul>
<li>Sequence numbers per direction</li>
<li>Nonce never reused (fatal if violated)</li>
<li>AEAD authentication fails on replay</li>
</ul>
</section>
<section>
<h2>Comparison</h2>
<table>
<tr><th>Property </th><th>TLS 1.3 </th><th>IKEv2 </th><th>CIP </th></tr>
<tr><td>Messages to establish </td><td>2-3 </td><td>4+ </td><td>10 </td></tr>
<tr><td>DoS resistance </td><td>Limited </td><td>Cookies </td><td>Cookies </td></tr>
<tr><td>Algorithm negotiation </td><td>Yes </td><td>Yes </td><td>No </td></tr>
<tr><td>Certificate required </td><td>Yes </td><td>Yes </td><td>No </td></tr>
<tr><td>Identity protection </td><td>Partial </td><td>Yes </td><td>Yes </td></tr>
<tr><td>Capability binding </td><td>No </td><td>No </td><td>Yes </td></tr>
</table>
<p>CIP trades fewer round-trips for simplicity and capability integration.</p>
</section>
<section>
<h2>Implementation</h2>
<pre class="language-scheme">
;; Initiator
(define ch (node-connect "remote.host" 4433))
(channel-send ch '(request object-hash))
(channel-recv ch)

;; Responder
(node-listen 4433 "my-node")
(define ch (node-accept))
(let ((msg (channel-recv ch)))
  (channel-send ch (process msg)))
</pre>
</section>
<section>
<h2>References</h2>
<p>1. Karn, P. &amp; Simpson, W. (1999). PHOTURIS. RFC 2522. 2. Karn, P. &amp; Simpson, W. (1999). PHOTURIS Extended Schemes. RFC 2523. 3. Bernstein, D.J. (2006). Curve25519. 4. Bernstein, D.J. (2008). ChaCha20. 5. Memo-021: Capability Delegation 6. Memo-040: Security Architecture</p>
</section>
<section>
<h2>Changelog</h2>
<p>- 2026-01-07: Initial specification</p>
</section>
<script>
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
}
(function() {
  // Query param override (for REPL: ?theme=dark or ?theme=light)
  const params = new URLSearchParams(window.location.search);
  const param = params.get('theme');
  if (param === 'dark' || param === 'light') {
    document.documentElement.setAttribute('data-theme', param);
    localStorage.setItem('theme', param);
    return;
  }
  // localStorage preference
  const saved = localStorage.getItem('theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
  } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script>
</body>
</html>
