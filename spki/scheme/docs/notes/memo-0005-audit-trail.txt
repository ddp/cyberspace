Memo 0005: Audit Trail


------------------------------------------------------------------------

------------------------------------------------------------------------
ABSTRACT
------------------------------------------------------------------------

This Memo specifies the cryptographic audit trail system for the Library
of Cyberspace, providing tamper-evident, hash-chained logging with
Simple Public Key Infrastructure (SPKI) principal attribution and
Ed25519 signatures.


------------------------------------------------------------------------
MOTIVATION
------------------------------------------------------------------------


    "The first principle is that you must not fool yourself—and you are the easiest person to fool. — Richard Feynman"

Distributed systems require accountability. Who did what, when, and
under whose authority? Without cryptographic audit trails, the answer is
always "we think so" rather than "we can prove it."

Every security breach postmortem asks the same questions: What happened?
When? Who had access? Could the logs have been tampered with?
Traditional logging cannot answer these questions with certainty.
Cyberspace audit trails can.


Heritage
--------

Inspired by VMS cluster-wide audit (1993). See Memo-0009 section 7.7 for
design heritage.


The Problem
-----------

Traditional logging fails on all counts:

  * Tamperable: Text files can be edited after the fact
  * Anonymous: No cryptographic identity binds actor to action
  * Disconnected: No provable ordering between entries
  * Unverifiable: No mathematical proof of integrity

Cyberspace audit trails provide:

  * Content-addressed entries - Tamper-evident by hash
  * Hash-chained structure - Append-only ordering
  * SPKI attribution - Cryptographic actor identity
  * Ed25519 seals - Mathematical proof of authenticity
  * Dual context - Human-readable motivation + machine-parseable environment


------------------------------------------------------------------------
SPECIFICATION
------------------------------------------------------------------------


Entry Structure
---------------


    (audit-entry
      (id "sha512:b14471cd57ea557f...")
      (timestamp "2026-01-05 23:38:20Z")
      (sequence 1)
      (parent-id "sha512:previous...")
      (actor
        (principal #${public-key-blob})
        (authorization-chain))
      (action
        (verb seal-publish)
        (object "1.0.0")
        (parameters "/path/to/remote"))
      (context
        (motivation "Published to filesystem")
        (language "en"))
      (environment
        (platform "darwin")
        (timestamp 1767685100))
      (seal
        (algorithm "ed25519-sha512")
        (content-hash "...")
        (signature "...")))


Core Fields
-----------


  Field         Type         Description                                            
  id            string       Content-addressed hash (SHA-512, first 32 hex chars)   
  timestamp     string       ISO 8601 UTC (YYYY-MM-DD HH:MM:SSZ)                    
  sequence      integer      Monotonic counter within audit trail                   
  parent-id     string/nil   ID of previous entry (hash chain)                      
  actor         record       SPKI principal who performed action                    
  action        record       What was done (verb, object, parameters)               
  context       record       Human-readable motivation                              
  environment   alist        Machine environment snapshot                           
  seal          record       Cryptographic signature                                


Actor Record
------------

Every action has an actor. Not a username—a cryptographic identity
that can be verified mathematically.


    (define-record-type <audit-actor>
      (make-audit-actor principal authorization-chain)
      audit-actor?
      (principal actor-principal)              ; Public key blob
      (authorization-chain actor-authorization-chain))  ; SPKI cert chain

The actor is identified by:

  * Principal: Ed25519 public key (32 bytes) - unforgeable identity
  * Authorization chain: Optional SPKI certificate chain proving delegation

The authorization chain answers "under whose authority?" - crucial for
auditing delegated actions.


Action Record
-------------

Actions are structured as verb-object-parameters, mirroring natural
language: "Alice committed version 1.0 to the vault."


    (define-record-type <audit-action>
      (make-audit-action verb object parameters)
      audit-action?
      (verb action-verb)        ; Symbol: seal-commit, seal-publish, etc.
      (object action-object)    ; Primary target
      (parameters action-parameters))  ; Additional arguments

Standard verbs:


  Verb               Meaning                                 
  seal-commit        Version control commit to local vault   
  seal-publish       Release publication to remote           
  seal-subscribe     Subscription to remote feed             
  seal-synchronize   Bidirectional sync with peer            
  seal-release       Version tagging for distribution        


Context Record
--------------

Machines record what happened. Humans need to know why. The context
record captures motivation in natural language—the commit message, the
reason for the release, the justification for the access.


    (define-record-type <audit-context>
      (make-audit-context motivation relates-to language)
      audit-context?
      (motivation context-motivation)    ; Human explanation
      (relates-to context-relates-to)    ; Related entries
      (language context-language))       ; ISO 639-1 code

Context provides:

  * Motivation: Why the action was taken, in the actor's own words
  * Relates-to: Cross-references to related audit entries
  * Language: ISO 639-1 code for internationalization

Six months later, "Fixed the bug" means nothing. "Fixed CVE-2026-1234
buffer overflow in certificate parser" means everything.


Seal Record
-----------


    (define-record-type <audit-seal>
      (make-audit-seal algorithm content-hash signature)
      audit-seal?
      (algorithm seal-algorithm)        ; "ed25519-sha512"
      (content-hash seal-content-hash)  ; SHA-512 of unsealed entry
      (signature seal-signature))       ; Ed25519 signature


------------------------------------------------------------------------
OPERATIONS
------------------------------------------------------------------------


audit-init
----------

Initialize audit trail for a vault.


    (audit-init signing-key: key audit-dir: ".vault/audit")


audit-append
------------

Create and sign a new audit entry.


    (audit-append
      actor: public-key-blob
      action: '(seal-commit "hash123")
      motivation: "Added new feature"
      signing-key: private-key-blob)

Process:

  * Increment sequence counter
  * Get parent entry ID (hash chain link)
  * Build unsealed entry structure
  * Compute SHA-512 hash of canonical S-expression
  * Sign hash with Ed25519
  * Create seal record
  * Save entry to disk


audit-verify
------------

Verify cryptographic seal on an entry.


    (audit-verify entry public-key: key)

Verification steps:

  * Reconstruct unsealed entry
  * Compute SHA-512 hash
  * Compare with stored content-hash
  * Verify Ed25519 signature


audit-chain
-----------

Verify the entire audit chain from genesis to present. One broken link
invalidates everything after it.


    (audit-chain verify-key: public-key)

Verifies:

  * Each entry's signature is valid
  * Parent-id references form unbroken chain
  * Sequence numbers are strictly monotonic

A valid chain proves no entries were inserted, deleted, or modified
after signing.


audit-read
----------

Read specific audit entry.


    (audit-read sequence: 42)
    (audit-read id: "sha512:...")


------------------------------------------------------------------------
STORAGE FORMAT
------------------------------------------------------------------------

Simplicity over cleverness. Entries are individual S-expression files,
one per action, named by sequence number.


    .vault/audit/
      1.sexp
      2.sexp
      3.sexp
      ...

This format trades storage density for operational simplicity:

  * Sequential reads: cat the files in order
  * Range queries: list files between N and M
  * Latest entry: highest-numbered file
  * Debugging: read any entry with a text editor

No database. No binary format. No special tools required to inspect the
audit trail.


------------------------------------------------------------------------
SECURITY CONSIDERATIONS
------------------------------------------------------------------------


Threat Model
------------

We trust as little as possible.

Trusted:

  * Local filesystem during operation (not after)
  * Ed25519 implementation (libsodium, audited)
  * Private keys (your responsibility)

Untrusted:

  * Storage medium after entry creation
  * Network transport between nodes
  * Other actors, including administrators

This threat model assumes a hostile environment where storage can be
tampered with and network traffic can be intercepted. The cryptography
protects the audit trail even when everything else is compromised.


Attack Mitigations
------------------


  Attack                Mitigation                           
  Entry modification    SHA-512 hash detects tampering       
  Entry deletion        Chain breaks are detectable          
  Entry insertion       Hash chain prevents backdating       
  Actor impersonation   Ed25519 signatures verify identity   
  Replay attacks        Sequence numbers detect duplicates   


Non-Repudiation
---------------

Once an entry is signed and published, the actor cannot credibly deny
it. This is non-repudiation: mathematical proof of authorship.

  * Actor cannot deny performing the action—their key signed it
  * Timestamp cannot be backdated—hash chain enforces ordering
  * Content cannot be altered—hash would change
  * Signature mathematically proves authorship—no "someone else used my account"

In court, in audits, in incident response: cryptographic proof beats
testimony.


------------------------------------------------------------------------
INTEGRATION POINTS
------------------------------------------------------------------------


Vault Operations
----------------

All vault operations record audit entries:


    (seal-commit "message")     > (action (verb seal-commit) ...)
    (seal-publish "1.0.0" ...)  > (action (verb seal-publish) ...)
    (seal-subscribe remote ...) > (action (verb seal-subscribe) ...)


SPKI Authorization
------------------

Audit entries can include authorization chains:


    (actor
      (principal #${bob-public-key})
      (authorization-chain
        (signed-cert ...)   ; Alice delegated to Bob
        (signed-cert ...))) ; Root delegated to Alice

This proves not just who acted, but under whose authority.


------------------------------------------------------------------------
EXPORT FORMATS
------------------------------------------------------------------------


S-expression Export
-------------------


    (audit-export-sexp output: "audit-export.sexp")

Produces:


    (audit-trail
      (audit-entry ...)
      (audit-entry ...)
      ...)


Human-readable Export
---------------------


    (audit-export-human output: "audit-export.txt")

Produces:


    AUDIT TRAIL - Library of Cyberspace
    ===================================
    Entry #1
      ID: sha512:b14471cd57ea557f...
      Time: 2026-01-05 23:38:20Z
      Action: seal-publish
      Why: Published release to filesystem
    Entry #2
      ...


------------------------------------------------------------------------
IMPLEMENTATION NOTES
------------------------------------------------------------------------


Dependencies
------------

  * crypto-ffi: Ed25519 signatures, SHA-512 hashing
  * srfi-1: List utilities
  * srfi-4: u8vectors for binary data
  * srfi-13: String utilities


Performance Considerations
--------------------------

  * Content-addressed IDs enable O(1) lookup by hash
  * Sequential file naming enables efficient range queries
  * Lazy verification: verify on read, not on load


------------------------------------------------------------------------
REFERENCES
------------------------------------------------------------------------

  * Haber, S., & Stornetta, W. S. (1991). How to time-stamp a digital document.
  * Merkle, R. C. (1987). A digital signature based on a conventional encryption function.
  * Bernstein, D. J. (2006). Curve25519: new Diffie-Hellman speed records.
  * SDSI/SPKI - RFC 2693, RFC 2692


------------------------------------------------------------------------
CHANGELOG
------------------------------------------------------------------------

2026-01-19 - Expanded narrative and rationale

2026-01-06 - Initial specification

------------------------------------------------------------------------
