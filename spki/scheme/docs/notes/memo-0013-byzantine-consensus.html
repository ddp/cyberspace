<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <title>Memo 0013: Byzantine Consensus</title>
  <link rel="icon" id="favicon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27%230f0%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>">
  <script>
(function(){
  var h=new Date().getHours(),c;
  if(h>=4&&h<6)c='%23845EC2';       // brahma muhurta - violet
  else if(h>=6&&h<8)c='%23ffd700';  // dawn - gold
  else if(h>=8&&h<11)c='%2300d4aa'; // morning - teal
  else if(h>=11&&h<14)c='%230f0';   // midday - phosphor
  else if(h>=14&&h<17)c='%2339ff14';// afternoon - neon
  else if(h>=17&&h<19)c='%23ff6600';// sunset - orange
  else if(h>=19&&h<22)c='%23ff3366';// evening - coral
  else c='%2300ffff';               // night - cyan
  document.getElementById('favicon').href='data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27'+c+'%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>';
})();
</script>
  <link rel="stylesheet" href="memo.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<p class="format-notice"><em>For pixel-perfect diagrams: <a href="memo-0013-byzantine-consensus.ps">PostScript</a> or <a href="memo-0013-byzantine-consensus.pdf">PDF</a></em></p>
<h1>Memo 0013: Byzantine Consensus</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This Memo specifies Byzantine fault-tolerant consensus for Cyberspace federation, enabling agreement among distributed vaults even when some participants are faulty or malicious. N nodes tolerate up to f failures where N ≥ 3f + 1.</p>
</section>
<section>
<h2>Motivation</h2>
<p>Federation (Memo-010) assumes honest peers. Reality differs:</p>
<ul>
<li>Crash failures: Nodes go offline</li>
<li>Byzantine failures: Nodes lie, equivocate, or attack</li>
<li>Network partitions: Messages delayed or lost</li>
<li>Sybil attacks: Fake identities flood the network</li>
</ul>
<p>These failure modes require protocols that assume the worst about participants rather than hoping for the best.</p>
<p>Byzantine consensus provides:</p>
<ul>
<li>Safety: Honest nodes agree on same value</li>
<li>Liveness: System makes progress despite failures</li>
<li>Fault tolerance: Survives f failures with 3f+1 nodes</li>
</ul>
<p>The 3f+1 bound is fundamental: fewer nodes cannot distinguish a slow honest node from a fast malicious one.</p>
<p>From Lamport, Shostak, and Pease (1982):</p>
<blockquote>
<p>The Byzantine Generals Problem: reaching agreement in the presence of traitors.</p>
</blockquote>
</section>
<section>
<h2>Specification</h2>
<h3>System Model</h3>
<pre>
Nodes:        N = 3f + 1 (tolerates f Byzantine faults)
Network:      Asynchronous with eventual delivery
Cryptography: Ed25519 signatures (authenticated channels)
</pre>
<h3>Consensus Properties</h3>
<p>Agreement: If honest node i decides v, honest node j decides v.</p>
<p>Validity: If all honest nodes propose v, decision is v.</p>
<p>Termination: All honest nodes eventually decide.</p>
<h3>Protocol: Practical Byzantine Fault Tolerance (PBFT)</h3>
<pre class="diagram">
Phase 1: PRE-PREPARE
  Primary broadcasts ⟨PRE-PREPARE, v, n, sig⟩

Phase 2: PREPARE
  On valid PRE-PREPARE, broadcast ⟨PREPARE, v, n, sig⟩
  Collect 2f PREPARE messages

Phase 3: COMMIT
  On 2f+1 PREPARE, broadcast ⟨COMMIT, v, n, sig⟩
  Collect 2f+1 COMMIT messages

Decision:
  On 2f+1 COMMIT, decide v
</pre>
<h3>Message Formats</h3>
<pre class="language-scheme">
(consensus-message
  (type pre-prepare)
  (view 0)
  (sequence 42)
  (value-hash "sha512:...")
  (from #${primary-pubkey})
  (signature #${ed25519-sig}))

(consensus-message
  (type prepare)
  (view 0)
  (sequence 42)
  (value-hash "sha512:...")
  (from #${replica-pubkey})
  (signature #${ed25519-sig}))

(consensus-message
  (type commit)
  (view 0)
  (sequence 42)
  (from #${replica-pubkey})
  (signature #${ed25519-sig}))
</pre>
</section>
<section>
<h2>View Change</h2>
<p>When primary fails or is Byzantine:</p>
<pre class="diagram">
1. Replica timeout on PRE-PREPARE
2. Broadcast ⟨VIEW-CHANGE, v+1, prepared-proofs⟩
3. New primary collects 2f+1 VIEW-CHANGE
4. New primary broadcasts ⟨NEW-VIEW, v+1, proofs⟩
5. Resume protocol in new view
</pre>
</section>
<section>
<h2>Application to Cyberspace</h2>
<h3>Federation Ordering</h3>
<pre class="language-scheme">
(consensus-propose
  (action release-publish)
  (version "2.0.0")
  (proposer #${alice-key}))

;; After consensus:
(consensus-decided
  (sequence 42)
  (action release-publish)
  (version "2.0.0")
  (decided-by (quorum ...)))
</pre>
<h3>Threshold Governance Integration</h3>
<p>Combine with Memo-008: - Consensus on what to do - Threshold signatures on authorization</p>
<pre class="language-scheme">
(governance-decision
  (consensus-sequence 42)
  (action deploy-production)
  (threshold-met 3-of-5)
  (signers (alice carol dave)))
</pre>
</section>
<section>
<h2>Optimizations</h2>
<h3>Speculation</h3>
<p>Execute optimistically before commit:</p>
<pre>
Tentative execution after 2f+1 PREPARE
Rollback if COMMIT fails
</pre>
<h3>Batching</h3>
<p>Amortize consensus over multiple operations:</p>
<pre>
(consensus-batch
  (sequence 42)
  (operations
    (release-publish "2.0.0")
    (release-publish "2.0.1")
    (config-update ...)))
</pre>
<h3>Fast Path</h3>
<p>When all replicas agree initially:</p>
<pre>
Skip PREPARE phase
Direct to COMMIT with 3f+1 matching responses
</pre>
</section>
<section>
<h2>Security Considerations</h2>
<h3>Threat Model</h3>
<p>Tolerates: - f Byzantine nodes (arbitrary behavior) - Network delays and reordering - Message loss (with retransmission)</p>
<p>Requires: - N ≥ 3f + 1 total nodes - Authenticated channels (signatures) - Eventual message delivery</p>
<h3>Attack Resistance</h3>
<table>
<tr><th>Attack </th><th>Mitigation </th></tr>
<tr><td>Equivocation </td><td>Signatures prove inconsistency </td></tr>
<tr><td>Replay </td><td>Sequence numbers, view numbers </td></tr>
<tr><td>Denial of service </td><td>View change, rate limiting </td></tr>
<tr><td>Sybil </td><td>SPKI admission control </td></tr>
</table>
</section>
<section>
<h2>Complexity</h2>
<table>
<tr><th>Metric </th><th>Value </th></tr>
<tr><td>Message complexity </td><td>O(N²) per decision </td></tr>
<tr><td>Communication rounds </td><td>3 (normal case) </td></tr>
<tr><td>Cryptographic operations </td><td>O(N) signatures/verifies </td></tr>
</table>
</section>
<section>
<h2>Implementation Notes</h2>
<h3>State Machine</h3>
<pre class="diagram">
(define-record-type &lt;pbft-state&gt;
  (make-pbft-state view sequence log prepared committed)
  pbft-state?
  (view pbft-view)
  (sequence pbft-sequence)
  (log pbft-log)              ; sequence → messages
  (prepared pbft-prepared)    ; sequence → value
  (committed pbft-committed)) ; sequence → value
</pre>
<h3>Dependencies</h3>
<ul>
<li>crypto-ffi</li>
<li>Ed25519 signatures - audit</li>
<li>Decision logging</li>
<li>Network transport (TCP, QUIC)</li>
</ul>
</section>
<section>
<h2>References</h2>
<ul>
<li>Lamport, L., Shostak, R., &amp; Pease, M. (1982). The Byzantine Generals Problem.</li>
<li>Castro, M., &amp; Liskov, B. (1999). Practical Byzantine Fault Tolerance.</li>
<li>Yin, M., et al. (2019). HotStuff: BFT Consensus with Linearity and Responsiveness.</li>
<li>Memo-008: Threshold Signature Governance</li>
<li>Memo-010: Federation Protocol</li>
</ul>
</section>
<section>
<h2>Changelog</h2>
<ul>
<li>2026-01-06</li>
<li>Initial specification</li>
</ul>
</section>
<script>
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
}
(function() {
  // Query param override (for REPL: ?theme=dark or ?theme=light)
  const params = new URLSearchParams(window.location.search);
  const param = params.get('theme');
  if (param === 'dark' || param === 'light') {
    document.documentElement.setAttribute('data-theme', param);
    localStorage.setItem('theme', param);
    return;
  }
  // localStorage preference
  const saved = localStorage.getItem('theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
  } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script>
</body>
</html>
