<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <title>Memo 0041: Scaling Architecture for IPv6</title>
  <link rel="icon" id="favicon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27%230f0%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>">
  <script>
(function(){
  var h=new Date().getHours(),c;
  if(h>=4&&h<6)c='%23845EC2';       // brahma muhurta - violet
  else if(h>=6&&h<8)c='%23ffd700';  // dawn - gold
  else if(h>=8&&h<11)c='%2300d4aa'; // morning - teal
  else if(h>=11&&h<14)c='%230f0';   // midday - phosphor
  else if(h>=14&&h<17)c='%2339ff14';// afternoon - neon
  else if(h>=17&&h<19)c='%23ff6600';// sunset - orange
  else if(h>=19&&h<22)c='%23ff3366';// evening - coral
  else c='%2300ffff';               // night - cyan
  document.getElementById('favicon').href='data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27'+c+'%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>';
})();
</script>
  <link rel="stylesheet" href="memo.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<p class="format-notice"><em>For pixel-perfect diagrams: <a href="memo-0041-ipv6-scaling.ps">PostScript</a> or <a href="memo-0041-ipv6-scaling.pdf">PDF</a></em></p>
<h1>Memo 0041: Scaling Architecture for IPv6</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This Memo defines the architectural changes required to scale Cyberspace from a git-backed prototype to a native distributed system capable of operating at IPv6 scale (billions of realms, exabytes of content). Git becomes an export format; the vault becomes the source of truth.</p>
</section>
<section>
<h2>Terminology</h2>
<p>Realm: A node's place in cyberspace - its vault, principal, capabilities, and objects. Each realm is sovereign: local-first, controlled by its operator. Realms federate by choice, sharing objects according to trust relationships.</p>
<p>Vault: The local content-addressed object store (.vault/). The vault IS the realm's storage - all objects, catalogs, audit trails, and configuration live here.</p>
<p>Principal: A node's cryptographic identity (Ed25519 public key). The principal identifies the realm to peers and signs its objects.</p>
<p>At IPv6 scale, cyberspace consists of billions of realms, each occupying its own address space, each sovereign, each choosing what to share and with whom.</p>
</section>
<section>
<h2>Motivation</h2>
<p>Git served as an excellent prototype substrate: - Content-addressed objects (proof of concept) - Merkle tree integrity (validates the model) - Ubiquitous tooling (bootstrap adoption)</p>
<p>Git cannot scale to IPv6: - Full history on every clone - Repository as replication unit (too coarse) - SHA-1 (cryptographically broken) - No native federation or discovery - Merge semantics are wrong model</p>
<p>The internet has 2^128 addresses. Cyberspace should use them.</p>
</section>
<section>
<h2>Design Principles</h2>
<pre>
1. Objects, not repositories
2. Pull, not push
3. Lazy, not eager
4. Local-first, federate-second
5. Trust math, not infrastructure
</pre>
</section>
<section>
<h2>Content-Addressed Object Store</h2>
<h3>Storage Model</h3>
<pre>
.vault/
  objects/
    sha512-a1b2c3.../    # First 8 chars as directory
      a1b2c3d4e5f6...    # Full hash as filename (S-expression)
  catalog/
    manifest.sexp        # Vault catalog object
    bloom.sexp           # Bloom filter object
    indices/             # Secondary index objects
      by-signer.sexp
      by-type.sexp
  chunks/
    sha512-xxxx/         # Chunked large objects
  audit/
    head.sexp            # Current audit chain head
    chain/               # Audit entries (hash-addressed)
</pre>
<h3>Object Format</h3>
<pre class="language-scheme">
(cyberspace-object
  (version 1)
  (type blob|tree|manifest|cert|audit)
  (size 1048576)
  (compression zstd|none)
  (hash "sha512:a1b2c3...")
  (chunks ("sha512:..." "sha512:..." ...))  ; If chunked
  (signature "ed25519:...")
  (timestamp 1736300000))
</pre>
<h3>Chunking Strategy</h3>
<p>Large objects split at content-defined boundaries (Rabin fingerprinting). Chunk size adapts to link characteristics:</p>
<pre class="diagram">
Link Profile          RTT        Bandwidth    Target Chunk
─────────────────────────────────────────────────────────────
Fiber/Datacenter     1-5ms      1Gbps+       256KB-1MB
Cable/DSL            10-30ms    50-500Mbps   128KB
Starlink             20-40ms    100-300Mbps  64KB
LTE/5G               10-50ms    variable     32-128KB
LoRa/Mesh            100ms+     kbps         4-16KB
Sneakernet           ∞          ∞            no chunking

Rabin parameters (content-defined):
  Min chunk:    4 KB   (floor for all links)
  Max chunk:    1 MB   (ceiling for all links)
  Target:       link-adaptive (see above)
</pre>
<p>Chunk size continuously adapts as links come and go. Mobile nodes may switch from WiFi to LTE to Starlink - the transfer strategy adjusts in real-time. Deduplication works across chunk sizes - same content, same hash.</p>
<pre class="language-scheme">
(define (optimal-chunk-size link)
  "Calculate target chunk size for link characteristics."
  (let ((rtt-ms (link-rtt link))
        (bandwidth-mbps (link-bandwidth link)))
    (cond
      ((&lt; rtt-ms 10)   (* 256 1024))   ; Datacenter
      ((&lt; rtt-ms 30)   (* 128 1024))   ; Cable/DSL
      ((&lt; rtt-ms 50)   (* 64 1024))    ; Starlink/LTE
      ((&lt; rtt-ms 100)  (* 32 1024))    ; Slow mobile
      (else            (* 8 1024)))))  ; Constrained

;; Auto-tune from observed performance
(define (auto-tune-chunk-size! link)
  "Adjust chunk size based on transfer performance."
  (let* ((samples (link-transfer-samples link))
         (avg-throughput (mean (map sample-throughput samples)))
         (avg-rtt (mean (map sample-rtt samples))))
    (link-chunk-size-set! link (optimal-chunk-size-for avg-rtt avg-throughput))))
</pre>
<p>Benefits:</p>
<pre>
  - Deduplication across objects (hash-based)
  - Partial sync (fetch only missing chunks)
  - Resumable transfers
  - Efficient diff
  - Link-optimal transfer sizes
  - Graceful degradation on constrained links
</pre>
<h3>Hash Function</h3>
<pre>
SHA-512 everywhere.

Not SHA-256: We have the bits, use them.
Not SHA-1: Broken.
Not BLAKE3: Less analyzed, marginal speed gain irrelevant at network latency.

SHA-512 is:
  - FIPS certified (GovCloud path)
  - 50 years of cryptanalysis
  - Hardware accelerated
  - Already in use (audit trail, signatures)
</pre>
</section>
<section>
<h2>Catalog and Query</h2>
<p>The soup IS the catalog. No SQL. Objects are S-expressions, queries are pattern matching.</p>
<h3>The Soup Query Model</h3>
<pre class="language-scheme">
;; Find objects by pattern
(soup-query
  '(cyberspace-object
    (type blob)
    (signer "ed25519:alice...")
    ?rest))                        ; Match any object signed by Alice

;; Find by hash (direct lookup)
(soup-fetch "sha512:a1b2c3...")    ; O(1) content-addressed

;; Find by type
(soup-query '(cyberspace-object (type cert) ?rest))

;; Find by time range
(soup-query-range
  type: 'audit
  from: 1736000000
  to:   1736100000)

;; Cursor-based iteration for large result sets
(soup-cursor
  '(cyberspace-object (type ?) ?rest)
  batch: 100)
</pre>
<h3>Object Catalog</h3>
<p>The catalog is itself an object in the soup - a manifest of what the vault contains:</p>
<pre class="language-scheme">
(vault-catalog
  (version 1)
  (realm "ed25519:principal...")
  (object-count 150000)
  (types
    (blob 100000)
    (tree 30000)
    (cert 15000)
    (audit 5000))
  (bloom-filter #${...})           ; Fast existence check
  (updated 1736400000))
</pre>
<h3>Bloom Filter</h3>
<p>Fast existence check before network round-trip:</p>
<pre class="language-scheme">
(define (soup-maybe-contains? hash)
  "Check bloom filter - false means definitely not, true means maybe"
  (let ((catalog (soup-fetch-catalog)))
    (bloom-test (catalog-bloom catalog) hash)))

;; Bloom parameters
(bloom-filter
  (capacity 10000000)              ; 10M objects
  (false-positive 0.001)           ; 0.1% FP rate
  (bits #${...}))
</pre>
<h3>Audit Trail</h3>
<p>The audit trail is a hash-chain of objects in the soup:</p>
<pre class="language-scheme">
(audit-entry
  (sequence 12345)
  (timestamp 1736300000)
  (lamport 67890)
  (actor "ed25519:subject...")
  (action (read "sha512:object..."))
  (previous "sha512:prev-entry...")  ; Chain link
  (signature "ed25519:auditor..."))

;; Query audit by walking the chain
(define (audit-query actor from-seq)
  "Walk audit chain, filter by actor"
  (soup-chain-walk
    start: (audit-head)
    filter: (lambda (entry)
              (equal? (entry-actor entry) actor))
    from: from-seq))
</pre>
<h3>Secondary Indices</h3>
<p>For queries that can't use content-addressing, the soup maintains lightweight indices as objects:</p>
<pre class="language-scheme">
(soup-index
  (name "by-signer")
  (key-type principal)
  (entries
    (("ed25519:alice..." ("sha512:obj1" "sha512:obj2" ...))
     ("ed25519:bob..." ("sha512:obj3" "sha512:obj4" ...)))))

(soup-index
  (name "by-type")
  (key-type symbol)
  (entries
    ((blob ("sha512:..." "sha512:..." ...))
     (cert ("sha512:..." "sha512:..." ...))
     (audit ("sha512:..." "sha512:..." ...)))))
</pre>
<p>Indices are rebuilt on demand, not authoritative - the soup is truth.</p>
</section>
<section>
<h2>Discovery and Routing</h2>
<h3>Realm Identity</h3>
<p>Each realm has a principal (Ed25519 public key). This IS its identity:</p>
<pre class="language-scheme">
(realm-identity
  (principal "ed25519:a1b2c3...")
  (addresses                          ; Where to reach this realm
    (ipv6 "2001:db8::1" port: 7777)
    (ipv4 "192.0.2.1" port: 7777)     ; Legacy
    (onion "xxxx.onion" port: 7777))  ; Tor
  (role witness)
  (capabilities (storage-gb 1000) (bandwidth-mbps 100))
  (signature "ed25519:..."))
</pre>
<h3>Peer Discovery</h3>
<p>Bootstrap:</p>
<pre class="language-scheme">
(bootstrap-peers
  ("ed25519:official1..." "bootstrap.cyberspace.org")
  ("ed25519:official2..." "bootstrap2.cyberspace.org"))
</pre>
<p>Gossip Protocol:</p>
<pre>
1. Realm joins, contacts bootstrap peer
2. Receives partial peer list (random subset)
3. Contacts those peers, exchanges lists
4. Epidemic spread: O(log n) rounds to reach all realms
5. Periodic refresh (every 5 min on Starlink-friendly schedule)
</pre>
<p>Distributed Hash Table (Future):</p>
<pre>
Kademlia-style routing:
  - XOR distance metric on principal hashes
  - O(log n) lookups
  - Realms responsible for nearby hash ranges
  - Natural load balancing
</pre>
<h3>Content Discovery</h3>
<pre class="language-scheme">
;; "Who has this hash?"
(content-locate "sha512:a1b2c3...")

;; Returns list of peers claiming to have it:
(("ed25519:peer1..." (latency-ms 50) (role full))
 ("ed25519:peer2..." (latency-ms 200) (role witness))
 ("ed25519:peer3..." (latency-ms 600) (role archiver)))

;; Fetch from best candidate
(content-fetch "sha512:a1b2c3..." from: "ed25519:peer1...")
</pre>
</section>
<section>
<h2>Transport Protocol</h2>
<h3>End-to-End Encryption</h3>
<p>All network traffic is encrypted. The OS and network are not trusted.</p>
<pre class="language-scheme">
(cyberspace-message
  (version 1)
  (from "ed25519:sender...")
  (to "ed25519:recipient...")        ; Or broadcast key
  (ephemeral "x25519:...")           ; One-time key (PFS)
  (nonce #${24-bytes})               ; Random nonce
  (ciphertext #${...})               ; NaCl box: X25519 + XSalsa20-Poly1305
  (signature "ed25519:..."))         ; Sign the ciphertext
</pre>
<p>Encryption scheme: NaCl crypto_box (libsodium) - Key agreement: X25519 (Curve25519 ECDH) - Cipher: XSalsa20-Poly1305 - Perfect forward secrecy: ephemeral keys per message</p>
<p>Decrypted payload:</p>
<pre class="language-scheme">
(plaintext-payload
  (type request|response|announce|gossip)
  (nonce 12345678)                   ; Replay protection
  (timestamp 1736300000)
  (body ...))
</pre>
<p>Broadcast messages use a shared group key or are signed-only (announcements of public objects).</p>
<h3>Wire Format (Encrypted)</h3>
<pre class="language-scheme">
;; Sender encrypts
(define (seal-message payload recipient-pubkey sender-keypair)
  (let ((ephemeral (x25519-keypair))
         (shared (x25519-shared (ephemeral-secret ephemeral) recipient-pubkey))
         (nonce (random-bytes 24))
         (ciphertext (crypto-box payload nonce shared)))
    `(cyberspace-message
      (version 1)
      (from ,(keypair-public sender-keypair))
      (to ,recipient-pubkey)
      (ephemeral ,(ephemeral-public ephemeral))
      (nonce ,nonce)
      (ciphertext ,ciphertext)
      (signature ,(sign-message ciphertext sender-keypair)))))

;; Recipient decrypts
(define (open-message msg recipient-keypair)
  (let ((shared (x25519-shared (keypair-secret recipient-keypair)
                                (message-ephemeral msg)))
         (plaintext (crypto-box-open (message-ciphertext msg)
                                     (message-nonce msg)
                                     shared)))
    (and (verify-signature msg (message-from msg))
         plaintext)))
</pre>
<h3>Request Types</h3>
<pre class="language-scheme">
;; Existence check
(have? ("sha512:..." "sha512:..." ...))
;; Response: (have ("sha512:..." "sha512:...") missing ("sha512:..."))

;; Fetch object
(fetch "sha512:...")
;; Response: (object ...)

;; Fetch chunk range
(fetch-chunks "sha512:..." start: 5 count: 10)
;; Response: (chunks ...)

;; Peer list exchange
(peers? limit: 50)
;; Response: (peers ...)

;; Announce new content
(announce ("sha512:..." "sha512:..."))
;; Response: (ack)
</pre>
<h3>Transport Bindings</h3>
<pre>
Native:     UDP/IPv6, port 7777 (primary)
Fallback:   TCP/IPv6, port 7777 (firewalls)
Legacy:     TCP/IPv4, port 7777 (transition)
Stealth:    Tor onion service (censorship resistance)
Offline:    USB drive, file copy (sneakernet)
Export:     Git bundle (GitHub compatibility)
</pre>
<h3>Link-Adaptive Transport</h3>
<p>Transport parameters adapt to detected link type:</p>
<pre class="language-scheme">
(transport-config
  (link-detection auto)          ; Probe RTT/bandwidth
  (chunk-size adaptive)          ; See Chunking Strategy
  (batch-window-ms               ; Aggregate small messages
    (fiber 50)
    (starlink 500)
    (lte 200)
    (lora 2000))
  (retry-strategy exponential)
  (max-in-flight                 ; Parallelism based on BDP
    (fiber 100)
    (starlink 10)
    (lte 5)
    (lora 1))
  (keepalive-sec                 ; Idle timeout
    (fiber 60)
    (starlink 300)
    (lte 120)
    (lora 600)))

;; Re-evaluate on link change
(define (on-link-change! old-link new-link)
  "Adjust transport when connectivity changes."
  (let ((config (detect-link-profile new-link)))
    (transport-reconfigure! config)
    (log-link-transition old-link new-link)))
</pre>
</section>
<script>
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
}
(function() {
  // Query param override (for REPL: ?theme=dark or ?theme=light)
  const params = new URLSearchParams(window.location.search);
  const param = params.get('theme');
  if (param === 'dark' || param === 'light') {
    document.documentElement.setAttribute('data-theme', param);
    localStorage.setItem('theme', param);
    return;
  }
  // localStorage preference
  const saved = localStorage.getItem('theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
  } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script>
</body>
</html>
