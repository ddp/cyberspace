<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <title>Memo 0049: TCB Access Control and Audit Integration</title>
  <link rel="icon" id="favicon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27%230f0%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>">
  <script>
(function(){
  var h=new Date().getHours(),c;
  if(h>=4&&h<6)c='%23845EC2';       // brahma muhurta - violet
  else if(h>=6&&h<8)c='%23ffd700';  // dawn - gold
  else if(h>=8&&h<11)c='%2300d4aa'; // morning - teal
  else if(h>=11&&h<14)c='%230f0';   // midday - phosphor
  else if(h>=14&&h<17)c='%2339ff14';// afternoon - neon
  else if(h>=17&&h<19)c='%23ff6600';// sunset - orange
  else if(h>=19&&h<22)c='%23ff3366';// evening - coral
  else c='%2300ffff';               // night - cyan
  document.getElementById('favicon').href='data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27'+c+'%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>';
})();
</script>
  <link rel="stylesheet" href="memo.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<h1>Memo 0049: TCB Access Control and Audit Integration</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This Memo establishes the principle that access control and auditing must be designed together, not separately. Every access control decision point produces three outputs: a decision, an effect, and a record. Audit policy is per-realm, with lean defaults.</p>
</section>
<section>
<h2>Motivation</h2>
<p>Security systems often treat auditing as an afterthought—bolted on after access control is designed. This leads to:</p>
<ul>
<li>Incomplete coverage: Some decisions are never logged</li>
<li>Inconsistent records: Different formats at different points</li>
<li>Performance surprises: Auditing added late without cost analysis</li>
<li>Policy gaps: No framework for what to log when</li>
</ul>
<p>These failures arise from treating auditing as an afterthought. Access control without auditing cannot detect attacks; auditing without access control cannot prevent them. Co-design ensures both work together from the start.</p>
</section>
<section>
<h2>Design Principle</h2>
<p>Access control and auditing are co-designed, not bolted on.</p>
<p>Every access control point has three outputs:</p>
<pre class="diagram">
┌─────────────────────────────────────┐
│         Access Control Point        │
├─────────────────────────────────────┤
│ Input:  principal, action, context  │
├─────────────────────────────────────┤
│ Output: decision (grant | refuse)   │
│         effect   (what happens)     │
│         record   (audit entry)      │
│                  ↓                  │
│         policy → lean: print        │
│                  paranoid: append   │
└─────────────────────────────────────┘
</pre>
<h3>The Three Outputs</h3>
<ul>
<li>Decision: Grant or refuse the requested action</li>
<li>Effect: The consequence of the decision (action performed, or refusal message)</li>
<li>Record: An audit entry capturing what happened</li>
</ul>
<h3>Auditable vs. Audited</h3>
<ul>
<li>Auditable: The mechanism exists to log the event</li>
<li>Audited: The event is actively being logged</li>
</ul>
<p>All access control decisions are auditable. Whether they are audited depends on realm policy.</p>
</section>
<section>
<h2>Per-Realm Audit Policy</h2>
<p>Each realm configures its own audit policy. The default is lean.</p>
<h3>Policy Levels</h3>
<table>
<tr><th>Level </th><th>Description </th></tr>
<tr><td>lean </td><td>Minimal auditing, low overhead (default) </td></tr>
<tr><td>standard </td><td>Security-relevant events audited </td></tr>
<tr><td>paranoid </td><td>All access decisions audited </td></tr>
</table>
<h3>Event Categories</h3>
<table>
<tr><th>Event </th><th>Lean </th><th>Standard </th><th>Paranoid </th></tr>
<tr><td>Successful joins </td><td>audit </td><td>audit </td><td>audit </td></tr>
<tr><td>Join refusals </td><td>print </td><td>audit </td><td>audit </td></tr>
<tr><td>Delegations </td><td>audit </td><td>audit </td><td>audit </td></tr>
<tr><td>Revocations </td><td>audit </td><td>audit </td><td>audit </td></tr>
<tr><td>Capability grants </td><td>audit </td><td>audit </td><td>audit </td></tr>
<tr><td>Capability refusals </td><td>print </td><td>audit </td><td>audit </td></tr>
<tr><td>Object reads </td><td>— </td><td>— </td><td>audit </td></tr>
<tr><td>Object writes </td><td>print </td><td>audit </td><td>audit </td></tr>
</table>
<h3>Configuration</h3>
<pre class="language-scheme">
(realm-audit-policy 'lean)      ; default
(realm-audit-policy 'standard)
(realm-audit-policy 'paranoid)

;; Or fine-grained:
(realm-audit-policy
  '((joins . audit)
    (refusals . print)
    (delegations . audit)
    (reads . none)))
</pre>
</section>
<section>
<h2>Implementation Pattern</h2>
<p>When implementing an access control point:</p>
<pre class="language-scheme">
(define (access-control-point principal action context)
  "Template for access control with co-designed auditing"

  ;; 1. Make the decision
  (let ((decision (evaluate-policy principal action context)))

    ;; 2. Record based on policy
    (case (realm-audit-policy)
      ((paranoid)
       (audit-append
         actor: principal
         action: `(,action ,@context)
         motivation: (if (eq? decision 'grant)
                         "Access granted"
                         "Access refused")))
      ((standard)
       (when (or (eq? decision 'grant)
                 (security-relevant? action))
         (audit-append ...)))
      ((lean)
       (when (eq? decision 'refuse)
         (print (format "~a Refused: ~a" action (refuse-reason))))))

    ;; 3. Effect
    (if (eq? decision 'grant)
        (perform-action action context)
        (refuse-with-reason action context))))
</pre>
</section>
<section>
<h2>Vocabulary</h2>
<p>Consistent terminology for access control outcomes:</p>
<table>
<tr><th>Outcome </th><th>Verb </th><th>Usage </th></tr>
<tr><td>Execution fails </td><td>Evaporated </td><td>"Execution Evaporated: Signature verification failed" </td></tr>
<tr><td>Join denied </td><td>Refused </td><td>"Join Refused: No valid attestation" </td></tr>
<tr><td>Capability denied </td><td>Refused </td><td>"Capability Refused: Insufficient authority" </td></tr>
<tr><td>Operation blocked </td><td>Refused </td><td>"Operation Refused: Policy violation" </td></tr>
</table>
<p>Avoid: terminated, aborted, ended, failed (where possible).</p>
</section>
<section>
<h2>Security Considerations</h2>
<h3>Refusal Patterns</h3>
<p>A pattern of refusals may indicate: - Misconfiguration (legitimate users being blocked) - Attack probing (malicious principals testing boundaries) - Policy too restrictive (needs adjustment)</p>
<p>Standard and paranoid policies audit refusals to enable pattern detection.</p>
<h3>Audit Cost</h3>
<p>Each audit entry is: - Cryptographically signed (Ed25519) - Hash-chained to previous entry - Persisted to storage</p>
<p>Lean policy minimizes this overhead for high-throughput realms.</p>
<h3>Audit Integrity</h3>
<p>Audit entries themselves are tamper-evident. An attacker cannot: - Delete entries (breaks hash chain) - Modify entries (invalidates signature) - Reorder entries (violates sequence numbers)</p>
</section>
<section>
<h2>References</h2>
<ul>
<li>Memo-003: Cryptographic Audit Trail</li>
<li>Memo-004: SPKI Authorization</li>
<li>Memo-046: Security Architecture</li>
</ul>
</section>
<section>
<h2>Changelog</h2>
<p>- 2026-01-10: Initial draft</p>
</section>
<script>
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
}
(function() {
  // Query param override (for REPL: ?theme=dark or ?theme=light)
  const params = new URLSearchParams(window.location.search);
  const param = params.get('theme');
  if (param === 'dark' || param === 'light') {
    document.documentElement.setAttribute('data-theme', param);
    localStorage.setItem('theme', param);
    return;
  }
  // localStorage preference
  const saved = localStorage.getItem('theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
  } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script>
</body>
</html>
