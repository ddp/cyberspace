Memo 0004: Replication Layer for Library of Cyberspace


------------------------------------------------------------------------

------------------------------------------------------------------------
ABSTRACT
------------------------------------------------------------------------

This Memo specifies a replication layer for the Library of Cyberspace
preservation architecture, enabling cryptographically sealed releases to
be published, subscribed to, and synchronized across distributed
locations while maintaining tamper-evident audit trails.


------------------------------------------------------------------------
MOTIVATION
------------------------------------------------------------------------


    "The network is the computer. â€” John Gage, Sun Microsystems"


Heritage: "Behave as One"
-------------------------

The VAXcluster principle (1984): N nodes must behave as one. Not
eventually consistent. Not loosely coupled. Identical. One security
domain, one namespace, one view of the world.

DECnet Phase IV's 24-bit addressing was fatal for internet scale.
Cyberspace applies the same principle to IPv6's 128-bit address space.
Federated nodes, behaving as one.

But unlike VAXcluster's tight coupling over CI bus, Cyberspace
replication works over any transport: git pushes, HTTP posts, USB drives
carried across air gaps. The cryptography travels with the data.


Requirements
------------

The Library of Cyberspace requires a distribution mechanism that:

  * Preserves cryptographic authenticity - Signatures travel with artifacts
  * Enables offline verification - No centralized authority required
  * Records provenance - All publication events are audited
  * Supports multiple transports - Git, HTTP, filesystem
  * Maintains loose coupling - Works for confederations of friends

These requirements reflect the reality of distributed archival: networks
partition, authorities disappear, and trust must be verifiable without
phoning home.

Traditional package managers and distribution systems assume centralized
registries and online verification. This replication layer is designed
for decentralized, long-term preservation where trust is established
through Simple Public Key Infrastructure (SPKI) certificates and
cryptographic seals.


------------------------------------------------------------------------
DESIGN PRINCIPLES
------------------------------------------------------------------------

  * Sealed Releases - Only cryptographically signed releases can be published
  * Transport Agnostic - Same API works for git, HTTP, filesystem
  * Audit Everything - All replication events are recorded in tamper-evident log
  * Verify Before Trust - Subscribers must verify cryptographic seals
  * Explicit Authorization - SPKI certificates determine who can publish

These principles ensure that trust is established cryptographically
rather than administratively, and that the system works regardless of
network topology or transport mechanism.


------------------------------------------------------------------------
SPECIFICATION
------------------------------------------------------------------------


seal-publish
------------

Publish a sealed release to a remote location. The fundamental
operation: take what's been cryptographically sealed locally and make it
available elsewhere.


    (seal-publish version
                  remote: target
                  archive-format: format
                  message: notes)

Parameters:


  Parameter        Description                                              
  version          Semantic version string (e.g., "1.0.0")                  
  remote           Publication target: git remote, URL, or directory path   
  archive-format   'tarball, 'bundle, or 'cryptographic (default)           
  message          Release notes (optional)                                 

Behavior:

  * Verify release exists (creates if needed via seal-release)
  * Create cryptographic archive with: tarball of repository at version tag, SHA-512 hash of tarball, Ed25519 signature of hash, manifest with version, hash, signature
  * Publish to remote based on type: Git remote (push tag, optionally upload archive), HTTP URL (POST archive to endpoint), Filesystem (copy archive to directory)
  * Record publication in audit trail with: actor (public key from signing key), action (seal-publish version remote), motivation (release notes), cryptographic seal (signature)

Audit Entry Format:


    (audit-entry
      (id "sha512:...")
      (timestamp "Mon Jan 5 23:38:20 2026")
      (sequence 1)
      (actor
        (principal #${public-key-blob})
        (authorization-chain))
      (action
        (verb seal-publish)
        (object "1.0.0")
        (parameters "/path/to/remote"))
      (context
        (motivation "Published to filesystem")
        (language "en"))
      (environment
        (platform "unknown")
        (timestamp 1767685100))
      (seal
        (algorithm "ed25519-sha512")
        (content-hash "...")
        (signature "...")))


seal-subscribe
--------------

Subscribe to sealed releases from a remote source. Pull what others have
published, verify it cryptographically, trust nothing until proven.


    (seal-subscribe remote
                    target: local-path
                    verify-key: public-key)

Parameters:


  Parameter    Description                                        
  remote       Source location: git remote, URL, or directory     
  target       Local path for downloaded archives (optional)      
  verify-key   Public key for signature verification (optional)   

Behavior:

  * Discover available releases from remote: Git remote (list tags), HTTP URL (GET /releases endpoint), Filesystem (list .archive files)
  * Download cryptographic archives
  * Verify each archive: check manifest structure, verify SHA-512 hash of tarball, verify Ed25519 signature (if verify-key provided)
  * Extract verified archives to target directory
  * Record subscription in audit trail: count of releases downloaded, source location, verification status

Security Consideration: Without verify-key, subscription downloads
archives but cannot verify authenticity. SPKI certificate chains should
be used to establish trust.


seal-synchronize
----------------

Bidirectional synchronization of sealed releases. For peers who trust
each other: what you have that I don't, what I have that you don't,
reconcile.


    (seal-synchronize remote
                      direction: 'both
                      verify-key: public-key)

Parameters:


  Parameter    Description                                        
  remote       Sync target: git remote, URL, or directory         
  direction    'both (default), 'push-only, or 'pull-only         
  verify-key   Public key for signature verification (optional)   

Behavior:

  * Discover local and remote releases
  * Compare versions to determine: releases to push (local but not remote), releases to pull (remote but not local)
  * Execute publication for new local releases
  * Execute subscription for new remote releases
  * Record synchronization in audit trail: count pushed and pulled, remote location, direction

Use Case: Periodic sync between trusted peers in a confederation.


------------------------------------------------------------------------
ARCHIVE FORMAT
------------------------------------------------------------------------


Cryptographic Archive Structure
-------------------------------


    vault-1.0.0.archive          # Manifest file
    vault-1.0.0.archive.tar.gz   # Actual tarball

Manifest S-expression:


    (sealed-archive
      (version "1.0.0")
      (format cryptographic)
      (tarball "vault-1.0.0.archive.tar.gz")
      (hash "sha512:...")
      (signature "ed25519:...")
      (timestamp 1767685100)
      (sealer #${public-key-blob}))

Verification Steps:

  * Read manifest
  * Hash tarball with SHA-512
  * Verify hash matches manifest
  * Verify Ed25519 signature on hash
  * Check SPKI authorization (optional)


------------------------------------------------------------------------
TRANSPORT IMPLEMENTATIONS
------------------------------------------------------------------------


Git Remote
----------

  * Uses git push to share tags
  * Optionally uploads archives as release assets (GitHub, GitLab)
  * Fetch uses git fetch + git tag -l


HTTP Endpoint
-------------

  * POST to /releases/<version> for publication
  * GET /releases for discovery
  * Content-Type: application/x-sealed-archive


Filesystem
----------

  * Copy archives to shared directory
  * Directory structure: <remote>/<archive-name>
  * No network required, works with NFS, USB drives, etc.


------------------------------------------------------------------------
AUDIT INTEGRATION
------------------------------------------------------------------------

Every replication operation creates an audit entry. No silent
operations. No unattributed changes. See Memo-005 for the full audit
trail specification.

Each entry contains:

  * Content-addressed ID: SHA-512 hash of entry
  * Chained structure: References parent entry
  * SPKI principal: Public key of actor
  * Dual context: Human motivation + machine environment
  * Cryptographic seal: Ed25519 signature

This provides:

  * Non-repudiation: Cannot deny publication
  * Tamper evidence: Changes are detectable
  * Causality: Chain shows temporal order
  * Accountability: Know who published what, when, and why


------------------------------------------------------------------------
SECURITY CONSIDERATIONS
------------------------------------------------------------------------


Threat Model
------------

Trusted:

  * Local filesystem and vault
  * SPKI private keys (your responsibility)
  * Cryptographic primitives (libsodium, audited)

Untrusted:

  * Remote repositories (anyone can host anything)
  * Network transport (assume hostile)
  * Downloaded archives (verify before use)
  * Remote publishers (until SPKI chain verified)

The key insight: trust the math, not the infrastructure. A verified
signature is proof regardless of how it arrived.


Attack Scenarios
----------------

  * Malicious Archive Substitution - Attacker replaces archive on remote - Mitigation: Signature verification fails
  * Version Rollback Attack - Attacker removes newer releases - Mitigation: Audit trail shows previous versions
  * Unauthorized Publication - Attacker publishes fake release - Mitigation: SPKI authorization chain required
  * Transport Tampering - Network attacker modifies download - Mitigation: Hash and signature verification

Each attack is addressed at the cryptographic layer rather than the
transport layer, ensuring protection regardless of network conditions.


Best Practices
--------------

  * Always verify signatures - Use verify-key parameter
  * Check SPKI certificates - Verify authorization chain
  * Maintain audit trail - Detect suspicious patterns
  * Use HTTPS for HTTP transport - Prevent network attacks
  * Backup signing keys - Use Shamir secret sharing

Defense in depth: cryptographic verification is primary, but transport
security and operational practices add additional layers.


------------------------------------------------------------------------
IMPLEMENTATION NOTES
------------------------------------------------------------------------


Helper Functions
----------------


    (tag-exists? tag-name)        ; Check if git tag exists
    (git-remote? str)             ; Detect git remote format
    (http-url? str)               ; Detect HTTP/HTTPS URL
    (publish-filesystem remote version archive)  ; Copy to directory
    (publish-http url version archive)           ; POST to endpoint


Dependencies
------------

  * Git: Version control and tag management
  * libsodium: Ed25519 signatures, SHA-512 hashing
  * (chicken process): Run git commands
  * (chicken file): Filesystem operations
  * (chicken irregex): URL/remote detection


------------------------------------------------------------------------
COMPATIBILITY
------------------------------------------------------------------------

This specification builds on existing standards rather than inventing
new ones:


  Technology         Role                                  
  Git tags           Standard version control operations   
  Git bundles        Portable repository format            
  Tarball archives   Universal archive format              
  S-expressions      LISP/Scheme readable manifests        
  SDSI/SPKI          Authorization certificates            

Future extensions may add:

  * IPFS transport: Content-addressed distribution
  * Tor hidden services: Anonymous publication
  * Encrypted archives: Confidential distribution
  * Multi-signature releases: Threshold authorization


------------------------------------------------------------------------
TEST COVERAGE
------------------------------------------------------------------------

See test-replication.scm:


    ;; Test seal-publish to filesystem
    (seal-publish "1.0.0"
                  remote: "/tmp/cyberspace-publish-test"
                  message: "Published to filesystem")
    ;; Verify archive exists
    (file-exists? "/tmp/cyberspace-publish-test/vault-1.0.0.archive")
    ;; Verify audit entry created
    (audit-read sequence: 1)


------------------------------------------------------------------------
REFERENCES
------------------------------------------------------------------------

  * SDSI/SPKI: RFC 2693, RFC 2692
  * Content-Addressed Storage: Git internals, IPFS
  * Semantic Versioning: semver.org
  * Ed25519: Bernstein et al., 2006
  * Audit Trails: Memo-005 (Cryptographic Audit Trail)


------------------------------------------------------------------------
CHANGELOG
------------------------------------------------------------------------

2026-01-19 - Expanded narrative, fixed formatting

2026-01-05 - Initial specification: seal-publish, seal-subscribe,
seal-synchronize with full audit trail integration

------------------------------------------------------------------------
