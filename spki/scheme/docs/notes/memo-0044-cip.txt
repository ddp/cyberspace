Memo 0044: Imprint Protocol


------------------------------------------------------------------------

------------------------------------------------------------------------
ABSTRACT
------------------------------------------------------------------------

CIP establishes secure channels between Cyberspace nodes using stateless
cookies for DoS resistance, ephemeral key exchange for forward secrecy,
and capability attestation for authorization. Each imprint is an
authoritative affirmation of trust - signed and sealed by the issuing
principal in their realm. No X.509. No CA hierarchy. No algorithm
negotiation.


------------------------------------------------------------------------
MOTIVATION
------------------------------------------------------------------------

TLS is complex: - Certificate chains require PKI - Algorithm negotiation
invites downgrade attacks - State allocated before client proven real -
Identity exposed before encryption

PHOTURIS (1995) had better ideas: - Cookies before crypto - Identity
under encryption - Simple state machine

CIP resurrects these ideas with modern primitives.


------------------------------------------------------------------------
PROTOCOL OVERVIEW
------------------------------------------------------------------------


    Initiator                          Responder
        |                                   |
        |-------- KNOCK (version) -------->|  Stateless
        |<-------- COOKIE -----------------|  Stateless
        |                                   |
        |-------- EXCHANGE (eph key) ----->|  State committed
        |<------- EXCHANGE (eph key) ------|
        |                                   |
        |========= encrypted below ========|
        |                                   |
        |-------- ATTEST (identity) ------>|
        |<------- ATTEST (identity) -------|
        |                                   |
        |-------- OFFER (capabilities) --->|
        |<------- OFFER (capabilities) ----|
        |                                   |
        |-------- CONFIRM (transcript) --->|
        |<------- CONFIRM (transcript) ----|
        |                                   |
        |========= CHANNEL OPEN ===========|
        |                                   |
        |<----------- DATA -------------->|

10 messages to establish. Unlimited encrypted DATA after.


------------------------------------------------------------------------
MESSAGE FORMAT
------------------------------------------------------------------------

All messages use TLV encoding:


    ┌──────┬────────┬──────────────────┐
    │ Type │ Length │ Payload          │
    │ 1B   │ 4B BE  │ variable         │
    └──────┴────────┴──────────────────┘


Message Types
-------------


  Type   Name       Direction       
  0x01   KNOCK      I → R         
  0x02   COOKIE     R → I         
  0x03   EXCHANGE   bidirectional   
  0x04   ATTEST     bidirectional   
  0x05   OFFER      bidirectional   
  0x06   CONFIRM    bidirectional   
  0x10   DATA       bidirectional   
  0xFF   CLOSE      bidirectional   


------------------------------------------------------------------------
PHASE 1: KNOCK
------------------------------------------------------------------------

Initiator announces intent and protocol version.


    KNOCK payload:
      "CIP/" VERSIONMAJOR "." VERSIONMINOR
    Example: "CIP/1.0"

Responder checks version compatibility: - Major mismatch: reject
(incompatible suites) - Minor mismatch: accept (backward compatible)

Responder allocates no state.


------------------------------------------------------------------------
PHASE 2: COOKIE
------------------------------------------------------------------------

Responder returns stateless cookie.


    (define (make-cookie remote-addr remote-port)
      (let ((data (string-append
                    (blob->string cookie-secret)
                    remote-addr
                    (number->string remote-port)
                    (number->string cookie-epoch*)))
             (hash (blake2b-hash (string->blob data))))
        (substring hash 0 16)))

Cookie properties: - Stateless: Responder doesn't store it -
Unforgeable: Requires server secret - Expiring: Epoch rotation
invalidates old cookies - Address-bound: Different address = different
cookie

Responder still allocates no state.


------------------------------------------------------------------------
PHASE 3: EXCHANGE
------------------------------------------------------------------------

Both parties exchange ephemeral public keys.

Initiator sends:


    EXCHANGE payload:
      cookie-r "|" cookie-i "|" ephemeral-public-hex

- cookie-r: Echo of responder's cookie (proves receipt) - cookie-i:
Initiator's random cookie (for key derivation) - ephemeral-public:
X25519 public key

Responder verifies cookie echo, then responds with same format.

State now committed. Keys derived.


Key Derivation
--------------


    (define (derive-session-keys shared-secret cookie-i cookie-r)
      (let* ((ikm (blob-append shared-secret
                               (string->blob cookie-i)
                               (string->blob cookie-r)))
             (prk (blake2b-hash ikm))
             (k-ir (blake2b-hash (blob-append prk "initiator->responder")))
             (k-ri (blake2b-hash (blob-append prk "responder->initiator"))))
        (values (take k-ir 32) (take k-ri 32))))

Directional keys prevent reflection attacks.


------------------------------------------------------------------------
PHASE 4: ATTEST
------------------------------------------------------------------------

All subsequent messages encrypted.

Both parties prove identity using Simple Public Key Infrastructure
(SPKI) principals.


    ATTEST payload (encrypted):
      principal-hash "|" signature

- principal-hash: SPKI principal (hex-encoded public key hash) -
signature: Ed25519 signature over transcript

Identity is cryptographic, not nominal. A principal is identified solely
by its public key hash, never by a human-readable name. This is a prime
directive.

The attestation is the principal's authoritative affirmation of their
own trust: I vouch for this channel. This is not a bearer token - it is
my sealed declaration, bound to my realm.

Transcript for signing:


    cookie-i || cookie-r || ephemeral-public


Anonymous Attestation (Optional)
--------------------------------

For privacy, use Chaum-style blind signatures:


    (define (blind-attest capability-hash)
      ;; Prove authorization without revealing identity
      (blind-sign capability-hash (blind-factor)))


------------------------------------------------------------------------
PHASE 5: OFFER
------------------------------------------------------------------------

Exchange authorized capabilities as SPKI tags.


    OFFER payload (encrypted):
      (tag ( set capability ...))
    Example: "(tag ( set read write replicate))"

Capabilities follow Memo-021 (Capability Delegation): - Only offer what
you hold - Attenuation only, no amplification - Explicit, not ambient -
Expressed as SPKI tag s-expressions

Future: Full SPKI auth-certs with issuer signatures.


------------------------------------------------------------------------
PHASE 6: CONFIRM
------------------------------------------------------------------------

Bind entire transcript.


    CONFIRM payload (encrypted):
      BLAKE2b(cookie-i || cookie-r || their-principal)

Both parties must produce matching hashes. Any tampering detected.


------------------------------------------------------------------------
DATA PHASE
------------------------------------------------------------------------

Channel open. Encrypted messaging.


    DATA payload:
      ChaCha20-Poly1305(key, nonce, plaintext)

Nonce construction:


    nonce = sequence-number (8 bytes) || 0x00000000 (4 bytes)

Sequence numbers: - Start at 0 - Increment per message - Prevent replay
- Separate counters per direction


------------------------------------------------------------------------
ALGORITHM SUITES
------------------------------------------------------------------------

No runtime negotiation. Version determines suite.


CIP/1.x (Current)
-----------------


  Function       Algorithm           
  Key Exchange   X25519              
  Signatures     Ed25519             
  AEAD           ChaCha20-Poly1305   
  Hash           BLAKE2b             
  KDF            HKDF-BLAKE2b        


CIP/2.x (Reserved: Post-Quantum)
--------------------------------


  Function       Algorithm           
  Key Exchange   Kyber-1024          
  Signatures     Dilithium3          
  AEAD           ChaCha20-Poly1305   
  Hash           BLAKE2b             


CIP/3.x (Reserved: Hybrid)
--------------------------


  Function       Algorithm             
  Key Exchange   X25519 + Kyber        
  Signatures     Ed25519 + Dilithium   


------------------------------------------------------------------------
SECURITY PROPERTIES
------------------------------------------------------------------------


DoS Resistance
--------------


  Attack             Defense                         
  SYN flood          Cookie proves return path       
  Amplification      No response until cookie echo   
  State exhaustion   No state until Phase 3          


Forward Secrecy
---------------

Ephemeral X25519 keys: - Generated per session - Destroyed after key
derivation - Compromise of long-term key doesn't expose past sessions


Identity Protection (SPKI Native)
---------------------------------

Principal identity: - Is the public key hash (not a name, not a
certificate) - Only revealed after encryption established - Only
revealed to authenticated peer - Never in plaintext on wire -
Self-certifying: principal = hash(public_key)


Replay Protection
-----------------

  * Sequence numbers per direction
  * Nonce never reused (fatal if violated)
  * AEAD authentication fails on replay

Each security property addresses a specific attack class. DoS resistance
prevents resource exhaustion before authentication; forward secrecy
limits damage from key compromise; identity protection prevents traffic
analysis; replay protection ensures message freshness.


------------------------------------------------------------------------
COMPARISON
------------------------------------------------------------------------


  Property                TLS 1.3   IKEv2     CIP       
  Messages to establish   2-3       4+        10        
  DoS resistance          Limited   Cookies   Cookies   
  Algorithm negotiation   Yes       Yes       No        
  Certificate required    Yes       Yes       No        
  Identity protection     Partial   Yes       Yes       
  Capability binding      No        No        Yes       

CIP trades fewer round-trips for simplicity and capability integration.


------------------------------------------------------------------------
IMPLEMENTATION
------------------------------------------------------------------------


    ;; Initiator
    (define ch (node-connect "remote.host" 4433))
    (channel-send ch '(request object-hash))
    (channel-recv ch)
    ;; Responder
    (node-listen 4433 "my-node")
    (define ch (node-accept))
    (let ((msg (channel-recv ch)))
      (channel-send ch (process msg)))


------------------------------------------------------------------------
REFERENCES
------------------------------------------------------------------------

  * Karn, P. & Simpson, W. (1999). PHOTURIS. RFC 2522.
  * Karn, P. & Simpson, W. (1999). PHOTURIS Extended Schemes. RFC 2523.
  * Bernstein, D.J. (2006). Curve25519.
  * Bernstein, D.J. (2008). ChaCha20.
  * Memo-021: Capability Delegation
  * Memo-040: Security Architecture


------------------------------------------------------------------------
CHANGELOG
------------------------------------------------------------------------

- 2026-01-07: Initial specification

------------------------------------------------------------------------
