<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <title>Memo 0012: Federation Protocol</title>
  <link rel="icon" id="favicon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27%230f0%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>">
  <script>
(function(){
  var h=new Date().getHours(),c;
  if(h>=4&&h<6)c='%23845EC2';       // brahma muhurta - violet
  else if(h>=6&&h<8)c='%23ffd700';  // dawn - gold
  else if(h>=8&&h<11)c='%2300d4aa'; // morning - teal
  else if(h>=11&&h<14)c='%230f0';   // midday - phosphor
  else if(h>=14&&h<17)c='%2339ff14';// afternoon - neon
  else if(h>=17&&h<19)c='%23ff6600';// sunset - orange
  else if(h>=19&&h<22)c='%23ff3366';// evening - coral
  else c='%2300ffff';               // night - cyan
  document.getElementById('favicon').href='data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27'+c+'%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>';
})();
</script>
  <link rel="stylesheet" href="memo.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<h1>Memo 0012: Federation Protocol</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This Memo specifies the Federation Protocol for the Library of Cyberspace: a peer-to-peer synchronization system enabling loose confederacies of friends to share and preserve cryptographically sealed artifacts without central authority.</p>
</section>
<section>
<h2>E Pluribus Unum</h2>
<p>Out of many, one.</p>
<pre class="diagram">
    ┌─────────┐         ┌─────────┐         ┌─────────┐
    │  Alice  │◄───────►│   Bob   │◄───────►│  Carol  │
    │  Vault  │         │  Vault  │         │  Vault  │
    └────┬────┘         └────┬────┘         └────┬────┘
         │                   │                   │
         │    ┌──────────────┴──────────────┐    │
         │    │                             │    │
         └────►    No Central Authority    ◄────┘
              │                             │
              │   Just keys, seals, trust   │
              │                             │
              └─────────────────────────────┘
</pre>
</section>
<section>
<h2>Motivation</h2>
<p>Centralized systems fail:</p>
<ul>
<li>Single point of failure: Server goes down, everyone stops</li>
<li>Censorship: Authority can deny access</li>
<li>Trust concentration: Must trust operator</li>
<li>Survival: Company folds, data lost</li>
</ul>
<p>These failures are not bugs but features of centralized design; the only remedy is architectural, not operational.</p>
<p>Federation provides:</p>
<ul>
<li>Decentralized - No master server</li>
<li>Resilient - Survives node failures</li>
<li>Autonomous - Each peer controls own data</li>
<li>Cryptographic - Trust through math, not authority</li>
<li>Eventual consistency - Convergence without coordination</li>
</ul>
<p>Federation trades coordination complexity for availability and autonomy, accepting that nodes may temporarily disagree in exchange for never being unable to operate.</p>
</section>
<section>
<h2>Federation Model</h2>
<h3>Peer Relationships</h3>
<pre>
Peer: A vault instance with identity (SPKI principal)

Relationships:
  - Publisher:  I push releases to you
  - Subscriber: I pull releases from you
  - Peer:       Bidirectional sync
</pre>
<h3>Trust Model</h3>
<pre class="language-scheme">
(federation-trust
  (peer alice-pubkey
    (role publisher)
    (trust-level verified)     ; Signature verified
    (sync-policy automatic))

  (peer bob-pubkey
    (role subscriber)
    (trust-level known)        ; Key known, not verified
    (sync-policy manual)))
</pre>
<p>Trust levels: - unknown: Never seen, reject - known: Key registered, manual approval - verified: Signature chain verified via Simple Public Key Infrastructure (SPKI) - trusted: Full automatic sync</p>
</section>
<section>
<h2>Protocol Operations</h2>
<h3>Peer Discovery</h3>
<pre class="language-scheme">
(federation-discover)
;; Returns: List of known peers and their status
</pre>
<p>Discovery mechanisms:</p>
<ul>
<li>Explicit configuration: Known peer list</li>
<li>Git remotes: Extract from repository</li>
<li>Directory service: Optional, not required</li>
<li>mDNS/Bonjour: Local network discovery via cyberspace.tcp</li>
</ul>
<h3>mDNS Service Discovery</h3>
<p>Cyberspace nodes announce themselves via mDNS using the cyberspace.tcp service type:</p>
<pre class="language-scheme">
;; Announce this node
(announce-presence 'starlight)
;; Registers: starlight.cyberspace.tcp.local. port 7654

;; Discover peers
(discover-peers)
;; Scans for cyberspace.tcp services on local network
</pre>
<p>Platform support: - macOS: dns-sd -R for registration, dns-sd -B for browsing - Linux: avahi-publish for registration, avahi-browse for browsing</p>
<h3>Peer Registration</h3>
<pre class="language-scheme">
(federation-register peer-uri
  #!key public-key trust-level)
</pre>
<p>Registers a new peer with: - URI (git remote, HTTP endpoint, filesystem path) - Public key for verification - Initial trust level</p>
<h3>Release Announcement</h3>
<pre class="language-scheme">
(federation-announce version
  #!key peers message)
</pre>
<p>Pushes release notification to peers:</p>
<ul>
<li>Create signed announcement</li>
<li>Send to specified peers (or all)</li>
<li>Peers verify signature</li>
<li>Peers decide whether to pull</li>
</ul>
<h3>Release Request</h3>
<pre class="language-scheme">
(federation-request version peer
  #!key verify-key)
</pre>
<p>Pulls specific release from peer:</p>
<ul>
<li>Request release metadata</li>
<li>Verify signature</li>
<li>Download archive</li>
<li>Verify integrity</li>
<li>Record in audit trail</li>
</ul>
<h3>Synchronization</h3>
<pre class="language-scheme">
(federation-sync peer
  #!key direction verify-key)
</pre>
<p>Bidirectional sync (from Memo-0002):</p>
<ul>
<li>Exchange release lists</li>
<li>Identify missing releases</li>
<li>Push/pull as configured</li>
<li>Verify all signatures</li>
<li>Update audit trails</li>
</ul>
</section>
<section>
<h2>Message Format</h2>
<h3>Announcement Message</h3>
<pre class="language-scheme">
(federation-message
  (type announcement)
  (from #${alice-pubkey})
  (timestamp 1767685100)
  (payload
    (release "2.0.0")
    (hash "sha512:...")
    (archive-size 1048576)
    (notes "Major release"))
  (signature #${ed25519-sig}))
</pre>
<h3>Request Message</h3>
<pre class="language-scheme">
(federation-message
  (type request)
  (from #${bob-pubkey})
  (timestamp 1767685200)
  (payload
    (release "2.0.0")
    (format cryptographic))
  (signature #${ed25519-sig}))
</pre>
<h3>Response Message</h3>
<pre class="language-scheme">
(federation-message
  (type response)
  (from #${alice-pubkey})
  (in-reply-to "sha512:request-hash")
  (timestamp 1767685300)
  (payload
    (release "2.0.0")
    (archive-uri "/releases/vault-2.0.0.archive")
    (hash "sha512:...")
    (signature "ed25519:..."))
  (signature #${ed25519-sig}))
</pre>
</section>
<section>
<h2>Transport Bindings</h2>
<h3>Git Transport</h3>
<pre>
Origin: git@github.com:alice/vault.git
Mechanism: Tags + release assets

Announce: git push origin v2.0.0
Request:  git fetch origin --tags
Sync:     git fetch origin &amp;&amp; git push origin
</pre>
<h3>HTTP Transport</h3>
<pre>
Endpoint: https://alice.example.com/federation

Announce: POST /federation/announce
Request:  GET /federation/releases/2.0.0
Sync:     POST /federation/sync
</pre>
<h3>Filesystem Transport</h3>
<pre>
Path: /shared/federation/alice

Announce: Copy to /shared/federation/alice/announce/
Request:  Read from /shared/federation/alice/releases/
Sync:     rsync --update
</pre>
</section>
<section>
<h2>Conflict Resolution</h2>
<h3>Version Conflicts</h3>
<p>Same version, different content:</p>
<pre class="language-scheme">
(federation-conflict
  (version "2.0.0")
  (local-hash "sha512:abc...")
  (remote-hash "sha512:def...")
  (resolution reject))  ; Or: prefer-local, prefer-remote, rename
</pre>
<p>Default: Reject conflicts, require human decision.</p>
<h3>Resolution Strategies</h3>
<ul>
<li>Reject: Stop sync, alert human</li>
<li>Prefer-local: Keep local version</li>
<li>Prefer-remote: Take remote version</li>
<li>Rename: Keep both as 2.0.0-local, 2.0.0-remote</li>
<li>Merge: If content mergeable (future)</li>
</ul>
</section>
<section>
<h2>Consistency Model</h2>
<h3>Eventual Consistency</h3>
<ul>
<li>No global ordering required</li>
<li>Each peer has local view</li>
<li>Convergence through sync</li>
<li>Conflicts resolved locally</li>
</ul>
<h3>Causal Ordering</h3>
<p>Within a peer's releases: - Version numbers are monotonic - Audit trail provides causality - Hash chains prevent reordering</p>
<h3>No Coordination</h3>
<ul>
<li>No consensus protocol required</li>
<li>No distributed lock</li>
<li>No leader election</li>
<li>Each peer autonomous</li>
</ul>
</section>
<section>
<h2>Security Considerations</h2>
<h3>Threat Model</h3>
<p>Protected: - Unauthenticated release injection (signature verification) - Content tampering (hash verification) - Impersonation (SPKI principal binding) - Replay attacks (timestamps, sequence numbers)</p>
<p>Not protected: - Denial of service (rate limiting helps) - Privacy of release metadata (encrypted transport helps) - Sybil attacks (trust management helps)</p>
<h3>Trust Verification</h3>
<pre class="language-scheme">
(define (verify-peer-message msg peer-key)
  (and (verify-signature msg peer-key)
       (verify-timestamp msg (current-seconds))
       (verify-not-replayed msg)))
</pre>
<h3>Rate Limiting</h3>
<pre class="language-scheme">
(federation-config
  (rate-limit
    (announcements-per-hour 10)
    (requests-per-minute 60)
    (sync-interval-minimum 300)))
</pre>
</section>
<section>
<h2>Gossip Protocol (Future)</h2>
<p>For larger networks:</p>
<pre>
Alice announces to Bob and Carol
Bob announces to Dave and Eve
Eve announces to Frank

Result: Epidemic spread without central broadcast
</pre>
<p>Properties: - Logarithmic propagation time - Resilient to node failures - No single bottleneck</p>
</section>
<section>
<h2>Bootstrap Procedure</h2>
<h3>New Peer Joining</h3>
<ul>
<li>Generate keypair</li>
<li>Register with known peer</li>
<li>Exchange public keys (out-of-band verification)</li>
<li>Initial sync to get current releases</li>
<li>Begin participating in federation</li>
</ul>
<h3>Network Partitions</h3>
<ul>
<li>Partitions heal automatically on reconnection</li>
<li>Conflicting releases detected and flagged</li>
<li>Audit trails show partition history</li>
</ul>
</section>
<section>
<h2>Configuration</h2>
<pre class="language-scheme">
(federation-config
  ;; Identity
  (identity my-private-key)

  ;; Peers
  (peers
    (peer "alice" uri: "git@github.com:alice/vault.git"
                  key: alice-pubkey
                  trust: verified)
    (peer "bob"   uri: "/shared/bob-vault"
                  key: bob-pubkey
                  trust: known))

  ;; Policies
  (auto-sync #t)
  (sync-interval 3600)  ; seconds
  (verify-before-accept #t)

  ;; Security
  (require-signature #t)
  (trust-on-first-use #f))
</pre>
</section>
<section>
<h2>Implementation Status</h2>
<h3>Implemented (Memo-007)</h3>
<ul>
<li>seal-publish: Push to single remote - seal-subscribe: Pull from single remote - seal-synchronize: Bidirectional with single peer</li>
<li>Transport: git, HTTP, filesystem</li>
</ul>
<h3>Proposed (This Memo)</h3>
<ul>
<li>Multi-peer management</li>
<li>Trust levels and policies</li>
<li>Announcement protocol</li>
<li>Gossip propagation</li>
<li>Conflict resolution UI</li>
</ul>
</section>
<section>
<h2>References</h2>
<ul>
<li>Birman, K. (2007). The Promise, and Limitations, of Gossip Protocols.</li>
<li>Demers, A., et al. (1987). Epidemic Algorithms for Replicated Database Maintenance.</li>
<li>Shapiro, M., et al. (2011). Conflict-Free Replicated Data Types.</li>
<li>Memo-007: Replication Layer</li>
<li>Memo-003: SPKI Authorization</li>
</ul>
</section>
<section>
<h2>Changelog</h2>
<ul>
<li>2026-01-06</li>
<li>Initial specification</li>
</ul>
</section>
<script>
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
}
(function() {
  // Query param override (for REPL: ?theme=dark or ?theme=light)
  const params = new URLSearchParams(window.location.search);
  const param = params.get('theme');
  if (param === 'dark' || param === 'light') {
    document.documentElement.setAttribute('data-theme', param);
    localStorage.setItem('theme', param);
    return;
  }
  // localStorage preference
  const saved = localStorage.getItem('theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
  } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script>
</body>
</html>
