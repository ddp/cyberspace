<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <title>Memo 0035: Audit Log Protection</title>
  <link rel="icon" id="favicon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27%230f0%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>">
  <script>
(function(){
  var h=new Date().getHours(),c;
  if(h>=4&&h<6)c='%23845EC2';       // brahma muhurta - violet
  else if(h>=6&&h<8)c='%23ffd700';  // dawn - gold
  else if(h>=8&&h<11)c='%2300d4aa'; // morning - teal
  else if(h>=11&&h<14)c='%230f0';   // midday - phosphor
  else if(h>=14&&h<17)c='%2339ff14';// afternoon - neon
  else if(h>=17&&h<19)c='%23ff6600';// sunset - orange
  else if(h>=19&&h<22)c='%23ff3366';// evening - coral
  else c='%2300ffff';               // night - cyan
  document.getElementById('favicon').href='data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27'+c+'%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>';
})();
</script>
  <link rel="stylesheet" href="memo.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<h1>Memo 0035: Audit Log Protection</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This Memo specifies protection mechanisms for the Library of Cyberspace audit log: how the system prevents resource exhaustion, log flooding, and denial of service attacks against the audit trail while maintaining its integrity as the authoritative record of all vault operations.</p>
</section>
<section>
<h2>Motivation</h2>
<p>The audit log is sacred:</p>
<ul>
<li>Evidence</li>
<li>Legal and forensic record</li>
<li>Accountability</li>
<li>Who did what when</li>
<li>Recovery</li>
<li>Reconstruct state after failure</li>
<li>Trust</li>
<li>Foundation of the security model</li>
</ul>
<p>But the audit log is also a target:</p>
<ul>
<li>Flooding</li>
<li>Generate noise to hide malicious activity</li>
<li>Exhaustion</li>
<li>Fill storage to halt operations</li>
<li>Evasion</li>
<li>Overwhelm to prevent logging of real attacks</li>
<li>Amplification</li>
<li>Small action triggers large log entries</li>
</ul>
<p>The audit log must protect itself while never failing to record.</p>
</section>
<section>
<h2>Threat Model</h2>
<h3>Attack Vectors</h3>
<pre class="language-scheme">
(define audit-threats
  '((flooding
     (description "Generate massive log volume")
     (goal "Hide malicious activity in noise")
     (method "Rapid legitimate-looking operations"))

    (exhaustion
     (description "Fill audit storage")
     (goal "Halt vault operations")
     (method "Sustained high-volume logging"))

    (amplification
     (description "Small input, large log output")
     (goal "Asymmetric resource consumption")
     (method "Operations that log disproportionately"))

    (corruption
     (description "Tamper with log entries")
     (goal "Alter historical record")
     (method "Exploit write access to log storage"))

    (truncation
     (description "Force log rotation/deletion")
     (goal "Remove evidence")
     (method "Fill logs to trigger cleanup"))))
</pre>
<h3>Attacker Capabilities</h3>
<pre class="language-scheme">
;; Assume attacker can:
;; - Authenticate as a valid principal
;; - Perform many legitimate operations
;; - Control timing of operations
;; - Observe system behavior

;; Assume attacker cannot:
;; - Directly write to audit storage
;; - Forge signatures on log entries
;; - Break cryptographic primitives
</pre>
</section>
<section>
<h2>Rate Limiting</h2>
<h3>Per-Principal Audit Limits</h3>
<pre class="language-scheme">
(define audit-rate-limits
  `((entries-per-second . 100)
    (bytes-per-second . 102400)      ; 100KB/s
    (entries-per-minute . 1000)
    (bytes-per-minute . 10485760)))  ; 10MB/min

(define principal-audit-buckets (make-hash-table))

(define (get-audit-bucket principal)
  (or (hash-table-ref principal-audit-buckets principal #f)
      (let ((bucket (make-token-bucket
                     (assoc-ref audit-rate-limits 'entries-per-second)
                     (assoc-ref audit-rate-limits 'entries-per-second))))
        (hash-table-set! principal-audit-buckets principal bucket)
        bucket)))

(define (audit-rate-check principal entry-size)
  "Check if principal can generate audit entry"
  (let ((bucket (get-audit-bucket principal)))
    (bucket 1)))  ; Consume one token
</pre>
<h3>Audit Entry Costing</h3>
<pre class="language-scheme">
;; Different operations have different audit costs
(define audit-costs
  `((read . 1)
    (write . 2)
    (delete . 5)
    (query . 1)
    (admin . 10)
    (key-operation . 50)
    (emergency . 0)))  ; Always allowed

(define (audit-cost action)
  (or (assoc-ref audit-costs action) 1))

(define (consume-audit-budget principal action)
  "Deduct from principal's audit budget"
  (let ((cost (audit-cost action))
        (bucket (get-audit-bucket principal)))
    (if (bucket cost)
        #t
        (begin
          ;; Log the rate limit event (always succeeds)
          (audit-append-privileged
            action: 'audit-rate-limited
            principal: principal
            attempted-action: action)
          #f))))
</pre>
<h3>Burst Handling</h3>
<pre class="language-scheme">
;; Allow short bursts but limit sustained rate
(define (make-audit-limiter)
  (let ((short-term (make-token-bucket 200 100))   ; 100/s, burst 200
        (long-term (make-sliding-window 10000 60))) ; 10k/min
    (lambda (cost)
      (and (short-term cost)
           (long-term)))))
</pre>
</section>
<section>
<h2>Storage Protection</h2>
<h3>Reserved Audit Space</h3>
<pre class="language-scheme">
;; Always reserve space for audit
(define audit-reserved-space ( 1024 1024 1024))  ; 1GB minimum

(define (audit-storage-available)
  (let ((total (storage-available))
        (audit-used (audit-storage-used)))
    (max 0 (- total audit-reserved-space*))))

(define (check-audit-storage entry-size)
  "Ensure space for audit entry"
  (let ((available (audit-storage-available)))
    (when (&lt; available entry-size)
      ;; Emergency: halt non-audit operations
      (enter-audit-protection-mode)
      ;; But always log
      #t)))
</pre>
<h3>Audit Protection Mode</h3>
<pre class="language-scheme">
(define audit-protection-mode? (make-parameter #f))

(define (enter-audit-protection-mode)
  "Emergency mode: only allow audit writes"
  (audit-protection-mode? #t)
  (audit-append-privileged
    action: 'audit-protection-enabled
    reason: 'storage-exhaustion)
  ;; Reject all non-essential operations
  (set-vault-mode! 'audit-only))

(define (exit-audit-protection-mode)
  "Resume normal operations"
  (when (&gt; (audit-storage-available) ( 2 audit-reserved-space*))
    (audit-protection-mode? #f)
    (set-vault-mode! 'normal)
    (audit-append-privileged
      action: 'audit-protection-disabled)))
</pre>
<h3>Tiered Storage</h3>
<pre class="language-scheme">
;; Audit log tiers
(define audit-tiers
  '((hot . ((retention . 86400)      ; 1 day
            (storage . ssd)
            (compression . none)))
    (warm . ((retention . 604800)    ; 7 days
             (storage . hdd)
             (compression . zstd-fast)))
    (cold . ((retention . 31536000)  ; 1 year
             (storage . archive)
             (compression . zstd-max)))
    (glacier . ((retention . #f)     ; Forever
                (storage . offsite)
                (compression . zstd-max)))))

(define (tier-audit-entry entry age)
  "Move entry to appropriate storage tier"
  (let ((tier (find (lambda (t)
                      (or (not (assoc-ref (cdr t) 'retention))
                          (&lt; age (assoc-ref (cdr t) 'retention))))
                    audit-tiers)))
    (migrate-to-tier entry (car tier))))
</pre>
</section>
<section>
<h2>Entry Size Limits</h2>
<h3>Maximum Entry Size</h3>
<pre class="language-scheme">
(define max-audit-entry-size 65536)  ; 64KB

(define (validate-audit-entry entry)
  "Validate entry before logging"
  (let ((size (serialized-size entry)))
    (when (&gt; size max-audit-entry-size)
      (error 'audit-entry-too-large
             `((size . ,size)
               (limit . ,max-audit-entry-size))))))
</pre>
<h3>Entry Truncation</h3>
<pre class="language-scheme">
(define (truncate-audit-entry entry max-size)
  "Truncate oversized entry while preserving critical fields"
  (let ((critical '(action principal timestamp hash signature)))
    (let loop ((entry entry)
               (fields (entry-fields entry)))
      (if (&lt;= (serialized-size entry) max-size)
          entry
          (let ((removable (find (lambda (f)
                                   (not (member f critical)))
                                 fields)))
            (if removable
                (loop (assoc-remove entry removable)
                      (delete removable fields))
                ;; Can't truncate further, log warning
                (begin
                  (audit-append-privileged
                    action: 'audit-entry-truncation-failed
                    original-size: (serialized-size entry))
                  entry)))))))
</pre>
<h3>Payload Summarization</h3>
<pre class="language-scheme">
(define (summarize-large-payload payload)
  "Summarize large payloads for audit"
  (if (&gt; (bytevector-length payload) 1024)
      `((type . summarized)
        (original-size . ,(bytevector-length payload))
        (hash . ,(content-hash payload))
        (preview . ,(subbytevector payload 0 256)))
      payload))
</pre>
</section>
<section>
<h2>Aggregation</h2>
<h3>Event Aggregation</h3>
<pre class="language-scheme">
;; Aggregate similar events to reduce volume
(define aggregation-window 60)  ; seconds
(define pending-aggregations (make-hash-table))

(define (aggregate-audit-event action principal details)
  "Aggregate similar events within window"
  (let* ((key (list action principal))
         (existing (hash-table-ref pending-aggregations key #f)))
    (if existing
        ;; Add to existing aggregation
        (begin
          (set-cdr! (assoc 'count existing)
                    (+ 1 (assoc-ref existing 'count)))
          (set-cdr! (assoc 'last-seen existing)
                    (current-time)))
        ;; Start new aggregation
        (hash-table-set! pending-aggregations key
          `((action . ,action)
            (principal . ,principal)
            (count . 1)
            (first-seen . ,(current-time))
            (last-seen . ,(current-time))
            (sample . ,details))))))

(define (flush-aggregations)
  "Flush aggregated events to audit log"
  (hash-table-walk pending-aggregations
    (lambda (key agg)
      (when (&gt; (- (current-time) (assoc-ref agg 'first-seen))
               aggregation-window)
        (audit-append-direct
          action: 'aggregated-events
          original-action: (assoc-ref agg 'action)
          principal: (assoc-ref agg 'principal)
          count: (assoc-ref agg 'count)
          window-start: (assoc-ref agg 'first-seen)
          window-end: (assoc-ref agg 'last-seen)
          sample: (assoc-ref agg 'sample))
        (hash-table-delete! pending-aggregations key)))))
</pre>
<h3>Sampling</h3>
<pre class="language-scheme">
;; Sample high-volume events
(define (should-sample? action principal)
  (let ((rate (current-rate action principal)))
    (cond
      ((&lt; rate 10) #t)              ; Always log low-rate
      ((&lt; rate 100) (&lt; (random 1.0) 0.5))  ; 50% sample
      ((&lt; rate 1000) (&lt; (random 1.0) 0.1)) ; 10% sample
      (else (&lt; (random 1.0) 0.01)))))      ; 1% sample

(define (audit-with-sampling action principal details)
  "Log with sampling for high-volume events"
  (if (should-sample? action principal)
      (audit-append action: action
                    principal: principal
                    details: details
                    sampled: #t)
      ;; Still count for rate tracking
      (increment-audit-counter action principal)))
</pre>
</section>
<section>
<h2>Anomaly Detection</h2>
<h3>Baseline Establishment</h3>
<pre class="language-scheme">
(define (establish-audit-baseline principal duration)
  "Establish normal audit patterns for principal"
  (let ((events (soup-query type: 'audit-entry
                            principal: principal
                            timestamp: (&gt; (- (current-time) duration)))))
    `((events-per-hour . ,(/ (length events) (/ duration 3600)))
      (common-actions . ,(top-n (map audit-action events) 10))
      (typical-hours . ,(typical-active-hours events))
      (established-at . ,(current-time)))))
</pre>
<h3>Anomaly Detection</h3>
<pre class="language-scheme">
(define (detect-audit-anomaly principal current-rate baseline)
  "Detect anomalous audit patterns"
  (let ((expected (assoc-ref baseline 'events-per-hour))
        (threshold 3.0))  ; 3x normal is anomalous
    (when (&gt; current-rate ( threshold expected))
      (audit-append-privileged
        action: 'audit-anomaly-detected
        principal: principal
        current-rate: current-rate
        expected-rate: expected
        severity: (if (&gt; current-rate ( 10 expected))
                      'critical
                      'warning))
      ;; Potentially throttle
      (when (&gt; current-rate (* 10 expected))
        (throttle-principal principal)))))
</pre>
<h3>Flood Detection</h3>
<pre class="language-scheme">
(define (detect-audit-flood)
  "Detect system-wide audit flooding"
  (let ((current-rate (global-audit-rate))
        (threshold (* 10 (baseline-global-rate))))
    (when (&gt; current-rate threshold)
      ;; Identify top contributors
      (let ((top-principals (top-audit-principals 10)))
        (audit-append-privileged
          action: 'audit-flood-detected
          global-rate: current-rate
          threshold: threshold
          top-principals: top-principals)
        ;; Throttle top contributors
        (for-each throttle-principal
                  (map car top-principals))))))
</pre>
</section>
<section>
<h2>Privileged Logging</h2>
<h3>System Events</h3>
<pre class="language-scheme">
;; Some events bypass rate limits
(define privileged-actions
  '(audit-rate-limited
    audit-protection-enabled
    audit-protection-disabled
    audit-anomaly-detected
    audit-flood-detected
    key-ceremony
    emergency-revoke
    security-alert))

(define (audit-append-privileged . args)
  "Log privileged event (bypasses rate limits)"
  (let ((entry (apply make-audit-entry args)))
    ;; Always log, never rate limit
    (audit-write-direct entry)
    ;; Alert on privileged events
    (when (member (assoc-ref entry 'action) '(security-alert emergency-revoke))
      (send-security-alert entry))))
</pre>
<h3>Guaranteed Delivery</h3>
<pre class="language-scheme">
(define (audit-write-guaranteed entry)
  "Write audit entry with guaranteed delivery"
  ;; Write to multiple locations
  (let ((locations (list (primary-audit-log)
                         (secondary-audit-log)
                         (remote-audit-log))))
    (let ((successes (filter (lambda (loc)
                               (guard (ex (else #f))
                                 (audit-write loc entry)
                                 #t))
                             locations)))
      (when (&lt; (length successes) 2)
        ;; Failed to write to enough locations
        (emergency-audit-alert entry successes)))))
</pre>
</section>
<section>
<h2>Integrity Protection</h2>
<h3>Append-Only Enforcement</h3>
<pre class="language-scheme">
;; Audit log is strictly append-only
(define (audit-write entry)
  "Append entry to audit log"
  (let ((log (current-audit-log)))
    ;; Verify we're at the end
    (unless (at-log-end? log)
      (error 'audit-log-not-at-end))
    ;; Append with sequence number
    (let ((seq (next-sequence-number log)))
      (write-entry log (cons `(sequence . ,seq) entry))
      ;; Sign the entry
      (sign-entry log entry))))
</pre>
<h3>Chain Integrity</h3>
<pre class="language-scheme">
;; Each entry references previous (blockchain-style)
(define (chain-entry entry previous-hash)
  `((previous-hash . ,previous-hash)
    (sequence . ,(+ 1 (previous-sequence)))
    (timestamp . ,(current-time))
    ,@entry
    (hash . ,(compute-entry-hash entry previous-hash))))

(define (verify-audit-chain log)
  "Verify audit log chain integrity"
  (let loop ((entries (audit-entries log))
             (expected-prev #f))
    (if (null? entries)
        #t
        (let ((entry (car entries)))
          (and (or (not expected-prev)
                   (equal? (assoc-ref entry 'previous-hash) expected-prev))
               (loop (cdr entries)
                     (assoc-ref entry 'hash)))))))
</pre>
</section>
<section>
<h2>Recovery</h2>
<h3>Log Reconstruction</h3>
<pre class="language-scheme">
(define (reconstruct-audit-log backups)
  "Reconstruct audit log from multiple backups"
  (let ((entries (merge-backup-entries backups)))
    ;; Deduplicate by sequence number
    (let ((deduped (deduplicate-by-sequence entries)))
      ;; Verify chain
      (unless (verify-audit-chain deduped)
        (error 'audit-chain-broken))
      deduped)))
</pre>
<h3>Gap Detection</h3>
<pre class="language-scheme">
(define (detect-audit-gaps log)
  "Find gaps in audit sequence"
  (let loop ((entries (audit-entries log))
             (expected-seq 1)
             (gaps '()))
    (if (null? entries)
        gaps
        (let ((seq (assoc-ref (car entries) 'sequence)))
          (if (= seq expected-seq)
              (loop (cdr entries) (+ seq 1) gaps)
              (loop (cdr entries) (+ seq 1)
                    (cons (list expected-seq (- seq 1)) gaps)))))))
</pre>
</section>
<section>
<h2>References</h2>
<p>1. [NIST SP 800-92: Guide to Computer Security Log Management](https://csrc.nist.gov/publications/detail/sp/800-92/final) 2. [Memo-003: Cryptographic Audit Trail](memo-003-audit-trail.html) 3. [Memo-032: Rate Limiting and Quotas](memo-032-rate-limiting.html) 4. [Memo-028: Error Handling and Recovery](memo-028-error-handling.html)</p>
</section>
<section>
<h2>Changelog</h2>
<ul>
<li>2026-01-07</li>
<li>Initial draft</li>
</ul>
</section>
<script>
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
}
(function() {
  // Query param override (for REPL: ?theme=dark or ?theme=light)
  const params = new URLSearchParams(window.location.search);
  const param = params.get('theme');
  if (param === 'dark' || param === 'light') {
    document.documentElement.setAttribute('data-theme', param);
    localStorage.setItem('theme', param);
    return;
  }
  // localStorage preference
  const saved = localStorage.getItem('theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
  } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script>
</body>
</html>
