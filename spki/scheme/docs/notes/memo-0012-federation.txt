Memo 0012: Federation Protocol


------------------------------------------------------------------------

------------------------------------------------------------------------
ABSTRACT
------------------------------------------------------------------------

This Memo specifies the Federation Protocol for the Library of
Cyberspace: a peer-to-peer synchronization system enabling loose
confederacies of friends to share and preserve cryptographically sealed
artifacts without central authority.


------------------------------------------------------------------------
E PLURIBUS UNUM
------------------------------------------------------------------------

Out of many, one.


        ┌─────────┐         ┌─────────┐         ┌─────────┐
        │  Alice  │◄───────►│   Bob   │◄───────►│  Carol  │
        │  Vault  │         │  Vault  │         │  Vault  │
        └────┬────┘         └────┬────┘         └────┬────┘
             │                   │                   │
             │    ┌──────────────┴──────────────┐    │
             │    │                             │    │
             └────►    No Central Authority    ◄────┘
                  │                             │
                  │   Just keys, seals, trust   │
                  │                             │
                  └─────────────────────────────┘


------------------------------------------------------------------------
MOTIVATION
------------------------------------------------------------------------

Centralized systems fail:

  * Single point of failure: Server goes down, everyone stops
  * Censorship: Authority can deny access
  * Trust concentration: Must trust operator
  * Survival: Company folds, data lost

These failures are not bugs but features of centralized design; the only
remedy is architectural, not operational.

Federation provides:

  * Decentralized - No master server
  * Resilient - Survives node failures
  * Autonomous - Each peer controls own data
  * Cryptographic - Trust through math, not authority
  * Eventual consistency - Convergence without coordination

Federation trades coordination complexity for availability and autonomy,
accepting that nodes may temporarily disagree in exchange for never
being unable to operate.


------------------------------------------------------------------------
FEDERATION MODEL
------------------------------------------------------------------------


Peer Relationships
------------------


    Peer: A vault instance with identity (SPKI principal)
    Relationships:
      - Publisher:  I push releases to you
      - Subscriber: I pull releases from you
      - Peer:       Bidirectional sync


Trust Model
-----------


    (federation-trust
      (peer alice-pubkey
        (role publisher)
        (trust-level verified)     ; Signature verified
        (sync-policy automatic))
      (peer bob-pubkey
        (role subscriber)
        (trust-level known)        ; Key known, not verified
        (sync-policy manual)))

Trust levels: - unknown: Never seen, reject - known: Key registered,
manual approval - verified: Signature chain verified via Simple Public
Key Infrastructure (SPKI) - trusted: Full automatic sync


------------------------------------------------------------------------
PROTOCOL OPERATIONS
------------------------------------------------------------------------


Peer Discovery
--------------


    (federation-discover)
    ;; Returns: List of known peers and their status

Discovery mechanisms:

  * Explicit configuration: Known peer list
  * Git remotes: Extract from repository
  * Directory service: Optional, not required
  * mDNS/Bonjour: Local network discovery via cyberspace.tcp


mDNS Service Discovery
----------------------

Cyberspace nodes announce themselves via mDNS using the cyberspace.tcp
service type:


    ;; Announce this node
    (announce-presence 'starlight)
    ;; Registers: starlight.cyberspace.tcp.local. port 7654
    ;; Discover peers
    (discover-peers)
    ;; Scans for cyberspace.tcp services on local network

Platform support: - macOS: dns-sd -R for registration, dns-sd -B for
browsing - Linux: avahi-publish for registration, avahi-browse for
browsing


Peer Registration
-----------------


    (federation-register peer-uri
      #!key public-key trust-level)

Registers a new peer with: - URI (git remote, HTTP endpoint, filesystem
path) - Public key for verification - Initial trust level


Release Announcement
--------------------


    (federation-announce version
      #!key peers message)

Pushes release notification to peers:

  * Create signed announcement
  * Send to specified peers (or all)
  * Peers verify signature
  * Peers decide whether to pull


Release Request
---------------


    (federation-request version peer
      #!key verify-key)

Pulls specific release from peer:

  * Request release metadata
  * Verify signature
  * Download archive
  * Verify integrity
  * Record in audit trail


Synchronization
---------------


    (federation-sync peer
      #!key direction verify-key)

Bidirectional sync (from Memo-0002):

  * Exchange release lists
  * Identify missing releases
  * Push/pull as configured
  * Verify all signatures
  * Update audit trails


------------------------------------------------------------------------
MESSAGE FORMAT
------------------------------------------------------------------------


Announcement Message
--------------------


    (federation-message
      (type announcement)
      (from #${alice-pubkey})
      (timestamp 1767685100)
      (payload
        (release "2.0.0")
        (hash "sha512:...")
        (archive-size 1048576)
        (notes "Major release"))
      (signature #${ed25519-sig}))


Request Message
---------------


    (federation-message
      (type request)
      (from #${bob-pubkey})
      (timestamp 1767685200)
      (payload
        (release "2.0.0")
        (format cryptographic))
      (signature #${ed25519-sig}))


Response Message
----------------


    (federation-message
      (type response)
      (from #${alice-pubkey})
      (in-reply-to "sha512:request-hash")
      (timestamp 1767685300)
      (payload
        (release "2.0.0")
        (archive-uri "/releases/vault-2.0.0.archive")
        (hash "sha512:...")
        (signature "ed25519:..."))
      (signature #${ed25519-sig}))


------------------------------------------------------------------------
TRANSPORT BINDINGS
------------------------------------------------------------------------


Git Transport
-------------


    Origin: git@github.com:alice/vault.git
    Mechanism: Tags + release assets
    Announce: git push origin v2.0.0
    Request:  git fetch origin --tags
    Sync:     git fetch origin && git push origin


HTTP Transport
--------------


    Endpoint: https://alice.example.com/federation
    Announce: POST /federation/announce
    Request:  GET /federation/releases/2.0.0
    Sync:     POST /federation/sync


Filesystem Transport
--------------------


    Path: /shared/federation/alice
    Announce: Copy to /shared/federation/alice/announce/
    Request:  Read from /shared/federation/alice/releases/
    Sync:     rsync --update


------------------------------------------------------------------------
CONFLICT RESOLUTION
------------------------------------------------------------------------


Version Conflicts
-----------------

Same version, different content:


    (federation-conflict
      (version "2.0.0")
      (local-hash "sha512:abc...")
      (remote-hash "sha512:def...")
      (resolution reject))  ; Or: prefer-local, prefer-remote, rename

Default: Reject conflicts, require human decision.


Resolution Strategies
---------------------

  * Reject: Stop sync, alert human
  * Prefer-local: Keep local version
  * Prefer-remote: Take remote version
  * Rename: Keep both as 2.0.0-local, 2.0.0-remote
  * Merge: If content mergeable (future)


------------------------------------------------------------------------
CONSISTENCY MODEL
------------------------------------------------------------------------


Eventual Consistency
--------------------

  * No global ordering required
  * Each peer has local view
  * Convergence through sync
  * Conflicts resolved locally


Causal Ordering
---------------

Within a peer's releases: - Version numbers are monotonic - Audit trail
provides causality - Hash chains prevent reordering


No Coordination
---------------

  * No consensus protocol required
  * No distributed lock
  * No leader election
  * Each peer autonomous


------------------------------------------------------------------------
SECURITY CONSIDERATIONS
------------------------------------------------------------------------


Threat Model
------------

Protected: - Unauthenticated release injection (signature verification)
- Content tampering (hash verification) - Impersonation (SPKI principal
binding) - Replay attacks (timestamps, sequence numbers)

Not protected: - Denial of service (rate limiting helps) - Privacy of
release metadata (encrypted transport helps) - Sybil attacks (trust
management helps)


Trust Verification
------------------


    (define (verify-peer-message msg peer-key)
      (and (verify-signature msg peer-key)
           (verify-timestamp msg (current-seconds))
           (verify-not-replayed msg)))


Rate Limiting
-------------


    (federation-config
      (rate-limit
        (announcements-per-hour 10)
        (requests-per-minute 60)
        (sync-interval-minimum 300)))


------------------------------------------------------------------------
GOSSIP PROTOCOL (FUTURE)
------------------------------------------------------------------------

For larger networks:


    Alice announces to Bob and Carol
    Bob announces to Dave and Eve
    Eve announces to Frank
    Result: Epidemic spread without central broadcast

Properties: - Logarithmic propagation time - Resilient to node failures
- No single bottleneck


------------------------------------------------------------------------
BOOTSTRAP PROCEDURE
------------------------------------------------------------------------


New Peer Joining
----------------

  * Generate keypair
  * Register with known peer
  * Exchange public keys (out-of-band verification)
  * Initial sync to get current releases
  * Begin participating in federation


Network Partitions
------------------

  * Partitions heal automatically on reconnection
  * Conflicting releases detected and flagged
  * Audit trails show partition history


------------------------------------------------------------------------
CONFIGURATION
------------------------------------------------------------------------


    (federation-config
      ;; Identity
      (identity my-private-key)
      ;; Peers
      (peers
        (peer "alice" uri: "git@github.com:alice/vault.git"
                      key: alice-pubkey
                      trust: verified)
        (peer "bob"   uri: "/shared/bob-vault"
                      key: bob-pubkey
                      trust: known))
      ;; Policies
      (auto-sync #t)
      (sync-interval 3600)  ; seconds
      (verify-before-accept #t)
      ;; Security
      (require-signature #t)
      (trust-on-first-use #f))


------------------------------------------------------------------------
MULTI-PEER MANAGEMENT
------------------------------------------------------------------------


Peer Registry
-------------

Each vault maintains a local peer registry mapping identities to
connection metadata:


    (define-record-type peer
      (make-peer id pubkey uri trust-level last-seen sync-state)
      peer?
      (id peer-id)                    ; Human-readable name
      (pubkey peer-pubkey)            ; SPKI principal (Ed25519 public key)
      (uri peer-uri)                  ; Connection URI (git, http, file)
      (trust-level peer-trust-level)  ; unknown|known|verified|trusted
      (last-seen peer-last-seen)      ; Unix timestamp of last contact
      (sync-state peer-sync-state))   ; idle|syncing|error

The registry persists in `.vault/peers.scm` as a simple alist.


Peer Lifecycle
--------------


    ┌─────────┐   register   ┌─────────┐   verify   ┌──────────┐   trust   ┌─────────┐
    │ unknown │────────────►│  known  │──────────►│ verified │─────────►│ trusted │
    └─────────┘             └─────────┘           └──────────┘          └─────────┘
         ▲                       │                      │                    │
         │                       │ expire               │ revoke             │ revoke
         │                       ▼                      ▼                    ▼
         └───────────────────────┴──────────────────────┴────────────────────┘


    ;; Add peer (starts as 'known')
    (peer-register! "alice"
      uri: "git@github.com:alice/vault.git"
      pubkey: alice-ed25519-pubkey)
    ;; Verify via SPKI cert chain
    (peer-verify! "alice" cert-chain)
    ;; Promote to trusted (enables auto-sync)
    (peer-trust! "alice")
    ;; Revoke (demotes to unknown, blocks sync)
    (peer-revoke! "alice")
    ;; Remove entirely
    (peer-remove! "alice")


Peer Groups
-----------

Peers can be organized into groups for bulk operations:


    (peer-group-create! 'family
      '("alice" "bob" "carol"))
    (peer-group-create! 'work
      '("dave" "eve"))
    ;; Sync to entire group
    (federation-sync-group 'family)
    ;; Announce to multiple groups
    (federation-announce "v2.0.0"
      groups: '(family work))

Groups are purely local organizational constructs with no protocol-level
significance.


------------------------------------------------------------------------
TRUST LEVELS AND POLICIES
------------------------------------------------------------------------


Trust Hierarchy
---------------


    Level      │ Signature │ Auto-Sync │ Announce │ Description
    ───────────┼───────────┼───────────┼──────────┼─────────────────────────
    unknown    │ reject    │ no        │ ignore   │ Never seen, no key on file
    known      │ verify    │ no        │ queue    │ Key registered, manual ops
    verified   │ verify    │ manual    │ notify   │ SPKI chain verified
    trusted    │ verify    │ automatic │ accept   │ Full bidirectional sync

Trust is not transitive: Alice trusting Bob does not imply Alice trusts
Bob's peers.


Trust Policies
--------------


    (federation-policy
      ;; How to handle first contact
      (first-contact
        (action prompt)           ; prompt|reject|tofu
        (tofu-window 300))        ; TOFU valid for 5 minutes
      ;; Signature requirements
      (signatures
        (require-on-announce #t)
        (require-on-sync #t)
        (require-on-request #t))
      ;; Automatic trust promotion
      (auto-promote
        (known->verified #f)      ; Require explicit verification
        (verified->trusted #f))   ; Require explicit trust grant
      ;; Trust decay
      (decay
        (trusted-idle-days 90)    ; Demote trusted->verified after 90 days idle
        (verified-idle-days 180)  ; Demote verified->known after 180 days idle
        (known-idle-days 365)))   ; Remove known after 1 year idle


SPKI Certificate Verification
-----------------------------

Trust verification uses SPKI certificate chains (Memo-003):


    (define (peer-verify! peer-id cert-chain)
      "Verify peer via SPKI certificate chain"
      (let* ((peer (peer-lookup peer-id))
             (pubkey (peer-pubkey peer))
             (valid? (spki-verify-chain cert-chain pubkey (current-seconds))))
        (when valid?
          (peer-set-trust-level! peer-id 'verified)
          (audit-log! 'peer-verified peer-id cert-chain))
        valid?))


------------------------------------------------------------------------
ANNOUNCEMENT PROTOCOL
------------------------------------------------------------------------


Message Flow
------------


    Announcer                          Receiver
        │                                  │
        │  ┌─────────────────────────┐     │
        ├──│ ANNOUNCE v2.0.0         │────►│
        │  │ hash: sha512:abc...     │     │
        │  │ size: 1048576           │     │
        │  │ sig: ed25519:...        │     │
        │  └─────────────────────────┘     │
        │                                  │
        │  ┌─────────────────────────┐     │
        │◄─│ ACK                     │─────┤ (if trusted)
        │  │ status: accepted        │     │
        │  │ sig: ed25519:...        │     │
        │  └─────────────────────────┘     │
        │                                  │
        │  ┌─────────────────────────┐     │
        │◄─│ REQUEST v2.0.0          │─────┤ (pull follows)
        │  └─────────────────────────┘     │

Receivers at different trust levels handle announcements differently:

  * trusted: Auto-ACK, auto-request
  * verified: Notify user, queue for manual approval
  * known: Queue silently, require explicit sync
  * unknown: Ignore (log for audit)


Announcement Message
--------------------


    (define-record-type announcement
      (make-announcement version hash size notes timestamp signature)
      announcement?
      (version announcement-version)      ; Semantic version string
      (hash announcement-hash)            ; Content hash (sha512)
      (size announcement-size)            ; Archive size in bytes
      (notes announcement-notes)          ; Release notes (optional)
      (timestamp announcement-timestamp)  ; Unix timestamp
      (signature announcement-signature)) ; Ed25519 signature over above


    (define (federation-announce version #!key peers groups notes)
      "Announce release to peers"
      (let* ((release (release-lookup version))
             (msg (make-announcement
                    version
                    (release-hash release)
                    (release-size release)
                    (or notes "")
                    (current-seconds)
                    #f))  ; Signature added below
             (signed (sign-announcement msg (vault-private-key))))
        (for-each
          (lambda (peer)
            (send-announcement peer signed))
          (resolve-recipients peers groups))))


Retries and Timeouts
--------------------


    (federation-config
      (announce
        (timeout-seconds 30)       ; Per-peer timeout
        (retry-count 3)            ; Retries on failure
        (retry-backoff-base 5)     ; 5, 10, 20 seconds
        (parallel-sends 5)))       ; Concurrent announcements

Failed announcements are logged and can be retried manually via
`(federation-retry-failed)`.


------------------------------------------------------------------------
GOSSIP PROPAGATION
------------------------------------------------------------------------


Epidemic Broadcast
------------------

For networks larger than a handful of peers, direct announcement to all
peers doesn't scale. Gossip provides O(log N) propagation:


    Round 0: Alice announces to 3 random peers (fanout=3)
             Alice ──► Bob, Carol, Dave
    Round 1: Bob, Carol, Dave each forward to 3 random peers
             Bob ──► Eve, Frank, Grace
             Carol ──► Henry, Eve, Ivan    (Eve receives duplicate)
             Dave ──► Grace, Julia, Karl   (Grace receives duplicate)
    Round 2: Continue until TTL expires or all peers reached


    (federation-gossip-config
      (fanout 3)              ; Forward to N random peers
      (ttl 5)                 ; Maximum hops
      (dedup-window 3600))    ; Ignore duplicates within 1 hour


Gossip Message
--------------


    (define-record-type gossip-envelope
      (make-gossip-envelope origin hop-count ttl seen payload)
      gossip-envelope?
      (origin gossip-origin)        ; Original announcer pubkey
      (hop-count gossip-hop-count)  ; Current hop count
      (ttl gossip-ttl)              ; Time-to-live (max hops)
      (seen gossip-seen)            ; Set of peer pubkeys who've seen this
      (payload gossip-payload))     ; The announcement


    (define (gossip-forward! envelope)
      "Forward gossip to random subset of peers"
      (when (< (gossip-hop-count envelope) (gossip-ttl envelope))
        (let* ((candidates (filter
                             (lambda (p)
                               (and (>= (peer-trust-level p) 'known)
                                    (not (member (peer-pubkey p) (gossip-seen envelope)))))
                             (peer-list)))
               (targets (take-random candidates (gossip-fanout))))
          (for-each
            (lambda (peer)
              (send-gossip peer
                (make-gossip-envelope
                  (gossip-origin envelope)
                  (+ 1 (gossip-hop-count envelope))
                  (gossip-ttl envelope)
                  (cons (my-pubkey) (gossip-seen envelope))
                  (gossip-payload envelope))))
            targets))))


Protocol Properties
-------------------

  * Distributed: No coordinator, any peer can initiate
  * Resilient: Survives peer failures, duplicates handled
  * Scalable: O(log N) rounds to reach N peers
  * Tunable: Fanout and TTL control spread vs traffic
  * Eventually consistent: All connected peers converge


------------------------------------------------------------------------
CONFLICT RESOLUTION UI
------------------------------------------------------------------------


Conflict Types
--------------


    Type            │ Cause                           │ Default Resolution
    ────────────────┼─────────────────────────────────┼───────────────────────
    version-hash    │ Same version, different content │ Prompt user
    fork            │ Divergent version histories     │ Prompt user
    rollback        │ Remote has older than local     │ Reject
    timestamp       │ Timestamps significantly skewed │ Warn, proceed

All conflicts are logged to the audit trail regardless of resolution.


Interactive Resolution
----------------------


    ;; When conflict detected, present choices:
    (define (resolve-conflict! conflict)
      (let* ((type (conflict-type conflict))
             (local (conflict-local conflict))
             (remote (conflict-remote conflict))
             (choice (prompt-conflict type local remote)))
        (case choice
          ((keep-local)
           (audit-log! 'conflict-resolved conflict 'keep-local))
          ((take-remote)
           (import-release! (conflict-remote-release conflict))
           (audit-log! 'conflict-resolved conflict 'take-remote))
          ((keep-both)
           (rename-release! local (string-append (release-version local) "-local"))
           (import-release! (conflict-remote-release conflict))
           (audit-log! 'conflict-resolved conflict 'keep-both))
          ((defer)
           (queue-conflict! conflict)
           (audit-log! 'conflict-deferred conflict)))))


    ┌──────────────────────────────────────────────────────────────┐
    │                    CONFLICT DETECTED                         │
    ├──────────────────────────────────────────────────────────────┤
    │  Version: 2.0.0                                              │
    │                                                              │
    │  Local:   sha512:abc123... (2026-01-15 14:30)               │
    │  Remote:  sha512:def456... (2026-01-15 14:35) from alice    │
    │                                                              │
    │  [1] Keep local version                                      │
    │  [2] Take remote version                                     │
    │  [3] Keep both (rename local to 2.0.0-local)                │
    │  [4] Defer decision                                          │
    │  [5] Show diff                                               │
    │                                                              │
    │  Choice: _                                                   │
    └──────────────────────────────────────────────────────────────┘


Automatic Resolution Policies
-----------------------------


    (federation-config
      (conflict-resolution
        ;; For trusted peers, can enable auto-resolution
        (trusted-peer-wins #f)      ; Auto-accept from trusted
        (newer-timestamp-wins #f)   ; Dangerous: clock skew
        (larger-version-wins #f)    ; Only for semver conflicts
        ;; Always prompt for these
        (always-prompt-on
          '(version-hash fork rollback))))

Automatic resolution is discouraged for hash conflicts; cryptographic
seals exist precisely to detect tampering, and automatic resolution
defeats this purpose.


------------------------------------------------------------------------
IMPLEMENTATION STATUS
------------------------------------------------------------------------


Implemented (Memo-007)
----------------------

  * seal-publish: Push to single remote
  * seal-subscribe: Pull from single remote
  * seal-synchronize: Bidirectional with single peer
  * Transport: git, HTTP, filesystem


Specified (This Memo)
---------------------

  * Multi-peer registry and lifecycle
  * Trust levels: unknown, known, verified, trusted
  * Trust policies and SPKI verification
  * Announcement protocol with ACK/retry
  * Gossip epidemic broadcast
  * Conflict detection and resolution UI


Future Work
-----------

  * Peer reputation scoring
  * Bandwidth-aware sync scheduling
  * Partial sync (subset of releases)
  * Encrypted peer-to-peer channels


------------------------------------------------------------------------
REFERENCES
------------------------------------------------------------------------

  * Birman, K. (2007). The Promise, and Limitations, of Gossip Protocols.
  * Demers, A., et al. (1987). Epidemic Algorithms for Replicated Database Maintenance.
  * Shapiro, M., et al. (2011). Conflict-Free Replicated Data Types.
  * Memo-007: Replication Layer
  * Memo-003: SPKI Authorization


------------------------------------------------------------------------
CHANGELOG
------------------------------------------------------------------------

  * 2026-01-31: Flesh out multi-peer management, trust policies, announcement protocol, gossip propagation, and conflict resolution UI
  * 2026-01-06: Initial specification

------------------------------------------------------------------------
