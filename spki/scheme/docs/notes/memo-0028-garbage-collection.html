<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <title>Memo 0028: Garbage Collection</title>
  <link rel="icon" id="favicon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27%230f0%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>">
  <script>
(function(){
  var h=new Date().getHours(),c;
  if(h>=4&&h<6)c='%23845EC2';       // brahma muhurta - violet
  else if(h>=6&&h<8)c='%23ffd700';  // dawn - gold
  else if(h>=8&&h<11)c='%2300d4aa'; // morning - teal
  else if(h>=11&&h<14)c='%230f0';   // midday - phosphor
  else if(h>=14&&h<17)c='%2339ff14';// afternoon - neon
  else if(h>=17&&h<19)c='%23ff6600';// sunset - orange
  else if(h>=19&&h<22)c='%23ff3366';// evening - coral
  else c='%2300ffff';               // night - cyan
  document.getElementById('favicon').href='data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27'+c+'%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>';
})();
</script>
  <link rel="stylesheet" href="memo.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<h1>Memo 0028: Garbage Collection</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This Memo specifies garbage collection for the Library of Cyberspace: how vaults identify and reclaim storage from unreferenced objects while preserving pinned content, respecting tombstones, and maintaining audit trails. Content-addressed storage requires careful GC to avoid data loss.</p>
<p>The Library of Cyberspace is an archival system. The default is preservation, not collection. Objects evaporate only with explicit consent.</p>
</section>
<section>
<h2>Philosophy: The Soup Preserves</h2>
<p>The soup is not a runtime heap. It is a library.</p>
<p>In runtime garbage collection, the goal is to reclaim memory quickly. Young objects die young. Old objects survive. Collect aggressively.</p>
<p>In archival garbage collection, the opposite holds:</p>
<ul>
<li>Old objects are precious</li>
<li>They have survived, been referenced, replicated</li>
<li>Young objects are suspect</li>
<li>They may be transient, failed, or temporary</li>
<li>Deletion is violence</li>
<li>Once collected, an object is gone from this vault forever</li>
<li>Preservation is the default</li>
<li>When in doubt, keep it</li>
</ul>
<p>This inverts the runtime GC assumption that most objects die young; in an archive, age confers value.</p>
<p>The Library of Alexandria burned once. We will not let it burn again.</p>
</section>
<section>
<h2>Motivation</h2>
<p>Content-addressed storage accumulates objects forever unless actively pruned:</p>
<ul>
<li>Orphaned objects</li>
<li>No longer referenced by any root</li>
<li>Superseded versions</li>
<li>Old versions after updates</li>
<li>Failed uploads</li>
<li>Partial or abandoned writes</li>
<li>Temporary objects</li>
<li>Intermediate computation results</li>
</ul>
<p>Without collection, storage grows without bound; the question is not whether to collect but how conservatively.</p>
<p>But deletion is dangerous:</p>
<ul>
<li>Hash as capability</li>
<li>Someone may hold the hash</li>
<li>Lazy replication</li>
<li>Remote vaults may need it later</li>
<li>Audit requirements</li>
<li>May need historical data</li>
<li>Resurrection</li>
<li>Deleted objects may be re-added</li>
</ul>
<p>Each risk represents a real failure mode; premature collection has caused data loss in every major distributed system.</p>
<p>GC must be conservative, consensual, and auditable.</p>
<p>The default is: never collect. Collection requires explicit action.</p>
</section>
<section>
<h2>Object Lifecycle</h2>
<h3>States</h3>
<div class="diagram-container">
<svg class="diagram" viewBox="0 0 420 360" width="420" height="360" xmlns="http://www.w3.org/2000/svg">
<style>
  .diagram line { stroke: currentColor; stroke-width: 1.5; stroke-linecap: square; }
  .diagram rect { fill: currentColor; }
  .diagram text { font-family: 'JetBrains Mono', monospace; font-size: 14px; fill: currentColor; dominant-baseline: central; }
</style>
<line x1="205" y1="10" x2="210" y2="10"/>
<line x1="205" y1="10" x2="205" y2="21"/>
<line x1="210" y1="10" x2="220" y2="10"/>
<line x1="220" y1="10" x2="230" y2="10"/>
<line x1="230" y1="10" x2="240" y2="10"/>
<line x1="240" y1="10" x2="250" y2="10"/>
<line x1="250" y1="10" x2="260" y2="10"/>
<line x1="260" y1="10" x2="270" y2="10"/>
<line x1="270" y1="10" x2="280" y2="10"/>
<line x1="280" y1="10" x2="290" y2="10"/>
<line x1="290" y1="10" x2="300" y2="10"/>
<line x1="300" y1="10" x2="305" y2="10"/>
<line x1="305" y1="10" x2="305" y2="21"/>
<text x="100" y="30">write</text>
<line x1="205" y1="19" x2="205" y2="41"/>
<line x1="305" y1="19" x2="305" y2="41"/>
<line x1="80" y1="50" x2="90" y2="50"/>
<line x1="90" y1="50" x2="100" y2="50"/>
<line x1="100" y1="50" x2="110" y2="50"/>
<line x1="110" y1="50" x2="120" y2="50"/>
<line x1="120" y1="50" x2="130" y2="50"/>
<line x1="130" y1="50" x2="140" y2="50"/>
<line x1="140" y1="50" x2="150" y2="50"/>
<line x1="150" y1="50" x2="160" y2="50"/>
<line x1="160" y1="50" x2="170" y2="50"/>
<line x1="205" y1="39" x2="205" y2="61"/>
<text x="230" y="50">LIVE</text>
<line x1="305" y1="39" x2="305" y2="61"/>
<line x1="205" y1="59" x2="205" y2="81"/>
<line x1="305" y1="59" x2="305" y2="81"/>
<line x1="205" y1="90" x2="210" y2="90"/>
<line x1="205" y1="79" x2="205" y2="90"/>
<line x1="210" y1="90" x2="220" y2="90"/>
<line x1="220" y1="90" x2="230" y2="90"/>
<line x1="230" y1="90" x2="240" y2="90"/>
<line x1="240" y1="90" x2="250" y2="90"/>
<line x1="250" y1="90" x2="260" y2="90"/>
<line x1="255" y1="90" x2="255" y2="101"/>
<line x1="260" y1="90" x2="270" y2="90"/>
<line x1="270" y1="90" x2="280" y2="90"/>
<line x1="280" y1="90" x2="290" y2="90"/>
<line x1="290" y1="90" x2="300" y2="90"/>
<line x1="300" y1="90" x2="305" y2="90"/>
<line x1="305" y1="79" x2="305" y2="90"/>
<line x1="255" y1="99" x2="255" y2="121"/>
<line x1="145" y1="130" x2="150" y2="130"/>
<line x1="145" y1="130" x2="145" y2="141"/>
<line x1="150" y1="130" x2="160" y2="130"/>
<line x1="160" y1="130" x2="170" y2="130"/>
<line x1="170" y1="130" x2="180" y2="130"/>
<line x1="180" y1="130" x2="190" y2="130"/>
<line x1="190" y1="130" x2="200" y2="130"/>
<line x1="200" y1="130" x2="210" y2="130"/>
<line x1="210" y1="130" x2="220" y2="130"/>
<line x1="220" y1="130" x2="230" y2="130"/>
<line x1="230" y1="130" x2="240" y2="130"/>
<line x1="240" y1="130" x2="250" y2="130"/>
<line x1="250" y1="130" x2="260" y2="130"/>
<line x1="255" y1="119" x2="255" y2="141"/>
<line x1="260" y1="130" x2="270" y2="130"/>
<line x1="270" y1="130" x2="280" y2="130"/>
<line x1="280" y1="130" x2="290" y2="130"/>
<line x1="290" y1="130" x2="300" y2="130"/>
<line x1="300" y1="130" x2="310" y2="130"/>
<line x1="310" y1="130" x2="320" y2="130"/>
<line x1="320" y1="130" x2="330" y2="130"/>
<line x1="330" y1="130" x2="340" y2="130"/>
<line x1="340" y1="130" x2="350" y2="130"/>
<line x1="350" y1="130" x2="360" y2="130"/>
<line x1="360" y1="130" x2="365" y2="130"/>
<line x1="365" y1="130" x2="365" y2="141"/>
<line x1="145" y1="139" x2="145" y2="161"/>
<line x1="255" y1="139" x2="255" y2="161"/>
<line x1="365" y1="139" x2="365" y2="161"/>
<line x1="95" y1="190" x2="100" y2="190"/>
<line x1="95" y1="190" x2="95" y2="201"/>
<line x1="100" y1="190" x2="110" y2="190"/>
<line x1="110" y1="190" x2="120" y2="190"/>
<line x1="120" y1="190" x2="130" y2="190"/>
<line x1="130" y1="190" x2="140" y2="190"/>
<line x1="140" y1="190" x2="150" y2="190"/>
<line x1="150" y1="190" x2="160" y2="190"/>
<line x1="160" y1="190" x2="170" y2="190"/>
<line x1="170" y1="190" x2="180" y2="190"/>
<line x1="180" y1="190" x2="185" y2="190"/>
<line x1="185" y1="190" x2="185" y2="201"/>
<line x1="205" y1="190" x2="210" y2="190"/>
<line x1="205" y1="190" x2="205" y2="201"/>
<line x1="210" y1="190" x2="220" y2="190"/>
<line x1="220" y1="190" x2="230" y2="190"/>
<line x1="230" y1="190" x2="240" y2="190"/>
<line x1="240" y1="190" x2="250" y2="190"/>
<line x1="250" y1="190" x2="260" y2="190"/>
<line x1="260" y1="190" x2="270" y2="190"/>
<line x1="270" y1="190" x2="280" y2="190"/>
<line x1="280" y1="190" x2="290" y2="190"/>
<line x1="290" y1="190" x2="295" y2="190"/>
<line x1="295" y1="190" x2="295" y2="201"/>
<line x1="315" y1="190" x2="320" y2="190"/>
<line x1="315" y1="190" x2="315" y2="201"/>
<line x1="320" y1="190" x2="330" y2="190"/>
<line x1="330" y1="190" x2="340" y2="190"/>
<line x1="340" y1="190" x2="350" y2="190"/>
<line x1="350" y1="190" x2="360" y2="190"/>
<line x1="360" y1="190" x2="370" y2="190"/>
<line x1="370" y1="190" x2="380" y2="190"/>
<line x1="380" y1="190" x2="390" y2="190"/>
<line x1="390" y1="190" x2="400" y2="190"/>
<line x1="400" y1="190" x2="405" y2="190"/>
<line x1="405" y1="190" x2="405" y2="201"/>
<line x1="95" y1="199" x2="95" y2="221"/>
<text x="100" y="210">PINNED</text>
<line x1="185" y1="199" x2="185" y2="221"/>
<line x1="205" y1="199" x2="205" y2="221"/>
<text x="210" y="210">TOMBSTONE</text>
<line x1="305" y1="199" x2="305" y2="221"/>
<line x1="325" y1="199" x2="325" y2="221"/>
<text x="330" y="210">ORPHANED</text>
<line x1="415" y1="199" x2="415" y2="221"/>
<line x1="95" y1="230" x2="100" y2="230"/>
<line x1="95" y1="219" x2="95" y2="230"/>
<line x1="100" y1="230" x2="110" y2="230"/>
<line x1="110" y1="230" x2="120" y2="230"/>
<line x1="120" y1="230" x2="130" y2="230"/>
<line x1="130" y1="230" x2="140" y2="230"/>
<line x1="140" y1="230" x2="150" y2="230"/>
<line x1="150" y1="230" x2="160" y2="230"/>
<line x1="160" y1="230" x2="170" y2="230"/>
<line x1="170" y1="230" x2="180" y2="230"/>
<line x1="180" y1="230" x2="185" y2="230"/>
<line x1="185" y1="219" x2="185" y2="230"/>
<line x1="205" y1="230" x2="210" y2="230"/>
<line x1="205" y1="219" x2="205" y2="230"/>
<line x1="210" y1="230" x2="220" y2="230"/>
<line x1="220" y1="230" x2="230" y2="230"/>
<line x1="230" y1="230" x2="240" y2="230"/>
<line x1="240" y1="230" x2="250" y2="230"/>
<line x1="250" y1="230" x2="260" y2="230"/>
<line x1="260" y1="230" x2="270" y2="230"/>
<line x1="270" y1="230" x2="280" y2="230"/>
<line x1="280" y1="230" x2="290" y2="230"/>
<line x1="290" y1="230" x2="295" y2="230"/>
<line x1="295" y1="219" x2="295" y2="230"/>
<line x1="315" y1="230" x2="320" y2="230"/>
<line x1="315" y1="219" x2="315" y2="230"/>
<line x1="320" y1="230" x2="330" y2="230"/>
<line x1="330" y1="230" x2="340" y2="230"/>
<line x1="340" y1="230" x2="350" y2="230"/>
<line x1="350" y1="230" x2="360" y2="230"/>
<line x1="355" y1="230" x2="355" y2="241"/>
<line x1="360" y1="230" x2="370" y2="230"/>
<line x1="370" y1="230" x2="380" y2="230"/>
<line x1="380" y1="230" x2="390" y2="230"/>
<line x1="390" y1="230" x2="400" y2="230"/>
<line x1="400" y1="230" x2="405" y2="230"/>
<line x1="405" y1="219" x2="405" y2="230"/>
<line x1="355" y1="239" x2="355" y2="261"/>
<line x1="355" y1="259" x2="355" y2="281"/>
<text x="370" y="270">GC</text>
<line x1="305" y1="310" x2="310" y2="310"/>
<line x1="305" y1="310" x2="305" y2="321"/>
<line x1="310" y1="310" x2="320" y2="310"/>
<line x1="320" y1="310" x2="330" y2="310"/>
<line x1="330" y1="310" x2="340" y2="310"/>
<line x1="340" y1="310" x2="350" y2="310"/>
<line x1="350" y1="310" x2="360" y2="310"/>
<line x1="360" y1="310" x2="370" y2="310"/>
<line x1="370" y1="310" x2="380" y2="310"/>
<line x1="380" y1="310" x2="390" y2="310"/>
<line x1="390" y1="310" x2="395" y2="310"/>
<line x1="395" y1="310" x2="395" y2="321"/>
<line x1="305" y1="319" x2="305" y2="341"/>
<text x="310" y="330">COLLECTED</text>
<line x1="405" y1="319" x2="405" y2="341"/>
<line x1="305" y1="350" x2="310" y2="350"/>
<line x1="305" y1="339" x2="305" y2="350"/>
<line x1="310" y1="350" x2="320" y2="350"/>
<line x1="320" y1="350" x2="330" y2="350"/>
<line x1="330" y1="350" x2="340" y2="350"/>
<line x1="340" y1="350" x2="350" y2="350"/>
<line x1="350" y1="350" x2="360" y2="350"/>
<line x1="360" y1="350" x2="370" y2="350"/>
<line x1="370" y1="350" x2="380" y2="350"/>
<line x1="380" y1="350" x2="390" y2="350"/>
<line x1="390" y1="350" x2="395" y2="350"/>
<line x1="395" y1="339" x2="395" y2="350"/>
</svg>
</div>
<h3>State Transitions</h3>
<pre class="language-scheme">
(define (object-state hash)
  (cond
    ((pinned? hash) 'pinned)
    ((tombstoned? hash) 'tombstone)
    ((referenced? hash) 'live)
    (else 'orphaned)))

(define (can-collect? hash)
  (and (eq? (object-state hash) 'orphaned)
       (not (in-grace-period? hash))
       (not (pending-replication? hash))))
</pre>
</section>
<section>
<h2>Reference Counting</h2>
<h3>Direct References</h3>
<pre class="language-scheme">
;; Track incoming references
(define ref-counts (make-hash-table))

(define (add-reference from-hash to-hash)
  (let ((count (hash-table-ref ref-counts to-hash 0)))
    (hash-table-set! ref-counts to-hash (+ count 1))
    (audit-append action: (add-ref ,from-hash ,to-hash))))

(define (remove-reference from-hash to-hash)
  (let ((count (hash-table-ref ref-counts to-hash 0)))
    (hash-table-set! ref-counts to-hash (max 0 (- count 1)))
    (audit-append action: (remove-ref ,from-hash ,to-hash))))

(define (reference-count hash)
  (hash-table-ref ref-counts hash 0))
</pre>
<h3>Root References</h3>
<pre class="language-scheme">
;; GC roots - objects that are always reachable
(define gc-roots (make-hash-set))

(define (add-gc-root hash reason)
  (hash-set-add! gc-roots hash)
  (audit-append action: (add-root ,hash ,reason)))

(define (remove-gc-root hash)
  (hash-set-remove! gc-roots hash)
  (audit-append action: (remove-root ,hash)))

(define (gc-root? hash)
  (hash-set-member? gc-roots hash))
</pre>
<h3>Implicit Roots</h3>
<pre class="language-scheme">
;; Some objects are implicitly rooted
(define (implicit-root? hash)
  (or (pinned? hash)
      (soup-object-type? hash 'certificate)  ; Certs are roots
      (soup-object-type? hash 'audit-entry)  ; Audit is sacred
      (recent-write? hash)))                 ; Grace period
</pre>
<h3>Cycle Detection</h3>
<p>Reference counting alone cannot detect cycles (A→B→C→A). The soup uses mark-and-sweep as the authoritative reachability test, with reference counts as a fast path for common cases.</p>
<pre class="language-scheme">
;; Reference counting is advisory, not authoritative
(define (fast-unreachable? hash)
  "Quick check - zero refs MIGHT mean unreachable"
  (and (zero? (reference-count hash))
       (not (gc-root? hash))
       (not (implicit-root? hash))))

;; Mark-and-sweep is authoritative
(define (truly-unreachable? hash marked-set)
  "Authoritative check - not in marked set means unreachable"
  (not (hash-set-member? marked-set hash)))

;; Cycle detection via mark-and-sweep
(define (detect-cycles)
  "Find reference cycles (objects that reference each other but are unreachable)"
  (let* ((marked (mark-reachable))
         (all-hashes (all-object-hashes))
         (unmarked (filter (lambda (h) (not (hash-set-member? marked h))) all-hashes))
         (with-refs (filter (lambda (h) (&gt; (reference-count h) 0)) unmarked)))
    ;; These have refs but are unreachable - they're in cycles
    with-refs))
</pre>
<p>In archival mode, cycles are preserved (they may be intentional - e.g., bidirectional links). Only explicit evaporation removes them.</p>
</section>
<section>
<h2>Mark and Sweep</h2>
<h3>Tricolor Abstraction</h3>
<p>The naive recursive mark algorithm risks stack overflow on deep object graphs. The tricolor abstraction provides:</p>
<ul>
<li>White: Unvisited, potentially garbage</li>
<li>Gray: Visited but references not yet scanned</li>
<li>Black: Visited and all references scanned</li>
</ul>
<pre class="language-scheme">
;; Tricolor sets - explicit worklist avoids stack overflow
(define white-set (make-hash-set))  ; Candidates for collection
(define gray-set (make-hash-set))   ; Work queue
(define black-set (make-hash-set))  ; Proven reachable

(define (tricolor-init)
  "Initialize: all objects are white"
  (hash-set-clear! white-set)
  (hash-set-clear! gray-set)
  (hash-set-clear! black-set)
  (for-each (lambda (h) (hash-set-add! white-set h))
            (all-object-hashes)))

(define (shade-gray! hash)
  "Move object from white to gray (discovered)"
  (when (hash-set-member? white-set hash)
    (hash-set-remove! white-set hash)
    (hash-set-add! gray-set hash)))

(define (shade-black! hash)
  "Move object from gray to black (fully scanned)"
  (hash-set-remove! gray-set hash)
  (hash-set-add! black-set hash))
</pre>
<h3>Mark Phase (Worklist Algorithm)</h3>
<pre class="language-scheme">
(define (mark-reachable)
  "Mark all objects reachable from roots using worklist"
  (tricolor-init)

  ;; Shade roots gray
  (for-each shade-gray! (hash-set-&gt;list gc-roots))
  (for-each (lambda (hash)
              (when (implicit-root? hash)
                (shade-gray! hash)))
            (all-object-hashes))

  ;; Process gray objects until none remain
  (let loop ()
    (unless (hash-set-empty? gray-set)
      (let ((current (hash-set-pop! gray-set)))
        ;; Shade all white references gray
        (for-each shade-gray! (object-references current))
        ;; Current is now fully scanned
        (shade-black! current)
        (loop))))

  black-set)  ; Return reachable set
</pre>
<h3>Incremental Tricolor Marking</h3>
<p>For large soups, mark in batches to avoid long pauses:</p>
<pre class="language-scheme">
(define mark-batch-size 1000)  ; Objects per batch

(define (mark-incremental)
  "Mark in batches, yielding between batches"
  (let ((batch 0))
    (let loop ()
      (unless (or (hash-set-empty? gray-set)
                  (&gt;= batch mark-batch-size))
        (let ((current (hash-set-pop! gray-set)))
          (for-each shade-gray! (object-references current))
          (shade-black! current)
          (set! batch (+ batch 1))
          (loop))))
    ;; Return whether more work remains
    (not (hash-set-empty? gray-set))))

;; Usage: call repeatedly until returns #f
(define (incremental-gc-step)
  (if (mark-incremental)
      'more-work
      (begin
        (sweep-white)
        'complete)))
</pre>
<h3>Concurrent Write Barrier</h3>
<p>For concurrent GC, mutations must maintain the tricolor invariant: a black object cannot point to a white object.</p>
<pre class="language-scheme">
;; Write barrier for concurrent GC
(define (cas-put-concurrent data)
  "Store with write barrier for concurrent GC"
  (let ((hash (cas-put data)))
    ;; If GC is running and we create new references
    (when gc-running?
      ;; Shade new object gray (conservative)
      (shade-gray! hash)
      ;; Re-shade any black object referencing new object
      (for-each (lambda (referencer)
                  (when (hash-set-member? black-set referencer)
                    ;; Demote to gray - needs re-scanning
                    (hash-set-remove! black-set referencer)
                    (hash-set-add! gray-set referencer)))
                (incoming-references hash)))
    hash))

;; Snapshot-at-the-beginning (SATB) barrier
(define (reference-update! from-hash old-ref new-ref)
  "SATB write barrier: preserve old reference for marking"
  (when (and gc-running? old-ref)
    ;; Keep old reference alive through this GC cycle
    (shade-gray! old-ref))
  (update-reference! from-hash new-ref))
</pre>
<h3>Original Mark (Preserved for Reference)</h3>
<pre class="language-scheme">
;; Simple recursive version (for small object graphs only)
(define (mark-reachable/simple)
  "Mark all objects reachable from roots (recursive, can stack overflow)"
  (let ((marked (make-hash-set)))
    (define (mark hash)
      (unless (hash-set-member? marked hash)
        (hash-set-add! marked hash)
        (for-each mark (object-references hash))))

    ;; Mark from explicit roots
    (for-each mark (hash-set-&gt;list gc-roots))

    ;; Mark from implicit roots
    (for-each (lambda (hash)
                (when (implicit-root? hash)
                  (mark hash)))
              (all-object-hashes))

    marked))
</pre>
<h3>Sweep Phase</h3>
<pre class="language-scheme">
(define (sweep marked)
  "Collect unmarked objects"
  (let ((collected '()))
    (for-each
      (lambda (hash)
        (unless (hash-set-member? marked hash)
          (when (can-collect? hash)
            (set! collected (cons hash collected))
            (collect-object! hash))))
      (all-object-hashes))
    collected))

(define (collect-object! hash)
  "Remove object from storage"
  (let ((obj (cas-get hash)))
    (audit-append
      action: 'gc-collect
      hash: hash
      size: (object-size obj)
      age: (object-age obj))
    (cas-delete! hash)))
</pre>
<h3>Full GC</h3>
<pre class="language-scheme">
(define (gc-full)
  "Perform full garbage collection"
  (let ((start (current-time)))
    (audit-append action: 'gc-start type: 'full)

    (let* ((marked (mark-reachable))
           (collected (sweep marked)))

      (audit-append
        action: 'gc-complete
        type: 'full
        duration: (- (current-time) start)
        marked: (hash-set-size marked)
        collected: (length collected)
        bytes-freed: (sum (map object-size collected)))

      collected)))
</pre>
</section>
<section>
<h2>Incremental GC</h2>
<h3>Archival Generational Collection</h3>
<p>Traditional generational GC collects young objects first (they die young). Archival GC inverts this: old objects are precious.</p>
<pre class="language-scheme">
;; Archival generations - age increases protection
(define generations
  '((ephemeral . 3600)     ; &lt; 1 hour: temporary, collect freely
    (young . 86400)        ; &lt; 1 day: probably transient
    (maturing . 604800)    ; &lt; 1 week: gaining stability
    (stable . 2592000)     ; &lt; 30 days: likely permanent
    (archival . #f)))      ; &gt;= 30 days: NEVER collect automatically

(define (object-generation hash)
  (let ((age (object-age hash)))
    (cond
      ((&lt; age 3600) 'ephemeral)
      ((&lt; age 86400) 'young)
      ((&lt; age 604800) 'maturing)
      ((&lt; age 2592000) 'stable)
      (else 'archival))))

;; Collection eligibility by generation
(define (generation-collectible? gen)
  (case gen
    ((ephemeral) #t)       ; Freely collectible
    ((young) #t)           ; Collectible with grace period
    ((maturing) 'warning)  ; Requires explicit approval
    ((stable) 'quorum)     ; Requires federation quorum
    ((archival) #f)))      ; NEVER collect automatically

(define (gc-generation gen)
  "Collect only specified generation (archival only via evaporation)"
  (when (eq? gen 'archival)
    (error "Archival objects require evaporation certificate"))
  (let ((candidates (filter (lambda (h)
                              (eq? (object-generation h) gen))
                            (all-object-hashes))))
    (gc-candidates candidates)))
</pre>
<h3>Write Barrier</h3>
<pre class="language-scheme">
;; Track modified objects for incremental GC
(define modified-set (make-hash-set))

(define (cas-put-with-barrier data)
  (let ((hash (cas-put data)))
    (hash-set-add! modified-set hash)
    hash))

(define (gc-incremental)
  "Collect recently modified objects if orphaned"
  (let ((candidates (hash-set-&gt;list modified-set)))
    (hash-set-clear! modified-set)
    (gc-candidates candidates)))
</pre>
<h3>Concurrent GC</h3>
<pre class="language-scheme">
;; GC runs concurrently with mutations
(define gc-lock (make-mutex))
(define gc-running? #f)

(define (gc-concurrent)
  "Run GC without stopping the world"
  (when (mutex-try-lock! gc-lock)
    (set! gc-running? #t)
    (let ((snapshot (snapshot-roots)))
      ;; Mark phase uses snapshot
      (let ((marked (mark-from-snapshot snapshot)))
        ;; Sweep only clearly dead objects
        (sweep-conservative marked)))
    (set! gc-running? #f)
    (mutex-unlock! gc-lock)))
</pre>
</section>
<section>
<h2>Pinning</h2>
<h3>Pin Management</h3>
<pre class="language-scheme">
(define pins (make-hash-table))

(define (pin! hash reason #!key duration)
  "Protect object from GC"
  (hash-table-set! pins hash
    ((reason . ,reason)
      (pinned-at . ,(current-time))
      (expires . ,(and duration (+ (current-time) duration)))
      (pinned-by . ,(current-principal))))
  (audit-append action: (pin ,hash ,reason)))

(define (unpin! hash)
  "Allow object to be collected"
  (hash-table-delete! pins hash)
  (audit-append action: `(unpin ,hash)))

(define (pinned? hash)
  (let ((pin (hash-table-ref pins hash #f)))
    (and pin
         (or (not (assoc-ref pin 'expires))
             (&gt; (assoc-ref pin 'expires) (current-time))))))
</pre>
<h3>Transitive Pinning</h3>
<pre class="language-scheme">
(define (pin-tree! root-hash reason)
  "Pin object and all objects it references"
  (let ((visited (make-hash-set)))
    (define (pin-recursive hash)
      (unless (hash-set-member? visited hash)
        (hash-set-add! visited hash)
        (pin! hash reason)
        (for-each pin-recursive (object-references hash))))
    (pin-recursive root-hash)))
</pre>
</section>
<section>
<h2>Tombstones</h2>
<h3>Tombstone Handling</h3>
<pre class="language-scheme">
;; Tombstones are never collected
(define (tombstoned? hash)
  (let ((obj (soup-get hash)))
    (and obj (eq? (soup-object-type obj) 'tombstone))))

;; Tombstones prevent resurrection
(define (cas-put-checked data)
  (let ((hash (content-hash data)))
    (when (tombstoned? hash)
      (error "Cannot resurrect tombstoned object" hash))
    (cas-put data)))
</pre>
<h3>Tombstone Expiry</h3>
<pre class="language-scheme">
;; Optional: tombstones can expire
(define (tombstone-expired? hash)
  (let ((tomb (soup-get hash)))
    (and tomb
         (assoc-ref (soup-object-metadata tomb) 'expires)
         (&lt; (assoc-ref (soup-object-metadata tomb) 'expires)
            (current-time)))))

(define (gc-expired-tombstones)
  "Remove expired tombstones"
  (for-each
    (lambda (hash)
      (when (and (tombstoned? hash) (tombstone-expired? hash))
        (collect-object! hash)))
    (all-object-hashes)))
</pre>
</section>
<section>
<h2>Grace Periods</h2>
<h3>Write Grace Period</h3>
<pre class="language-scheme">
;; Recently written objects are protected
(define write-grace-period 86400)  ; 24 hours

(define (recent-write? hash)
  (let ((obj (soup-get hash)))
    (and obj
         (&lt; (- (current-time) (soup-object-created obj))
            write-grace-period))))
</pre>
<h3>Replication Grace Period</h3>
<pre class="language-scheme">
;; Objects pending replication are protected
(define pending-replication (make-hash-set))

(define (mark-pending-replication hash vaults)
  (hash-set-add! pending-replication hash)
  (audit-append action: `(pending-replication ,hash ,vaults)))

(define (clear-pending-replication hash)
  (hash-set-remove! pending-replication hash))

(define (pending-replication? hash)
  (hash-set-member? pending-replication hash))
</pre>
</section>
<section>
<h2>Evaporation (Archival Collection)</h2>
<p>Objects don't get "garbage collected" in an archive. They evaporate - and only with explicit, signed, multi-party consent.</p>
<h3>Evaporation Certificate</h3>
<pre class="language-scheme">
;; An evaporation certificate authorizes deletion
(define-record-type evaporation-certificate
  (make-evaporation-cert hash reason signers timestamp)
  evaporation-cert?
  (hash evap-hash)           ; Object to evaporate
  (reason evap-reason)       ; Why (legal, storage, corruption, etc.)
  (signers evap-signers)     ; List of (principal . signature)
  (timestamp evap-timestamp))

;; Reasons for evaporation (enumerated, auditable)
(define evaporation-reasons
  '(legal-requirement        ; Court order, DMCA, etc.
    storage-emergency        ; Vault at capacity
    data-corruption          ; Object verified corrupt
    owner-request            ; Content owner requests removal
    federation-consensus))   ; Quorum agrees to remove

(define (create-evaporation-cert hash reason)
  "Create unsigned evaporation certificate"
  (make-evaporation-cert
    hash
    reason
    '()  ; No signatures yet
    (current-time)))

(define (sign-evaporation-cert cert private-key)
  "Add signature to evaporation certificate"
  (let* ((principal (key-&gt;principal private-key))
         (sig (sign-data (evap-hash cert) private-key)))
    (make-evaporation-cert
      (evap-hash cert)
      (evap-reason cert)
      (cons (cons principal sig) (evap-signers cert))
      (evap-timestamp cert))))
</pre>
<h3>Quorum Requirement</h3>
<pre class="language-scheme">
;; Evaporation requires M-of-N signatures from federation
(define evaporation-quorum
  '((ephemeral . 1)     ; Single vault can evaporate
    (young . 1)         ; Single vault can evaporate
    (maturing . 2)      ; Two vaults must agree
    (stable . 3)        ; Three vaults must agree
    (archival . #f)))   ; Requires special process (see below)

(define (evaporation-quorum-met? cert generation)
  (let ((required (assoc-ref evaporation-quorum generation)))
    (cond
      ((not required) #f)  ; Archival: never automatic
      (else (&gt;= (length (evap-signers cert)) required)))))

(define (evaporate! hash cert)
  "Evaporate object with valid certificate"
  (let ((gen (object-generation hash)))
    (unless (evaporation-quorum-met? cert gen)
      (error "Evaporation quorum not met"
             `(generation ,gen required ,(assoc-ref evaporation-quorum gen))))

    ;; Archival objects require special handling
    (when (eq? gen 'archival)
      (unless (archival-evaporation-authorized? cert)
        (error "Archival evaporation requires governance approval")))

    ;; Log everything before deletion
    (audit-append
      action: 'evaporate
      hash: hash
      generation: gen
      certificate: cert
      reason: (evap-reason cert)
      signers: (map car (evap-signers cert)))

    ;; Finally, delete
    (cas-delete! hash)))
</pre>
<h3>Archival Object Evaporation</h3>
<p>Archival objects (&gt;30 days) receive maximum protection. They can only evaporate via:</p>
<ul>
<li>Legal requirement - With proof of legal order</li>
<li>Data corruption - With cryptographic proof of corruption</li>
<li>Governance vote - Per Memo-036 quorum protocol</li>
</ul>
<p>These narrow exceptions exist because even sacred objects sometimes must go, but only with extraordinary justification.</p>
<pre class="language-scheme">
(define (archival-evaporation-authorized? cert)
  "Check if archival evaporation is properly authorized"
  (case (evap-reason cert)
    ((legal-requirement)
     ;; Must include legal order reference
     (and (evap-legal-order cert)
          (verify-legal-order (evap-legal-order cert))))

    ((data-corruption)
     ;; Must include corruption proof
     (and (evap-corruption-proof cert)
          (verify-corruption (evap-hash cert) (evap-corruption-proof cert))))

    ((federation-consensus)
     ;; Must have governance quorum (Memo-036)
     (governance-quorum-met? cert))

    (else #f)))  ; No other reasons valid for archival
</pre>
</section>
<section>
<h2>Distributed GC</h2>
<h3>Coordinated Collection</h3>
<pre class="language-scheme">
;; Multi-vault GC requires coordination
(define (distributed-gc vaults)
  "Coordinate GC across vault federation"
  ;; Phase 1: Gather root sets
  (let ((root-sets (map vault-roots vaults)))
    ;; Phase 2: Compute global reachability
    (let ((global-marked (union-all root-sets)))
      ;; Phase 3: Propose evaporation (no unilateral deletion)
      (for-each (lambda (vault)
                  (vault-propose-evaporation vault global-marked))
                vaults))))
</pre>
<h3>Remote Reference Tracking</h3>
<pre class="language-scheme">
;; Track references from remote vaults
(define remote-refs (make-hash-table))

(define (add-remote-reference vault-id hash)
  (let ((refs (hash-table-ref remote-refs hash '())))
    (hash-table-set! remote-refs hash (cons vault-id refs))))

(define (remove-remote-reference vault-id hash)
  (let ((refs (hash-table-ref remote-refs hash '())))
    (hash-table-set! remote-refs hash (delete vault-id refs))))

(define (has-remote-references? hash)
  (not (null? (hash-table-ref remote-refs hash '()))))
</pre>
<h3>Lease-Based Collection</h3>
<pre class="language-scheme">
;; Remote vaults lease objects
(define leases (make-hash-table))

(define (grant-lease hash vault-id duration)
  (let ((expires (+ (current-time) duration)))
    (hash-table-set! leases hash
      (cons (cons vault-id expires)
            (hash-table-ref leases hash '())))))

(define (lease-active? hash)
  (let ((hash-leases (hash-table-ref leases hash '())))
    (any (lambda (lease)
           (&gt; (cdr lease) (current-time)))
         hash-leases)))
</pre>
</section>
<section>
<h2>GC Scheduling</h2>
<h3>Archival Defaults</h3>
<p>The soup defaults to never collect. GC only runs when explicitly enabled and only considers ephemeral/young generations automatically.</p>
<pre class="language-scheme">
;; Archival GC mode
(define gc-mode 'archival)  ; 'archival, 'conservative, or 'aggressive

(define (gc-enabled?)
  "Check if automatic GC is enabled"
  (not (eq? gc-mode 'archival)))
</pre>
<h3>Triggers</h3>
<pre class="language-scheme">
;; GC triggered only under pressure, and only for young generations
(define (should-gc?)
  (and (gc-enabled?)
       (or (&gt; (storage-usage-percent) 95)    ; Emergency only
           (&gt; (ephemeral-orphan-count) 1000)))) ; Too many ephemeral orphans

(define (gc-schedule)
  "Run appropriate GC based on conditions and mode"
  (case gc-mode
    ((archival)
     ;; Never automatic - only explicit evaporation
     (audit-append action: 'gc-skipped reason: 'archival-mode))

    ((conservative)
     ;; Only ephemeral objects
     (cond
       ((&gt; (storage-usage-percent) 99)
        (gc-generation 'ephemeral)
        (gc-generation 'young))  ; Emergency: young too
       ((&gt; (storage-usage-percent) 95)
        (gc-generation 'ephemeral))
       (else
        (audit-append action: 'gc-skipped reason: 'no-pressure))))

    ((aggressive)
     ;; Traditional GC (NOT RECOMMENDED for archives)
     (cond
       ((&gt; (storage-usage-percent) 95)
        (gc-full))
       ((&gt; (storage-usage-percent) 80)
        (gc-generation 'young))
       (else
        (gc-incremental))))))
</pre>
<h3>Background GC</h3>
<pre class="language-scheme">
(define gc-thread #f)

(define (start-gc-daemon interval)
  "Start background GC daemon (archival mode: monitoring only)"
  (set! gc-thread
    (thread-start!
      (make-thread
        (lambda ()
          (let loop ()
            (thread-sleep! interval)
            ;; Always report status
            (audit-append
              action: 'gc-status
              mode: gc-mode
              storage-percent: (storage-usage-percent)
              ephemeral-orphans: (ephemeral-orphan-count)
              should-gc: (should-gc?))
            ;; Only act if enabled
            (when (should-gc?)
              (gc-schedule))
            (loop)))))))
</pre>
</section>
<section>
<h2>Safety Mechanisms</h2>
<h3>Dry Run</h3>
<pre class="language-scheme">
(define (gc-dry-run)
  "Report what would be collected without collecting"
  (let* ((marked (mark-reachable))
         (would-collect (filter (lambda (h)
                                  (not (hash-set-member? marked h)))
                                (all-object-hashes))))
    `((would-collect . ,(length would-collect))
      (bytes . ,(sum (map object-size would-collect)))
      (samples . ,(take would-collect 10)))))
</pre>
<h3>Collection Log</h3>
<pre class="language-scheme">
;; Every collection is logged with recovery info
(define (collect-with-log! hash)
  (let ((obj (cas-get hash)))
    ;; Log enough to reconstruct if needed
    (audit-append
      action: 'gc-collect
      hash: hash
      size: (object-size obj)
      type: (soup-object-type obj)
      references: (object-references hash)
      metadata: (soup-object-metadata obj))
    (cas-delete! hash)))
</pre>
<h3>Recovery</h3>
<pre class="language-scheme">
;; Recover recently collected object from audit log
(define (gc-recover hash)
  "Attempt to recover collected object"
  (let ((entry (find (lambda (e)
                       (and (eq? (audit-action e) 'gc-collect)
                            (equal? (audit-hash e) hash)))
                     (recent-audit-entries))))
    (if entry
        (error "Object collected, metadata preserved in audit"
               (audit-metadata entry))
        (error "Object not found in recent collections"))))
</pre>
</section>
<section>
<h2>Metrics</h2>
<h3>GC Statistics</h3>
<pre class="language-scheme">
(define gc-stats
  ((collections . 0)
    (bytes-freed . 0)
    (objects-freed . 0)
    (total-time . 0)
    (last-gc . #f)))

(define (update-gc-stats collected duration)
  (set! gc-stats
    ((collections . ,(+ 1 (assoc-ref gc-stats 'collections)))
      (bytes-freed . ,(+ (sum (map object-size collected))
                         (assoc-ref gc-stats 'bytes-freed)))
      (objects-freed . ,(+ (length collected)
                           (assoc-ref gc-stats 'objects-freed)))
      (total-time . ,(+ duration (assoc-ref gc-stats 'total-time)))
      (last-gc . ,(current-time)))))
</pre>
<h3>Monitoring</h3>
<pre class="language-scheme">
;; Expose GC metrics
(define (gc-metrics)
  `((storage-used . ,(storage-used))
    (storage-total . ,(storage-total))
    (object-count . ,(object-count))
    (orphan-estimate . ,(orphan-estimate))
    (pinned-count . ,(hash-table-size pins))
    (gc-stats . ,gc-stats)))
</pre>
</section>
<section>
<h2>Security Considerations</h2>
<h3>GC as Side Channel</h3>
<pre class="language-scheme">
;; GC timing can leak information about object references
;; Use constant-time operations where possible
(define (constant-time-mark hash)
  (let ((refs (object-references hash)))
    ;; Always process same number of refs
    (for-each mark (pad-list refs max-refs))))
</pre>
<h3>Denial of Service</h3>
<pre class="language-scheme">
;; Prevent GC starvation attacks
(define max-pins-per-principal 10000)

(define (pin-with-limit! hash reason)
  (let ((count (principal-pin-count (current-principal))))
    (when (&gt; count max-pins-per-principal)
      (error "Pin limit exceeded"))
    (pin! hash reason)))
</pre>
</section>
<section>
<h2>Invariants</h2>
<div class="diagram-container">
<svg class="diagram" viewBox="0 0 700 320" width="700" height="320" xmlns="http://www.w3.org/2000/svg">
<style>
  .diagram line { stroke: currentColor; stroke-width: 1.5; stroke-linecap: square; }
  .diagram rect { fill: currentColor; }
  .diagram text { font-family: 'JetBrains Mono', monospace; font-size: 14px; fill: currentColor; dominant-baseline: central; }
</style>
<text x="0" y="10">G1.</text>
<text x="40" y="10">Preservation</text>
<text x="170" y="10">default</text>
<text x="40" y="30">default-mode</text>
<text x="170" y="30">=</text>
<text x="190" y="30">archival</text>
<text x="300" y="30">no-automatic-collection</text>
<text x="0" y="50">G2.</text>
<text x="40" y="50">Age</text>
<text x="80" y="50">increases</text>
<text x="180" y="50">protection</text>
<text x="40" y="70">age(obj)</text>
<text x="130" y="70">&gt;</text>
<text x="150" y="70">age(obj')</text>
<text x="270" y="70">protection(obj)</text>
<text x="430" y="70">≥</text>
<text x="450" y="70">protection(obj')</text>
<text x="0" y="90">G3.</text>
<text x="40" y="90">Evaporation</text>
<text x="160" y="90">requires</text>
<text x="250" y="90">consent</text>
<text x="40" y="110">evaporate(hash)</text>
<text x="200" y="110">requires</text>
<text x="290" y="110">signed-certificate(hash)</text>
<text x="0" y="130">G4.</text>
<text x="40" y="130">Quorum</text>
<text x="110" y="130">scales</text>
<text x="180" y="130">with</text>
<text x="230" y="130">age</text>
<text x="40" y="150">generation</text>
<text x="150" y="150">=</text>
<text x="170" y="150">archival</text>
<text x="280" y="150">quorum</text>
<text x="350" y="150">=</text>
<text x="370" y="150">governance-level</text>
<text x="0" y="170">G5.</text>
<text x="40" y="170">Archival</text>
<text x="130" y="170">objects</text>
<text x="210" y="170">are</text>
<text x="250" y="170">sacred</text>
<text x="40" y="190">age</text>
<text x="80" y="190">&gt;</text>
<text x="100" y="190">30-days</text>
<text x="200" y="190">no-automatic-evaporation</text>
<text x="0" y="210">G6.</text>
<text x="40" y="210">Audit</text>
<text x="100" y="210">trail</text>
<text x="160" y="210">preserved</text>
<text x="40" y="230">evaporate(hash)</text>
<text x="220" y="230">audit-append(hash,</text>
<text x="410" y="230">certificate,</text>
<text x="540" y="230">reason,</text>
<text x="620" y="230">signers)</text>
<text x="0" y="250">G7.</text>
<text x="40" y="250">Mark-and-sweep</text>
<text x="190" y="250">authoritative</text>
<text x="40" y="270">truly-unreachable(hash)</text>
<text x="280" y="270">↔</text>
<text x="300" y="270">¬member(hash,</text>
<text x="440" y="270">mark-reachable())</text>
<text x="0" y="290">G8.</text>
<text x="40" y="290">Cycles</text>
<text x="110" y="290">preserved</text>
<text x="40" y="310">cycle(A,</text>
<text x="130" y="310">B,</text>
<text x="160" y="310">C)</text>
<text x="190" y="310">∧</text>
<text x="210" y="310">archival-mode</text>
<text x="370" y="310">preserve(A,</text>
<text x="490" y="310">B,</text>
<text x="520" y="310">C)</text>
</svg>
</div>
</section>
<section>
<h2>References</h2>
<ul>
<li>The Garbage Collection Handbook - Jones, Hosking, Moss</li>
<li>On-the-Fly Garbage Collection - Dijkstra et al.</li>
<li>Memo-020: Content-Addressed Storage</li>
<li>Memo-003: Cryptographic Audit Trail</li>
<li>Memo-036: Quorum Protocol with Homomorphic Voting</li>
<li>Memo-008: Threshold Signature Governance</li>
</ul>
</section>
<section>
<h2>Changelog</h2>
<ul>
<li>2026-01-09</li>
<li>Tricolor marking with worklist (eliminates stack overflow), incremental marking, SATB write barriers, concurrent GC support - 2026-01-09</li>
<li>Archival GC improvements: evaporation certificates, quorum requirements, reversed generational policy, cycle detection, preservation-first defaults - 2026-01-07</li>
<li>Initial draft</li>
</ul>
</section>
<script>
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
}
(function() {
  // Query param override (for REPL: ?theme=dark or ?theme=light)
  const params = new URLSearchParams(window.location.search);
  const param = params.get('theme');
  if (param === 'dark' || param === 'light') {
    document.documentElement.setAttribute('data-theme', param);
    localStorage.setItem('theme', param);
    return;
  }
  // localStorage preference
  const saved = localStorage.getItem('theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
  } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script>
</body>
</html>
