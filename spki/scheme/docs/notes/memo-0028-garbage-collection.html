<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <title>Memo 0028: Garbage Collection</title>
  <link rel="icon" id="favicon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27%230f0%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>">
  <script>
(function(){
  var h=new Date().getHours(),c;
  if(h>=4&&h<6)c='%23845EC2';       // brahma muhurta - violet
  else if(h>=6&&h<8)c='%23ffd700';  // dawn - gold
  else if(h>=8&&h<11)c='%2300d4aa'; // morning - teal
  else if(h>=11&&h<14)c='%230f0';   // midday - phosphor
  else if(h>=14&&h<17)c='%2339ff14';// afternoon - neon
  else if(h>=17&&h<19)c='%23ff6600';// sunset - orange
  else if(h>=19&&h<22)c='%23ff3366';// evening - coral
  else c='%2300ffff';               // night - cyan
  document.getElementById('favicon').href='data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 32 32%27><text x=%2716%27 y=%2725%27 font-family=%27serif%27 font-size=%2728%27 fill=%27'+c+'%27 text-anchor=%27middle%27 font-weight=%27bold%27>λ</text></svg>';
})();
</script>
  <link rel="stylesheet" href="memo.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<h1>Memo 0028: Garbage Collection</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This Memo specifies garbage collection for the Library of Cyberspace: how vaults identify and reclaim storage from unreferenced objects while preserving pinned content, respecting tombstones, and maintaining audit trails. Content-addressed storage requires careful GC to avoid data loss.</p>
<p>The Library of Cyberspace is an archival system. The default is preservation, not collection. Objects evaporate only with explicit consent.</p>
</section>
<section>
<h2>Philosophy: The Soup Preserves</h2>
<p>The soup is not a runtime heap. It is a library.</p>
<p>In runtime garbage collection, the goal is to reclaim memory quickly. Young objects die young. Old objects survive. Collect aggressively.</p>
<p>In archival garbage collection, the opposite holds:</p>
<ul>
<li>Old objects are precious</li>
<li>They have survived, been referenced, replicated</li>
<li>Young objects are suspect</li>
<li>They may be transient, failed, or temporary</li>
<li>Deletion is violence</li>
<li>Once collected, an object is gone from this vault forever</li>
<li>Preservation is the default</li>
<li>When in doubt, keep it</li>
</ul>
<p>This inverts the runtime GC assumption that most objects die young; in an archive, age confers value.</p>
<p>The Library of Alexandria burned once. We will not let it burn again.</p>
</section>
<section>
<h2>Motivation</h2>
<p>Content-addressed storage accumulates objects forever unless actively pruned:</p>
<ul>
<li>Orphaned objects</li>
<li>No longer referenced by any root</li>
<li>Superseded versions</li>
<li>Old versions after updates</li>
<li>Failed uploads</li>
<li>Partial or abandoned writes</li>
<li>Temporary objects</li>
<li>Intermediate computation results</li>
</ul>
<p>Without collection, storage grows without bound; the question is not whether to collect but how conservatively.</p>
<p>But deletion is dangerous:</p>
<ul>
<li>Hash as capability</li>
<li>Someone may hold the hash</li>
<li>Lazy replication</li>
<li>Remote vaults may need it later</li>
<li>Audit requirements</li>
<li>May need historical data</li>
<li>Resurrection</li>
<li>Deleted objects may be re-added</li>
</ul>
<p>Each risk represents a real failure mode; premature collection has caused data loss in every major distributed system.</p>
<p>GC must be conservative, consensual, and auditable.</p>
<p>The default is: never collect. Collection requires explicit action.</p>
</section>
<section>
<h2>Object Lifecycle</h2>
<h3>States</h3>
<pre class="diagram">
                    ┌─────────┐
          write     │         │
        ─────────►  │  LIVE   │
                    │         │
                    └────┬────┘
                         │
              ┌──────────┼──────────┐
              │          │          │
              ▼          ▼          ▼
         ┌────────┐ ┌────────┐ ┌────────┐
         │PINNED  │ │TOMBSTONE│ │ORPHANED│
         └────────┘ └────────┘ └───┬────┘
                                   │
                                   │ GC
                                   ▼
                              ┌────────┐
                              │COLLECTED│
                              └────────┘
</pre>
<h3>State Transitions</h3>
<pre class="language-scheme">
(define (object-state hash)
  (cond
    ((pinned? hash) 'pinned)
    ((tombstoned? hash) 'tombstone)
    ((referenced? hash) 'live)
    (else 'orphaned)))

(define (can-collect? hash)
  (and (eq? (object-state hash) 'orphaned)
       (not (in-grace-period? hash))
       (not (pending-replication? hash))))
</pre>
</section>
<section>
<h2>Reference Counting</h2>
<h3>Direct References</h3>
<pre class="language-scheme">
;; Track incoming references
(define ref-counts (make-hash-table))

(define (add-reference from-hash to-hash)
  (let ((count (hash-table-ref ref-counts to-hash 0)))
    (hash-table-set! ref-counts to-hash (+ count 1))
    (audit-append action: (add-ref ,from-hash ,to-hash))))

(define (remove-reference from-hash to-hash)
  (let ((count (hash-table-ref ref-counts to-hash 0)))
    (hash-table-set! ref-counts to-hash (max 0 (- count 1)))
    (audit-append action: (remove-ref ,from-hash ,to-hash))))

(define (reference-count hash)
  (hash-table-ref ref-counts hash 0))
</pre>
<h3>Root References</h3>
<pre class="language-scheme">
;; GC roots - objects that are always reachable
(define gc-roots (make-hash-set))

(define (add-gc-root hash reason)
  (hash-set-add! gc-roots hash)
  (audit-append action: (add-root ,hash ,reason)))

(define (remove-gc-root hash)
  (hash-set-remove! gc-roots hash)
  (audit-append action: (remove-root ,hash)))

(define (gc-root? hash)
  (hash-set-member? gc-roots hash))
</pre>
<h3>Implicit Roots</h3>
<pre class="language-scheme">
;; Some objects are implicitly rooted
(define (implicit-root? hash)
  (or (pinned? hash)
      (soup-object-type? hash 'certificate)  ; Certs are roots
      (soup-object-type? hash 'audit-entry)  ; Audit is sacred
      (recent-write? hash)))                 ; Grace period
</pre>
<h3>Cycle Detection</h3>
<p>Reference counting alone cannot detect cycles (A→B→C→A). The soup uses mark-and-sweep as the authoritative reachability test, with reference counts as a fast path for common cases.</p>
<pre class="language-scheme">
;; Reference counting is advisory, not authoritative
(define (fast-unreachable? hash)
  "Quick check - zero refs MIGHT mean unreachable"
  (and (zero? (reference-count hash))
       (not (gc-root? hash))
       (not (implicit-root? hash))))

;; Mark-and-sweep is authoritative
(define (truly-unreachable? hash marked-set)
  "Authoritative check - not in marked set means unreachable"
  (not (hash-set-member? marked-set hash)))

;; Cycle detection via mark-and-sweep
(define (detect-cycles)
  "Find reference cycles (objects that reference each other but are unreachable)"
  (let* ((marked (mark-reachable))
         (all-hashes (all-object-hashes))
         (unmarked (filter (lambda (h) (not (hash-set-member? marked h))) all-hashes))
         (with-refs (filter (lambda (h) (&gt; (reference-count h) 0)) unmarked)))
    ;; These have refs but are unreachable - they're in cycles
    with-refs))
</pre>
<p>In archival mode, cycles are preserved (they may be intentional - e.g., bidirectional links). Only explicit evaporation removes them.</p>
</section>
<section>
<h2>Mark and Sweep</h2>
<h3>Tricolor Abstraction</h3>
<p>The naive recursive mark algorithm risks stack overflow on deep object graphs. The tricolor abstraction provides:</p>
<ul>
<li>White: Unvisited, potentially garbage</li>
<li>Gray: Visited but references not yet scanned</li>
<li>Black: Visited and all references scanned</li>
</ul>
<pre class="language-scheme">
;; Tricolor sets - explicit worklist avoids stack overflow
(define white-set (make-hash-set))  ; Candidates for collection
(define gray-set (make-hash-set))   ; Work queue
(define black-set (make-hash-set))  ; Proven reachable

(define (tricolor-init)
  "Initialize: all objects are white"
  (hash-set-clear! white-set)
  (hash-set-clear! gray-set)
  (hash-set-clear! black-set)
  (for-each (lambda (h) (hash-set-add! white-set h))
            (all-object-hashes)))

(define (shade-gray! hash)
  "Move object from white to gray (discovered)"
  (when (hash-set-member? white-set hash)
    (hash-set-remove! white-set hash)
    (hash-set-add! gray-set hash)))

(define (shade-black! hash)
  "Move object from gray to black (fully scanned)"
  (hash-set-remove! gray-set hash)
  (hash-set-add! black-set hash))
</pre>
<h3>Mark Phase (Worklist Algorithm)</h3>
<pre class="language-scheme">
(define (mark-reachable)
  "Mark all objects reachable from roots using worklist"
  (tricolor-init)

  ;; Shade roots gray
  (for-each shade-gray! (hash-set-&gt;list gc-roots))
  (for-each (lambda (hash)
              (when (implicit-root? hash)
                (shade-gray! hash)))
            (all-object-hashes))

  ;; Process gray objects until none remain
  (let loop ()
    (unless (hash-set-empty? gray-set)
      (let ((current (hash-set-pop! gray-set)))
        ;; Shade all white references gray
        (for-each shade-gray! (object-references current))
        ;; Current is now fully scanned
        (shade-black! current)
        (loop))))

  black-set)  ; Return reachable set
</pre>
<h3>Incremental Tricolor Marking</h3>
<p>For large soups, mark in batches to avoid long pauses:</p>
<pre class="language-scheme">
(define mark-batch-size 1000)  ; Objects per batch

(define (mark-incremental)
  "Mark in batches, yielding between batches"
  (let ((batch 0))
    (let loop ()
      (unless (or (hash-set-empty? gray-set)
                  (&gt;= batch mark-batch-size))
        (let ((current (hash-set-pop! gray-set)))
          (for-each shade-gray! (object-references current))
          (shade-black! current)
          (set! batch (+ batch 1))
          (loop))))
    ;; Return whether more work remains
    (not (hash-set-empty? gray-set))))

;; Usage: call repeatedly until returns #f
(define (incremental-gc-step)
  (if (mark-incremental)
      'more-work
      (begin
        (sweep-white)
        'complete)))
</pre>
<h3>Concurrent Write Barrier</h3>
<p>For concurrent GC, mutations must maintain the tricolor invariant: a black object cannot point to a white object.</p>
<pre class="language-scheme">
;; Write barrier for concurrent GC
(define (cas-put-concurrent data)
  "Store with write barrier for concurrent GC"
  (let ((hash (cas-put data)))
    ;; If GC is running and we create new references
    (when gc-running?
      ;; Shade new object gray (conservative)
      (shade-gray! hash)
      ;; Re-shade any black object referencing new object
      (for-each (lambda (referencer)
                  (when (hash-set-member? black-set referencer)
                    ;; Demote to gray - needs re-scanning
                    (hash-set-remove! black-set referencer)
                    (hash-set-add! gray-set referencer)))
                (incoming-references hash)))
    hash))

;; Snapshot-at-the-beginning (SATB) barrier
(define (reference-update! from-hash old-ref new-ref)
  "SATB write barrier: preserve old reference for marking"
  (when (and gc-running? old-ref)
    ;; Keep old reference alive through this GC cycle
    (shade-gray! old-ref))
  (update-reference! from-hash new-ref))
</pre>
<h3>Original Mark (Preserved for Reference)</h3>
<pre class="language-scheme">
;; Simple recursive version (for small object graphs only)
(define (mark-reachable/simple)
  "Mark all objects reachable from roots (recursive, can stack overflow)"
  (let ((marked (make-hash-set)))
    (define (mark hash)
      (unless (hash-set-member? marked hash)
        (hash-set-add! marked hash)
        (for-each mark (object-references hash))))

    ;; Mark from explicit roots
    (for-each mark (hash-set-&gt;list gc-roots))

    ;; Mark from implicit roots
    (for-each (lambda (hash)
                (when (implicit-root? hash)
                  (mark hash)))
              (all-object-hashes))

    marked))
</pre>
<h3>Sweep Phase</h3>
<pre class="language-scheme">
(define (sweep marked)
  "Collect unmarked objects"
  (let ((collected '()))
    (for-each
      (lambda (hash)
        (unless (hash-set-member? marked hash)
          (when (can-collect? hash)
            (set! collected (cons hash collected))
            (collect-object! hash))))
      (all-object-hashes))
    collected))

(define (collect-object! hash)
  "Remove object from storage"
  (let ((obj (cas-get hash)))
    (audit-append
      action: 'gc-collect
      hash: hash
      size: (object-size obj)
      age: (object-age obj))
    (cas-delete! hash)))
</pre>
<h3>Full GC</h3>
<pre class="language-scheme">
(define (gc-full)
  "Perform full garbage collection"
  (let ((start (current-time)))
    (audit-append action: 'gc-start type: 'full)

    (let* ((marked (mark-reachable))
           (collected (sweep marked)))

      (audit-append
        action: 'gc-complete
        type: 'full
        duration: (- (current-time) start)
        marked: (hash-set-size marked)
        collected: (length collected)
        bytes-freed: (sum (map object-size collected)))

      collected)))
</pre>
</section>
<section>
<h2>Incremental GC</h2>
<h3>Archival Generational Collection</h3>
<p>Traditional generational GC collects young objects first (they die young). Archival GC inverts this: old objects are precious.</p>
<pre class="language-scheme">
;; Archival generations - age increases protection
(define generations
  '((ephemeral . 3600)     ; &lt; 1 hour: temporary, collect freely
    (young . 86400)        ; &lt; 1 day: probably transient
    (maturing . 604800)    ; &lt; 1 week: gaining stability
    (stable . 2592000)     ; &lt; 30 days: likely permanent
    (archival . #f)))      ; &gt;= 30 days: NEVER collect automatically

(define (object-generation hash)
  (let ((age (object-age hash)))
    (cond
      ((&lt; age 3600) 'ephemeral)
      ((&lt; age 86400) 'young)
      ((&lt; age 604800) 'maturing)
      ((&lt; age 2592000) 'stable)
      (else 'archival))))

;; Collection eligibility by generation
(define (generation-collectible? gen)
  (case gen
    ((ephemeral) #t)       ; Freely collectible
    ((young) #t)           ; Collectible with grace period
    ((maturing) 'warning)  ; Requires explicit approval
    ((stable) 'quorum)     ; Requires federation quorum
    ((archival) #f)))      ; NEVER collect automatically

(define (gc-generation gen)
  "Collect only specified generation (archival only via evaporation)"
  (when (eq? gen 'archival)
    (error "Archival objects require evaporation certificate"))
  (let ((candidates (filter (lambda (h)
                              (eq? (object-generation h) gen))
                            (all-object-hashes))))
    (gc-candidates candidates)))
</pre>
<h3>Write Barrier</h3>
<pre class="language-scheme">
;; Track modified objects for incremental GC
(define modified-set (make-hash-set))

(define (cas-put-with-barrier data)
  (let ((hash (cas-put data)))
    (hash-set-add! modified-set hash)
    hash))

(define (gc-incremental)
  "Collect recently modified objects if orphaned"
  (let ((candidates (hash-set-&gt;list modified-set)))
    (hash-set-clear! modified-set)
    (gc-candidates candidates)))
</pre>
<h3>Concurrent GC</h3>
<pre class="language-scheme">
;; GC runs concurrently with mutations
(define gc-lock (make-mutex))
(define gc-running? #f)

(define (gc-concurrent)
  "Run GC without stopping the world"
  (when (mutex-try-lock! gc-lock)
    (set! gc-running? #t)
    (let ((snapshot (snapshot-roots)))
      ;; Mark phase uses snapshot
      (let ((marked (mark-from-snapshot snapshot)))
        ;; Sweep only clearly dead objects
        (sweep-conservative marked)))
    (set! gc-running? #f)
    (mutex-unlock! gc-lock)))
</pre>
</section>
<section>
<h2>Pinning</h2>
<h3>Pin Management</h3>
<pre class="language-scheme">
(define pins (make-hash-table))

(define (pin! hash reason #!key duration)
  "Protect object from GC"
  (hash-table-set! pins hash
    ((reason . ,reason)
      (pinned-at . ,(current-time))
      (expires . ,(and duration (+ (current-time) duration)))
      (pinned-by . ,(current-principal))))
  (audit-append action: (pin ,hash ,reason)))

(define (unpin! hash)
  "Allow object to be collected"
  (hash-table-delete! pins hash)
  (audit-append action: `(unpin ,hash)))

(define (pinned? hash)
  (let ((pin (hash-table-ref pins hash #f)))
    (and pin
         (or (not (assoc-ref pin 'expires))
             (&gt; (assoc-ref pin 'expires) (current-time))))))
</pre>
<h3>Transitive Pinning</h3>
<pre class="language-scheme">
(define (pin-tree! root-hash reason)
  "Pin object and all objects it references"
  (let ((visited (make-hash-set)))
    (define (pin-recursive hash)
      (unless (hash-set-member? visited hash)
        (hash-set-add! visited hash)
        (pin! hash reason)
        (for-each pin-recursive (object-references hash))))
    (pin-recursive root-hash)))
</pre>
</section>
<section>
<h2>Tombstones</h2>
<h3>Tombstone Handling</h3>
<pre class="language-scheme">
;; Tombstones are never collected
(define (tombstoned? hash)
  (let ((obj (soup-get hash)))
    (and obj (eq? (soup-object-type obj) 'tombstone))))

;; Tombstones prevent resurrection
(define (cas-put-checked data)
  (let ((hash (content-hash data)))
    (when (tombstoned? hash)
      (error "Cannot resurrect tombstoned object" hash))
    (cas-put data)))
</pre>
<h3>Tombstone Expiry</h3>
<pre class="language-scheme">
;; Optional: tombstones can expire
(define (tombstone-expired? hash)
  (let ((tomb (soup-get hash)))
    (and tomb
         (assoc-ref (soup-object-metadata tomb) 'expires)
         (&lt; (assoc-ref (soup-object-metadata tomb) 'expires)
            (current-time)))))

(define (gc-expired-tombstones)
  "Remove expired tombstones"
  (for-each
    (lambda (hash)
      (when (and (tombstoned? hash) (tombstone-expired? hash))
        (collect-object! hash)))
    (all-object-hashes)))
</pre>
</section>
<section>
<h2>Grace Periods</h2>
<h3>Write Grace Period</h3>
<pre class="language-scheme">
;; Recently written objects are protected
(define write-grace-period 86400)  ; 24 hours

(define (recent-write? hash)
  (let ((obj (soup-get hash)))
    (and obj
         (&lt; (- (current-time) (soup-object-created obj))
            write-grace-period))))
</pre>
<h3>Replication Grace Period</h3>
<pre class="language-scheme">
;; Objects pending replication are protected
(define pending-replication (make-hash-set))

(define (mark-pending-replication hash vaults)
  (hash-set-add! pending-replication hash)
  (audit-append action: `(pending-replication ,hash ,vaults)))

(define (clear-pending-replication hash)
  (hash-set-remove! pending-replication hash))

(define (pending-replication? hash)
  (hash-set-member? pending-replication hash))
</pre>
</section>
<section>
<h2>Evaporation (Archival Collection)</h2>
<p>Objects don't get "garbage collected" in an archive. They evaporate - and only with explicit, signed, multi-party consent.</p>
<h3>Evaporation Certificate</h3>
<pre class="language-scheme">
;; An evaporation certificate authorizes deletion
(define-record-type evaporation-certificate
  (make-evaporation-cert hash reason signers timestamp)
  evaporation-cert?
  (hash evap-hash)           ; Object to evaporate
  (reason evap-reason)       ; Why (legal, storage, corruption, etc.)
  (signers evap-signers)     ; List of (principal . signature)
  (timestamp evap-timestamp))

;; Reasons for evaporation (enumerated, auditable)
(define evaporation-reasons
  '(legal-requirement        ; Court order, DMCA, etc.
    storage-emergency        ; Vault at capacity
    data-corruption          ; Object verified corrupt
    owner-request            ; Content owner requests removal
    federation-consensus))   ; Quorum agrees to remove

(define (create-evaporation-cert hash reason)
  "Create unsigned evaporation certificate"
  (make-evaporation-cert
    hash
    reason
    '()  ; No signatures yet
    (current-time)))

(define (sign-evaporation-cert cert private-key)
  "Add signature to evaporation certificate"
  (let* ((principal (key-&gt;principal private-key))
         (sig (sign-data (evap-hash cert) private-key)))
    (make-evaporation-cert
      (evap-hash cert)
      (evap-reason cert)
      (cons (cons principal sig) (evap-signers cert))
      (evap-timestamp cert))))
</pre>
<h3>Quorum Requirement</h3>
<pre class="language-scheme">
;; Evaporation requires M-of-N signatures from federation
(define evaporation-quorum
  '((ephemeral . 1)     ; Single vault can evaporate
    (young . 1)         ; Single vault can evaporate
    (maturing . 2)      ; Two vaults must agree
    (stable . 3)        ; Three vaults must agree
    (archival . #f)))   ; Requires special process (see below)

(define (evaporation-quorum-met? cert generation)
  (let ((required (assoc-ref evaporation-quorum generation)))
    (cond
      ((not required) #f)  ; Archival: never automatic
      (else (&gt;= (length (evap-signers cert)) required)))))

(define (evaporate! hash cert)
  "Evaporate object with valid certificate"
  (let ((gen (object-generation hash)))
    (unless (evaporation-quorum-met? cert gen)
      (error "Evaporation quorum not met"
             `(generation ,gen required ,(assoc-ref evaporation-quorum gen))))

    ;; Archival objects require special handling
    (when (eq? gen 'archival)
      (unless (archival-evaporation-authorized? cert)
        (error "Archival evaporation requires governance approval")))

    ;; Log everything before deletion
    (audit-append
      action: 'evaporate
      hash: hash
      generation: gen
      certificate: cert
      reason: (evap-reason cert)
      signers: (map car (evap-signers cert)))

    ;; Finally, delete
    (cas-delete! hash)))
</pre>
<h3>Archival Object Evaporation</h3>
<p>Archival objects (&gt;30 days) receive maximum protection. They can only evaporate via:</p>
<ul>
<li>Legal requirement - With proof of legal order</li>
<li>Data corruption - With cryptographic proof of corruption</li>
<li>Governance vote - Per Memo-036 quorum protocol</li>
</ul>
<p>These narrow exceptions exist because even sacred objects sometimes must go, but only with extraordinary justification.</p>
<pre class="language-scheme">
(define (archival-evaporation-authorized? cert)
  "Check if archival evaporation is properly authorized"
  (case (evap-reason cert)
    ((legal-requirement)
     ;; Must include legal order reference
     (and (evap-legal-order cert)
          (verify-legal-order (evap-legal-order cert))))

    ((data-corruption)
     ;; Must include corruption proof
     (and (evap-corruption-proof cert)
          (verify-corruption (evap-hash cert) (evap-corruption-proof cert))))

    ((federation-consensus)
     ;; Must have governance quorum (Memo-036)
     (governance-quorum-met? cert))

    (else #f)))  ; No other reasons valid for archival
</pre>
</section>
<section>
<h2>Distributed GC</h2>
<h3>Coordinated Collection</h3>
<pre class="language-scheme">
;; Multi-vault GC requires coordination
(define (distributed-gc vaults)
  "Coordinate GC across vault federation"
  ;; Phase 1: Gather root sets
  (let ((root-sets (map vault-roots vaults)))
    ;; Phase 2: Compute global reachability
    (let ((global-marked (union-all root-sets)))
      ;; Phase 3: Propose evaporation (no unilateral deletion)
      (for-each (lambda (vault)
                  (vault-propose-evaporation vault global-marked))
                vaults))))
</pre>
<h3>Remote Reference Tracking</h3>
<pre class="language-scheme">
;; Track references from remote vaults
(define remote-refs (make-hash-table))

(define (add-remote-reference vault-id hash)
  (let ((refs (hash-table-ref remote-refs hash '())))
    (hash-table-set! remote-refs hash (cons vault-id refs))))

(define (remove-remote-reference vault-id hash)
  (let ((refs (hash-table-ref remote-refs hash '())))
    (hash-table-set! remote-refs hash (delete vault-id refs))))

(define (has-remote-references? hash)
  (not (null? (hash-table-ref remote-refs hash '()))))
</pre>
<h3>Lease-Based Collection</h3>
<pre class="language-scheme">
;; Remote vaults lease objects
(define leases (make-hash-table))

(define (grant-lease hash vault-id duration)
  (let ((expires (+ (current-time) duration)))
    (hash-table-set! leases hash
      (cons (cons vault-id expires)
            (hash-table-ref leases hash '())))))

(define (lease-active? hash)
  (let ((hash-leases (hash-table-ref leases hash '())))
    (any (lambda (lease)
           (&gt; (cdr lease) (current-time)))
         hash-leases)))
</pre>
</section>
<section>
<h2>GC Scheduling</h2>
<h3>Archival Defaults</h3>
<p>The soup defaults to never collect. GC only runs when explicitly enabled and only considers ephemeral/young generations automatically.</p>
<pre class="language-scheme">
;; Archival GC mode
(define gc-mode 'archival)  ; 'archival, 'conservative, or 'aggressive

(define (gc-enabled?)
  "Check if automatic GC is enabled"
  (not (eq? gc-mode 'archival)))
</pre>
<h3>Triggers</h3>
<pre class="language-scheme">
;; GC triggered only under pressure, and only for young generations
(define (should-gc?)
  (and (gc-enabled?)
       (or (&gt; (storage-usage-percent) 95)    ; Emergency only
           (&gt; (ephemeral-orphan-count) 1000)))) ; Too many ephemeral orphans

(define (gc-schedule)
  "Run appropriate GC based on conditions and mode"
  (case gc-mode
    ((archival)
     ;; Never automatic - only explicit evaporation
     (audit-append action: 'gc-skipped reason: 'archival-mode))

    ((conservative)
     ;; Only ephemeral objects
     (cond
       ((&gt; (storage-usage-percent) 99)
        (gc-generation 'ephemeral)
        (gc-generation 'young))  ; Emergency: young too
       ((&gt; (storage-usage-percent) 95)
        (gc-generation 'ephemeral))
       (else
        (audit-append action: 'gc-skipped reason: 'no-pressure))))

    ((aggressive)
     ;; Traditional GC (NOT RECOMMENDED for archives)
     (cond
       ((&gt; (storage-usage-percent) 95)
        (gc-full))
       ((&gt; (storage-usage-percent) 80)
        (gc-generation 'young))
       (else
        (gc-incremental))))))
</pre>
<h3>Background GC</h3>
<pre class="language-scheme">
(define gc-thread #f)

(define (start-gc-daemon interval)
  "Start background GC daemon (archival mode: monitoring only)"
  (set! gc-thread
    (thread-start!
      (make-thread
        (lambda ()
          (let loop ()
            (thread-sleep! interval)
            ;; Always report status
            (audit-append
              action: 'gc-status
              mode: gc-mode
              storage-percent: (storage-usage-percent)
              ephemeral-orphans: (ephemeral-orphan-count)
              should-gc: (should-gc?))
            ;; Only act if enabled
            (when (should-gc?)
              (gc-schedule))
            (loop)))))))
</pre>
</section>
<section>
<h2>Safety Mechanisms</h2>
<h3>Dry Run</h3>
<pre class="language-scheme">
(define (gc-dry-run)
  "Report what would be collected without collecting"
  (let* ((marked (mark-reachable))
         (would-collect (filter (lambda (h)
                                  (not (hash-set-member? marked h)))
                                (all-object-hashes))))
    `((would-collect . ,(length would-collect))
      (bytes . ,(sum (map object-size would-collect)))
      (samples . ,(take would-collect 10)))))
</pre>
<h3>Collection Log</h3>
<pre class="language-scheme">
;; Every collection is logged with recovery info
(define (collect-with-log! hash)
  (let ((obj (cas-get hash)))
    ;; Log enough to reconstruct if needed
    (audit-append
      action: 'gc-collect
      hash: hash
      size: (object-size obj)
      type: (soup-object-type obj)
      references: (object-references hash)
      metadata: (soup-object-metadata obj))
    (cas-delete! hash)))
</pre>
<h3>Recovery</h3>
<pre class="language-scheme">
;; Recover recently collected object from audit log
(define (gc-recover hash)
  "Attempt to recover collected object"
  (let ((entry (find (lambda (e)
                       (and (eq? (audit-action e) 'gc-collect)
                            (equal? (audit-hash e) hash)))
                     (recent-audit-entries))))
    (if entry
        (error "Object collected, metadata preserved in audit"
               (audit-metadata entry))
        (error "Object not found in recent collections"))))
</pre>
</section>
<section>
<h2>Metrics</h2>
<h3>GC Statistics</h3>
<pre class="language-scheme">
(define gc-stats
  ((collections . 0)
    (bytes-freed . 0)
    (objects-freed . 0)
    (total-time . 0)
    (last-gc . #f)))

(define (update-gc-stats collected duration)
  (set! gc-stats
    ((collections . ,(+ 1 (assoc-ref gc-stats 'collections)))
      (bytes-freed . ,(+ (sum (map object-size collected))
                         (assoc-ref gc-stats 'bytes-freed)))
      (objects-freed . ,(+ (length collected)
                           (assoc-ref gc-stats 'objects-freed)))
      (total-time . ,(+ duration (assoc-ref gc-stats 'total-time)))
      (last-gc . ,(current-time)))))
</pre>
<h3>Monitoring</h3>
<pre class="language-scheme">
;; Expose GC metrics
(define (gc-metrics)
  `((storage-used . ,(storage-used))
    (storage-total . ,(storage-total))
    (object-count . ,(object-count))
    (orphan-estimate . ,(orphan-estimate))
    (pinned-count . ,(hash-table-size pins))
    (gc-stats . ,gc-stats)))
</pre>
</section>
<section>
<h2>Security Considerations</h2>
<h3>GC as Side Channel</h3>
<pre class="language-scheme">
;; GC timing can leak information about object references
;; Use constant-time operations where possible
(define (constant-time-mark hash)
  (let ((refs (object-references hash)))
    ;; Always process same number of refs
    (for-each mark (pad-list refs max-refs))))
</pre>
<h3>Denial of Service</h3>
<pre class="language-scheme">
;; Prevent GC starvation attacks
(define max-pins-per-principal 10000)

(define (pin-with-limit! hash reason)
  (let ((count (principal-pin-count (current-principal))))
    (when (&gt; count max-pins-per-principal)
      (error "Pin limit exceeded"))
    (pin! hash reason)))
</pre>
</section>
<section>
<h2>Invariants</h2>
<pre class="diagram">
G1. Preservation default
    default-mode = archival → no-automatic-collection

G2. Age increases protection
    age(obj) &gt; age(obj') → protection(obj) ≥ protection(obj')

G3. Evaporation requires consent
    evaporate(hash) requires signed-certificate(hash)

G4. Quorum scales with age
    generation = archival → quorum = governance-level

G5. Archival objects are sacred
    age &gt; 30-days → no-automatic-evaporation

G6. Audit trail preserved
    evaporate(hash) → audit-append(hash, certificate, reason, signers)

G7. Mark-and-sweep authoritative
    truly-unreachable(hash) ↔ ¬member(hash, mark-reachable())

G8. Cycles preserved
    cycle(A, B, C) ∧ archival-mode → preserve(A, B, C)
</pre>
</section>
<section>
<h2>References</h2>
<ul>
<li>The Garbage Collection Handbook - Jones, Hosking, Moss</li>
<li>On-the-Fly Garbage Collection - Dijkstra et al.</li>
<li>Memo-020: Content-Addressed Storage</li>
<li>Memo-003: Cryptographic Audit Trail</li>
<li>Memo-036: Quorum Protocol with Homomorphic Voting</li>
<li>Memo-008: Threshold Signature Governance</li>
</ul>
</section>
<section>
<h2>Changelog</h2>
<ul>
<li>2026-01-09</li>
<li>Tricolor marking with worklist (eliminates stack overflow), incremental marking, SATB write barriers, concurrent GC support - 2026-01-09</li>
<li>Archival GC improvements: evaporation certificates, quorum requirements, reversed generational policy, cycle detection, preservation-first defaults - 2026-01-07</li>
<li>Initial draft</li>
</ul>
</section>
<script>
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
}
(function() {
  // Query param override (for REPL: ?theme=dark or ?theme=light)
  const params = new URLSearchParams(window.location.search);
  const param = params.get('theme');
  if (param === 'dark' || param === 'light') {
    document.documentElement.setAttribute('data-theme', param);
    localStorage.setItem('theme', param);
    return;
  }
  // localStorage preference
  const saved = localStorage.getItem('theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
  } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script>
</body>
</html>
