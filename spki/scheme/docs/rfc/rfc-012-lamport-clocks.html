<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RFC-012: Lamport Logical Clocks</title>
  <link rel="stylesheet" href="rfc.css">
</head>
<body>
<h1>RFC-012: Lamport Logical Clocks</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This RFC specifies Lamport logical clocks for Cyberspace distributed ordering, providing a happened-before relation across federated vaults without synchronized physical clocks.</p>
</section>
<section>
<h2>Motivation</h2>
<p>Physical clocks lie:</p>
<p>- Clock skew: Machines disagree on time - Clock drift: Skew grows over time - NTP failures: Synchronization breaks - Relativity: No global "now" anyway</p>
<p>Lamport clocks provide:</p>
<p>1. Logical ordering: a → b means a happened before b 2. No synchronization: No NTP, no GPS, no trusted time 3. Causality tracking: If a caused b, then C(a) &lt; C(b) 4. Consistency: All nodes agree on partial order</p>
<p>From Lamport (1978):</p>
<blockquote>
<p>Time, Clocks, and the Ordering of Events in a Distributed System</p>
</blockquote>
</section>
<section>
<h2>Specification</h2>
<h3>The Happened-Before Relation</h3>
<p>Definition: a → b (a happened before b) if:</p>
<p>1. a and b are in same process and a comes before b, or 2. a is sending a message and b is receiving it, or 3. ∃c such that a → c and c → b (transitivity)</p>
<h3>Lamport Clock Rules</h3>
<p>Each process P maintains counter C(P):</p>
<pre>
Rule 1: Before each event, increment C(P)
         C(P) := C(P) + 1

Rule 2: When sending message m, attach C(P)
         send(m, C(P))

Rule 3: When receiving message (m, T), update clock
         C(P) := max(C(P), T) + 1
</pre>
<h3>Clock Condition</h3>
<p>If a → b then C(a) &lt; C(b).</p>
<p>Note: Converse is not guaranteed. C(a) &lt; C(b) does not imply a → b.</p>
</section>
<section>
<h2>Data Structures</h2>
<h3>Logical Timestamp</h3>
<pre class="language-scheme">
(define-record-type &lt;lamport-clock&gt;
  (make-lamport-clock counter node-id)
  lamport-clock?
  (counter clock-counter)
  (node-id clock-node-id))
</pre>
<h3>Timestamped Event</h3>
<pre class="language-scheme">
(define-record-type &lt;timestamped-event&gt;
  (make-timestamped-event clock event)
  timestamped-event?
  (clock event-clock)
  (event event-data))
</pre>
</section>
<section>
<h2>Operations</h2>
<h3>Increment (Local Event)</h3>
<pre class="language-scheme">
(define (clock-tick! clock)
  "Increment clock for local event"
  (set! (clock-counter clock)
        (+ 1 (clock-counter clock)))
  clock)
</pre>
<h3>Send (Message Departure)</h3>
<pre class="language-scheme">
(define (clock-send clock message)
  "Attach timestamp to outgoing message"
  (clock-tick! clock)
  (make-timestamped-message
    (clock-counter clock)
    (clock-node-id clock)
    message))
</pre>
<h3>Receive (Message Arrival)</h3>
<pre class="language-scheme">
(define (clock-receive! clock timestamped-message)
  "Update clock on message receipt"
  (let ((remote-time (message-timestamp timestamped-message)))
    (set! (clock-counter clock)
          (+ 1 (max (clock-counter clock) remote-time)))
    (message-payload timestamped-message)))
</pre>
</section>
<section>
<h2>Total Ordering</h2>
<p>Lamport clocks give partial order. For total order, break ties with node ID:</p>
<pre class="language-scheme">
(define (lamport-compare a b)
  "Total order: compare by timestamp, then by node-id"
  (let ((ta (clock-counter (event-clock a)))
        (tb (clock-counter (event-clock b)))
        (na (clock-node-id (event-clock a)))
        (nb (clock-node-id (event-clock b))))
    (cond
      ((&lt; ta tb) -1)
      ((&gt; ta tb) 1)
      ((string&lt;? na nb) -1)
      ((string&gt;? na nb) 1)
      (else 0))))
</pre>
</section>
<section>
<h2>Application to Cyberspace</h2>
<h3>Audit Trail Ordering</h3>
<pre class="language-scheme">
(audit-entry
  (lamport-clock 1042 "alice-vault")
  (timestamp "2026-01-06T15:30:00Z")  ; Physical (advisory)
  (action (seal-commit "abc123"))
  ...)
</pre>
<p>Logical clock provides causal ordering even if physical clocks differ.</p>
<h3>Federation Message Ordering</h3>
<pre class="language-scheme">
(federation-message
  (logical-time 573)
  (from "bob-vault")
  (type announcement)
  (payload ...))
</pre>
<p>Receivers update their clocks, ensuring consistent view of causality.</p>
<h3>Conflict Detection</h3>
<p>If events are concurrent (neither a → b nor b → a):</p>
<pre class="language-scheme">
(define (concurrent? a b)
  "True if neither event happened before the other"
  (let ((ta (clock-counter (event-clock a)))
        (tb (clock-counter (event-clock b))))
    ;; If timestamps equal and different nodes, concurrent
    ;; More sophisticated: use vector clocks for accurate detection
    (and (= ta tb)
         (not (equal? (clock-node-id (event-clock a))
                      (clock-node-id (event-clock b)))))))
</pre>
</section>
<section>
<h2>Vector Clocks (Extension)</h2>
<p>For precise concurrency detection, use vector clocks:</p>
<pre class="language-scheme">
(define-record-type &lt;vector-clock&gt;
  (make-vector-clock entries)
  vector-clock?
  (entries vc-entries))  ; Hash: node-id → counter

;; a → b iff VC(a) &lt; VC(b) (component-wise)
;; a || b (concurrent) iff neither VC(a) &lt; VC(b) nor VC(b) &lt; VC(a)
</pre>
<p>Trade-off: O(N) space vs O(1) for Lamport clocks.</p>
</section>
<section>
<h2>Integration Points</h2>
<h3>With Audit Trail (RFC-003)</h3>
<pre class="language-scheme">
(audit-entry
  (sequence 42)           ; Local sequence
  (lamport-clock 1042)    ; Logical timestamp
  (physical-time "...")   ; Advisory only
  ...)
</pre>
<h3>With Consensus (RFC-011)</h3>
<pre class="language-scheme">
(consensus-message
  (sequence 573)          ; Consensus sequence
  (lamport-clock 2891)    ; Causal context
  ...)
</pre>
<h3>With Replication (RFC-001)</h3>
<pre class="language-scheme">
(seal-publish "2.0.0"
  (logical-time 892)
  ...)
</pre>
</section>
<section>
<h2>Security Considerations</h2>
<h3>Clock Manipulation</h3>
<p>A Byzantine node could: - Report artificially high clock values - Attempt to order events incorrectly</p>
<p>Mitigations: - Clock values bounded by received values + margin - Signatures prevent retroactive tampering - Audit trails detect anomalies</p>
<h3>Denial of Service</h3>
<p>Flooding with high-timestamped messages forces clock advancement.</p>
<p>Mitigation: Rate limiting, reputation systems.</p>
</section>
<section>
<h2>Implementation Notes</h2>
<h3>Thread Safety</h3>
<p>Clock updates must be atomic:</p>
<pre class="language-scheme">
(define (atomic-tick! clock)
  (mutex-lock! clock-mutex)
  (clock-tick! clock)
  (mutex-unlock! clock-mutex))
</pre>
<h3>Persistence</h3>
<p>Clock state survives restarts:</p>
<pre class="language-scheme">
(define (save-clock clock path)
  (with-output-to-file path
    (lambda ()
      (write `(lamport-clock
                (counter ,(clock-counter clock))
                (node-id ,(clock-node-id clock)))))))
</pre>
</section>
<section>
<h2>References</h2>
<p>1. Lamport, L. (1978). Time, Clocks, and the Ordering of Events in a Distributed System. 2. Fidge, C. J. (1988). Timestamps in Message-Passing Systems. 3. Mattern, F. (1989). Virtual Time and Global States of Distributed Systems. 4. RFC-003: Cryptographic Audit Trail 5. RFC-010: Federation Protocol</p>
</section>
<section>
<h2>Changelog</h2>
<p>- 2026-01-06 - Initial specification</p>
</section>
</body>
</html>
