RFC-036: Quorum Protocol with Homomorphic Voting


------------------------------------------------------------------------------

------------------------------------------------------------------------------
ABSTRACT
------------------------------------------------------------------------------

This RFC specifies the quorum protocol for the Library of Cyberspace: how
principals reach collective decisions through homomorphic encryption-based
voting, enabling private ballot tallying without revealing individual votes.
Quorum integrates with threshold governance (RFC-007) and Byzantine consensus
(RFC-011).


------------------------------------------------------------------------------
MOTIVATION
------------------------------------------------------------------------------

Collective decisions require:

  * Privacy
  * Voters shouldn't know how others voted
  * Verifiability
  * Results must be provably correct
  * Coercion resistance
  * Can't prove how you voted to others
  * Availability
  * Voting continues despite failures

Traditional approaches fail:

  * Open ballot
  * No privacy, enables coercion
  * Trusted tallier
  * Single point of compromise
  * Secure multi-party computation
  * Complex, high communication overhead

Homomorphic encryption provides:

  * Vote on encrypted ballots
  * Sum without decryption
  * Decrypt only the final tally
  * Mathematical proof of correctness


------------------------------------------------------------------------------
CRYPTOGRAPHIC FOUNDATION
------------------------------------------------------------------------------


Homomorphic Encryption Schemes
------------------------------


  Scheme              Operations          Performance         Use Case            
  Paillier            Addition            Fast                Vote tallying       
  BFV/BGV             Add + Multiply      Medium              Complex predicates  
  TFHE                Arbitrary           Slow                General computation 

For quorum voting, Paillier suffices - we only need addition.


Paillier Properties
-------------------


    ;; Additive homomorphism
    (= (decrypt (he-add (encrypt a) (encrypt b)))
       (+ a b))
    ;; Scalar multiplication via repeated addition
    (= (decrypt (he-scalar-mult (encrypt a) k))
       (* a k))
    ;; Semantic security - ciphertexts indistinguishable
    (not (distinguishable? (encrypt 0) (encrypt 1)))


Key Generation
--------------


    (define-record-type <quorum-keys>
      (make-quorum-keys public private threshold shares)
      quorum-keys?
      (public qk-public)           ; Public encryption key
      (private qk-private)         ; Private decryption key (or #f if distributed)
      (threshold qk-threshold)     ; M-of-N threshold
      (shares qk-shares))          ; Distributed key shares
    (define (generate-quorum-keys bit-length threshold trustees)
      "Generate threshold Paillier keys"
      (let* ((keys (paillier-keygen bit-length))
             (shares (shamir-split (paillier-private keys)
                                   threshold
                                   (length trustees))))
        (make-quorum-keys
          (paillier-public keys)
          #f  ; No single party holds private key
          threshold
          (map cons trustees shares))))


------------------------------------------------------------------------------
BALLOT STRUCTURE
------------------------------------------------------------------------------


Ballot Definition
-----------------


    (define-record-type <ballot>
      (make-ballot id question options threshold deadline)
      ballot?
      (id ballot-id)                 ; Content hash
      (question ballot-question)     ; Human-readable question
      (options ballot-options)       ; List of choices
      (threshold ballot-threshold)   ; Votes needed to pass
      (deadline ballot-deadline))    ; Voting closes
    ;; Example ballot
    (make-ballot
      id: "sha256:ballot..."
      question: "Accept RFC-042 into standard?"
      options: '(accept reject abstain)
      threshold: '(majority members)  ; >50% of members
      deadline: 1767786000)


Encrypted Vote
--------------


    (define-record-type <encrypted-vote>
      (make-encrypted-vote ballot-id voter ciphertext proof timestamp signature)
      encrypted-vote?
      (ballot-id vote-ballot-id)     ; Which ballot
      (voter vote-voter)             ; Voter's public key (or anonymous token)
      (ciphertext vote-ciphertext)   ; HE-encrypted choice
      (proof vote-proof)             ; Zero-knowledge proof of validity
      (timestamp vote-timestamp)
      (signature vote-signature))


Vote Encoding
-------------


    ;; One-hot encoding for multiple choices
    ;; accept=1, reject=0, abstain=0 â†’ (1, 0, 0)
    (define (encode-vote choice options)
      "Encode choice as one-hot vector"
      (map (lambda (opt)
             (if (eq? opt choice) 1 0))
           options))
    (define (encrypt-vote choice options public-key)
      "Encrypt one-hot encoded vote"
      (map (lambda (v)
             (paillier-encrypt public-key v))
           (encode-vote choice options)))
    ;; Vote for "accept"
    (encrypt-vote 'accept '(accept reject abstain) pub-key)
    ;; => (Enc(1), Enc(0), Enc(0))


------------------------------------------------------------------------------
VOTING PROTOCOL
------------------------------------------------------------------------------


Phase 1: Ballot Creation
------------------------


    (define (create-ballot question options threshold deadline trustees)
      "Create new ballot with threshold decryption"
      (let* ((keys (generate-quorum-keys 2048
                                         (ceiling (/ (length trustees) 2))
                                         trustees))
             (ballot (make-ballot
                       question: question
                       options: options
                       threshold: threshold
                       deadline: deadline)))
        ;; Distribute key shares to trustees
        (for-each (lambda (trustee share)
                    (secure-send trustee
                      `(key-share
                        (ballot-id ,(ballot-id ballot))
                        (share ,share))))
                  trustees
                  (qk-shares keys))
        ;; Publish ballot
        (soup-put ballot type: 'ballot)
        (audit-append action: 'ballot-created
                      ballot: (ballot-id ballot))
        ballot))


Phase 2: Vote Casting
---------------------


    (define (cast-vote ballot choice voter-key)
      "Cast encrypted vote with validity proof"
      (let* ((pub-key (ballot-public-key ballot))
             (encrypted (encrypt-vote choice (ballot-options ballot) pub-key))
             (proof (generate-validity-proof encrypted choice pub-key))
             (vote (make-encrypted-vote
                     ballot-id: (ballot-id ballot)
                     voter: (key->principal voter-key)
                     ciphertext: encrypted
                     proof: proof
                     timestamp: (current-time))))
        ;; Sign the vote
        (set-encrypted-vote-signature! vote
          (sign-vote voter-key vote))
        ;; Submit
        (submit-vote vote)
        vote))
    (define (submit-vote vote)
      "Submit vote to ballot coordinator"
      ;; Verify eligibility
      (unless (eligible-voter? (vote-voter vote) (vote-ballot-id vote))
        (error 'not-eligible))
      ;; Verify validity proof
      (unless (verify-validity-proof vote)
        (error 'invalid-vote-proof))
      ;; Verify not already voted
      (when (already-voted? (vote-voter vote) (vote-ballot-id vote))
        (error 'already-voted))
      ;; Record vote
      (soup-put vote type: 'encrypted-vote)
      (audit-append action: 'vote-cast
                    ballot: (vote-ballot-id vote)
                    voter: (vote-voter vote)))


Phase 3: Homomorphic Tallying
-----------------------------


    (define (tally-votes ballot)
      "Homomorphically sum all votes"
      (let* ((votes (soup-query type: 'encrypted-vote
                                ballot-id: (ballot-id ballot)))
             (num-options (length (ballot-options ballot)))
             (zero-tally (make-list num-options (paillier-encrypt-zero))))
        ;; Sum encrypted votes
        (fold (lambda (vote tally)
                (map paillier-add
                     (vote-ciphertext vote)
                     tally))
              zero-tally
              votes)))
    ;; After tallying 100 votes:
    ;; (Enc(47), Enc(41), Enc(12))
    ;; Still encrypted - no one knows the result yet


Phase 4: Threshold Decryption
-----------------------------


    (define (decrypt-tally ballot encrypted-tally)
      "Threshold decrypt the tally"
      (let* ((trustees (ballot-trustees ballot))
             (threshold (ballot-key-threshold ballot))
             (shares '()))
        ;; Collect decryption shares
        (for-each (lambda (trustee)
                    (let ((share (request-decryption-share trustee
                                   (ballot-id ballot)
                                   encrypted-tally)))
                      (when share
                        (set! shares (cons share shares)))))
                  trustees)
        ;; Need threshold shares
        (unless (>= (length shares) threshold)
          (error 'insufficient-decryption-shares))
        ;; Combine shares to decrypt
        (let ((plaintext-tally
               (map (lambda (ct)
                      (threshold-decrypt ct shares))
                    encrypted-tally)))
          ;; Publish result
          (publish-result ballot plaintext-tally)
          plaintext-tally)))
    (define (request-decryption-share trustee ballot-id encrypted-tally)
      "Request trustee's decryption share"
      (let ((response (tunnel trustee
                        `(decryption-share-request
                          (ballot-id ,ballot-id)
                          (tally ,encrypted-tally)))))
        (and (valid-share? response)
             response)))


Phase 5: Result Publication
---------------------------


    (define (publish-result ballot tally)
      "Publish verified result"
      (let* ((options (ballot-options ballot))
             (result (map cons options tally))
             (winner (determine-winner result (ballot-threshold ballot))))
        (soup-put
          `(ballot-result
            (ballot-id ,(ballot-id ballot))
            (tally ,result)
            (winner ,winner)
            (timestamp ,(current-time))
            (total-votes ,(apply + tally)))
          type: 'ballot-result)
        (audit-append action: 'ballot-result
                      ballot: (ballot-id ballot)
                      result: result
                      winner: winner)))


------------------------------------------------------------------------------
ZERO-KNOWLEDGE PROOFS
------------------------------------------------------------------------------


Vote Validity Proof
-------------------

Prove vote is valid (exactly one 1, rest 0s) without revealing which:


    (define (generate-validity-proof encrypted-vote choice public-key)
      "ZK proof that vote encodes valid choice"
      ;; Disjunctive proof: prove one of N possibilities
      ;; Without revealing which
      (let ((n (length encrypted-vote)))
        (make-or-proof
          (map (lambda (i)
                 (if (= i (choice-index choice))
                     ;; Real proof for actual choice
                     (make-encryption-proof (list-ref encrypted-vote i) 1 public-key)
                     ;; Simulated proof for other choices
                     (simulate-encryption-proof (list-ref encrypted-vote i) 1 public-key)))
               (iota n)))))
    (define (verify-validity-proof vote)
      "Verify vote validity without learning choice"
      (let ((proof (vote-proof vote))
            (ciphertext (vote-ciphertext vote))
            (pub-key (ballot-public-key (vote-ballot-id vote))))
        ;; Verify OR proof
        (and (verify-or-proof proof ciphertext pub-key)
             ;; Verify sum of encrypted values equals Enc(1)
             (verify-sum-equals-one ciphertext pub-key))))


Decryption Share Proof
----------------------

Prove decryption share is correct:


    (define (generate-share-proof share ciphertext trustee-key)
      "ZK proof that decryption share is correct"
      (make-dlog-proof
        (share-value share)
        trustee-key
        ciphertext))
    (define (verify-share-proof share ciphertext trustee-pubkey)
      "Verify decryption share correctness"
      (verify-dlog-proof
        (share-proof share)
        (share-value share)
        trustee-pubkey
        ciphertext))


------------------------------------------------------------------------------
VOTER PRIVACY
------------------------------------------------------------------------------


Anonymous Voting Tokens
-----------------------


    (define (issue-voting-token voter-key ballot-id issuer-key)
      "Issue blind voting token"
      ;; Voter blinds their key
      (let* ((blinding-factor (random-scalar))
             (blinded-key (blind-key voter-key blinding-factor)))
        ;; Issuer signs blinded key
        (let ((blind-signature (sign issuer-key blinded-key)))
          ;; Voter unblinds signature
          (let ((token (unblind-signature blind-signature blinding-factor)))
            ;; Token proves eligibility without linking to voter
            (make-voting-token
              ballot-id: ballot-id
              token: token
              ;; Cannot be linked to voter-key
              )))))
    (define (vote-anonymously ballot choice token)
      "Cast vote using anonymous token"
      (let ((vote (cast-vote ballot choice token)))
        ;; Vote linked to token, not voter identity
        vote))


Receipt-Freeness
----------------

Voters cannot prove how they voted (prevents vote buying/coercion):


    ;; Re-encryption mixnet for receipt-freeness
    (define (submit-through-mixnet vote mixnet-nodes)
      "Submit vote through re-encryption mixnet"
      (fold (lambda (node encrypted-vote)
              ;; Each node re-encrypts
              (let ((re-encrypted (paillier-rerandomize encrypted-vote)))
                ;; Shuffle with other votes
                (mixnet-shuffle node re-encrypted)))
            vote
            mixnet-nodes))


------------------------------------------------------------------------------
QUORUM TYPES
------------------------------------------------------------------------------


Simple Majority
---------------


    (define (simple-majority tally total-eligible)
      "More than half of voters"
      (let ((total-votes (apply + tally))
            (winning-votes (apply max tally)))
        (> winning-votes (/ total-votes 2))))


Supermajority
-------------


    (define (supermajority tally fraction)
      "Require fraction (e.g., 2/3) agreement"
      (let ((total-votes (apply + tally))
            (winning-votes (apply max tally)))
        (>= winning-votes (* fraction total-votes))))


Threshold of Eligible
---------------------


    (define (threshold-of-eligible tally total-eligible threshold)
      "Require threshold of all eligible voters"
      (let ((winning-votes (apply max tally)))
        (>= winning-votes (* threshold total-eligible))))


Weighted Voting
---------------


    (define (weighted-vote voter-key weight choice ballot)
      "Cast vote with weight"
      ;; Encode weight in vote
      (let ((encoded (map (lambda (v) (* v weight))
                          (encode-vote choice (ballot-options ballot)))))
        (encrypt-vote-vector encoded (ballot-public-key ballot))))


------------------------------------------------------------------------------
INTEGRATION WITH GOVERNANCE
------------------------------------------------------------------------------


RFC-007 Threshold Governance
----------------------------


    ;; Quorum voting for threshold operations
    (define (threshold-operation-vote operation trustees)
      "Vote on threshold operation"
      (let ((ballot (create-ballot
                      question: (format "Approve ~a?" operation)
                      options: '(approve reject)
                      threshold: '(supermajority 2/3)
                      deadline: (+ (current-time) 86400)
                      trustees: trustees)))
        ;; Wait for voting
        (await-ballot-result ballot)))


RFC-011 Byzantine Consensus
---------------------------


    ;; Use quorum voting within Byzantine protocol
    (define (byzantine-propose-vote proposal validators)
      "Propose via encrypted voting"
      (let ((ballot (create-ballot
                      question: proposal
                      options: '(commit abort)
                      threshold: '(byzantine-quorum (length validators))
                      trustees: validators)))
        ballot))
    (define (byzantine-quorum n)
      "2f+1 for n=3f+1 validators"
      (+ (* 2 (floor (/ (- n 1) 3))) 1))


Key Ceremony Voting
-------------------


    ;; Vote to approve key ceremony
    (define (key-ceremony-approval ceremony guardians)
      "Guardians vote to approve ceremony"
      (let ((ballot (create-ballot
                      question: (format "Approve key ceremony ~a?" (ceremony-id ceremony))
                      options: '(approve reject)
                      threshold: '(unanimous)
                      deadline: (+ (current-time) 3600)
                      trustees: guardians)))
        (let ((result (await-ballot-result ballot)))
          (if (eq? (result-winner result) 'approve)
              (proceed-ceremony ceremony)
              (abort-ceremony ceremony)))))


------------------------------------------------------------------------------
SECURITY CONSIDERATIONS
------------------------------------------------------------------------------


Cryptographic Assumptions
-------------------------


  Assumption          Primitive           Consequence if Broke
  Decisional CompositePaillier            Vote privacy lost   
  Discrete Log        ZK proofs           Validity unverifiabl
  Random Oracle       Hash functions      Proof forgery       


Attack Mitigations
------------------


  Attack              Mitigation          
  Vote buying         Receipt-freeness via
  Coercion            Deniable voting toke
  Ballot stuffing     Eligibility proofs, 
  Tally manipulation  Threshold decryption
  Denial of service   Rate limiting, deadl


Audit Trail
-----------


    ;; All voting actions audited
    (audit-append action: 'ballot-created ...)
    (audit-append action: 'vote-cast ...)      ; Voter ID, not choice
    (audit-append action: 'tally-computed ...)
    (audit-append action: 'share-provided ...)
    (audit-append action: 'result-published ...)


------------------------------------------------------------------------------
PERFORMANCE CONSIDERATIONS
------------------------------------------------------------------------------


Paillier Costs
--------------


  Operation           Time (2048-bit)     
  Key generation      ~100ms              
  Encrypt             ~5ms                
  Homomorphic add     ~0.1ms              
  Decrypt             ~5ms                
  Threshold decrypt   ~10ms per share     


Scalability
-----------


    ;; For N voters, M options:
    ;; - Encryption: O(N  M) operations
    ;; - Tallying: O(N  M) additions (fast)
    ;; - Decryption: O(M * threshold) operations
    ;; 10,000 voters, 3 options, 5 trustees:
    ;; ~50,000 encryptions (parallel)
    ;; ~30,000 additions (<1 second)
    ;; ~15 decryptions (~150ms)


------------------------------------------------------------------------------
IMPLEMENTATION NOTES
------------------------------------------------------------------------------


Dependencies
------------

  * paillier
  * Paillier cryptosystem - shamir
  * Secret sharing for threshold keys - zkp
  * Zero-knowledge proof primitives - srfi-27
  * Random number generation


Libraries
---------

Recommended implementations: - OpenFHE (C++) - Full HE library -
python-paillier - Reference implementation - threshold-paillier - Distributed
key generation


------------------------------------------------------------------------------
REFERENCES
------------------------------------------------------------------------------

1. Paillier, P. (1999). Public-Key Cryptosystems Based on Composite Degree
Residuosity Classes 2. Benaloh, J. (1994). Dense Probabilistic Encryption 3.
Cramer, R., Gennaro, R., Schoenmakers, B. (1997). A Secure and Optimally
Efficient Multi-Authority Election Scheme 4. RFC-007: Threshold Signature
Governance 5. RFC-011: Byzantine Consensus 6. RFC-022: Key Ceremony Protocol


------------------------------------------------------------------------------
CHANGELOG
------------------------------------------------------------------------------

  * 2026-01-07
  * Initial draft

------------------------------------------------------------------------------
