<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RFC-006: Vault System Architecture</title>
  <link rel="stylesheet" href="rfc.css">
</head>
<body>
<h1>RFC-006: Vault System Architecture</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This RFC specifies the Vault system for the Library of Cyberspace: cryptographically sealed version control with SPKI authorization, progressive metadata, archival support, and integrated audit trails.</p>
</section>
<section>
<h2>Motivation</h2>
<p>Git is powerful but lacks:</p>
<p>1. Cryptographic sealing - GPG signing is optional and awkward 2. Authorization model - Anyone with access can commit 3. Archival features - No first-class backup/restore 4. Audit integration - History is mutable</p>
<p>The Vault wraps Git with:</p>
<p>- seal- commands that cryptographically sign operations - SPKI certificates for authorization - Three archive formats for different use cases - Integrated audit trail for non-repudiation</p>
<pre>
                    ╭────────────────────────────────╮
                    │         CYBERSPACE VAULT       │
                    ├────────────────────────────────┤
                    │  seal-commit    seal-release   │
                    │  seal-archive   seal-publish   │
                    │  seal-verify    seal-subscribe │
                    ├────────────────────────────────┤
                    │         Audit Trail            │
                    ├────────────────────────────────┤
                    │         SPKI Certs             │
                    ├────────────────────────────────┤
                    │            Git                 │
                    ╰────────────────────────────────╯
</pre>
</section>
<section>
<h2>Core Operations</h2>
<h3>seal-commit</h3>
<p>Stage and commit changes in one operation.</p>
<pre class="language-scheme">
(seal-commit message
  #!key files catalog subjects keywords description preserve)
</pre>
<p>Parameters: - message - Commit message (required) - files - Specific files to stage (optional) - catalog - Enable catalog metadata - subjects - Subject headings - keywords - Search keywords - description - Extended description - preserve - Enable preservation metadata</p>
<p>Process: 1. Stage specified files (or all modified) 2. Create git commit 3. Save metadata (if catalog or preserve) 4. Record in audit trail (if signing key configured)</p>
<p>Example:</p>
<pre class="language-scheme">
(seal-commit "Add authentication module"
  files: '("auth.scm" "auth-test.scm")
  catalog: #t
  subjects: '("security" "authentication")
  keywords: '("login" "oauth"))
</pre>
<h3>seal-update</h3>
<p>Pull latest changes from remote.</p>
<pre class="language-scheme">
(seal-update #!key branch)
</pre>
<p>Like svn update - fetches and fast-forwards.</p>
<h3>seal-undo</h3>
<p>Undo changes.</p>
<pre class="language-scheme">
(seal-undo #!key file hard)
</pre>
<p>- file - Restore specific file - hard - Discard all uncommitted changes</p>
<h3>seal-history</h3>
<p>Show commit history.</p>
<pre class="language-scheme">
(seal-history #!key count)
</pre>
<p>Displays decorated graph log.</p>
<h3>seal-branch / seal-merge</h3>
<p>Branch and merge operations.</p>
<pre class="language-scheme">
(seal-branch "feature-auth" #!key from)
(seal-merge "feature-auth" #!key strategy)
</pre>
</section>
<section>
<h2>Version Management</h2>
<h3>seal-release</h3>
<p>Create cryptographically sealed release.</p>
<pre class="language-scheme">
(seal-release version #!key message migrate-from)
</pre>
<p>Parameters: - version - Semantic version (X.Y.Z required) - message - Release notes - migrate-from - Previous version for migration tracking</p>
<p>Process: 1. Validate semantic version format 2. Get current commit hash 3. Create annotated git tag 4. Sign with SPKI (if configured) 5. Create migration marker (if migrate-from specified)</p>
<p>Signature Storage:</p>
<pre class="language-scheme">
;; .vault/releases/1.0.0.sig
(signature
  (version "1.0.0")
  (hash "abc123...")
  (manifest "(release \"1.0.0\" \"abc123\" 1767685100)")
  (signature #${ed25519-signature}))
</pre>
<h3>seal-verify</h3>
<p>Verify release signature.</p>
<pre class="language-scheme">
(seal-verify version #!key verify-key)
</pre>
<p>Process: 1. Load signature file 2. Recompute manifest hash 3. Verify Ed25519 signature</p>
</section>
<section>
<h2>Archival System</h2>
<h3>seal-archive</h3>
<p>Create sealed archive of a version.</p>
<pre class="language-scheme">
(seal-archive version #!key format output)
</pre>
<p>Formats:</p>
<p>#### Tarball (default)</p>
<pre class="language-scheme">
(seal-archive "1.0.0" format: 'tarball)
</pre>
<p>- Standard gzipped tarball - No history included - Smallest size</p>
<p>#### Git Bundle</p>
<pre class="language-scheme">
(seal-archive "1.0.0" format: 'bundle)
</pre>
<p>- Full git history - Can clone directly - Medium size</p>
<p>#### Cryptographic (legacy)</p>
<pre class="language-scheme">
(seal-archive "1.0.0" format: 'cryptographic)
</pre>
<p>- Tarball + SHA-512 hash + Ed25519 signature - Tamper-evident - Manifest for verification</p>
<p>#### Zstd+Age (preferred)</p>
<pre class="language-scheme">
(seal-archive "1.0.0" format: 'zstd-age)
</pre>
<p>- Zstd compression (faster, better ratio than gzip) - Age encryption (X25519/Ed25519 compatible) - SHA-512 hash + Ed25519 signature - Encrypted at rest - See RFC-018: Sealed Archive Format for full specification</p>
<p>Cryptographic Archive Structure:</p>
<pre>
vault-1.0.0.archive        # Manifest
vault-1.0.0.archive.tar.gz # Tarball (cryptographic)
</pre>
<p>Zstd+Age Archive Structure:</p>
<pre>
vault-1.0.0.archive            # Manifest
vault-1.0.0.archive.tar.zst.age # Encrypted archive
</pre>
<p>Manifest (cryptographic):</p>
<pre class="language-scheme">
(sealed-archive
  (version "1.0.0")
  (format cryptographic)
  (tarball "vault-1.0.0.archive.tar.gz")
  (hash "sha512:...")
  (signature "ed25519:..."))
</pre>
<p>Manifest (zstd-age):</p>
<pre class="language-scheme">
(sealed-archive
  (version "1.0.0")
  (format zstd-age)
  (archive "vault-1.0.0.archive.tar.zst.age")
  (compression zstd)
  (encryption age)
  (recipients ("age1..."))
  (hash "sha512:...")
  (signature "ed25519:..."))
</pre>
<h3>seal-restore</h3>
<p>Restore from sealed archive.</p>
<pre class="language-scheme">
(seal-restore archive #!key verify-key target identity)
</pre>
<p>Parameters: - verify-key - SPKI public key for signature verification - target - Extraction directory - identity - Age identity file for decryption (zstd-age format)</p>
<p>Process: 1. Read manifest 2. Verify hash (archive integrity) 3. Verify signature (if key provided) 4. Decrypt (zstd-age only, requires identity) 5. Extract to target directory</p>
</section>
<section>
<h2>Replication Layer</h2>
<p>See RFC-001 for complete specification.</p>
<h3>seal-publish</h3>
<p>Publish release to remote.</p>
<pre class="language-scheme">
(seal-publish version #!key remote archive-format message)
</pre>
<p>Supports: - Git remotes (push tags) - HTTP endpoints (POST) - Filesystem paths (copy)</p>
<h3>seal-subscribe</h3>
<p>Subscribe to releases from remote.</p>
<pre class="language-scheme">
(seal-subscribe remote #!key target verify-key)
</pre>
<p>Downloads and optionally verifies remote releases.</p>
<h3>seal-synchronize</h3>
<p>Bidirectional sync.</p>
<pre class="language-scheme">
(seal-synchronize remote #!key direction verify-key)
</pre>
</section>
<section>
<h2>Configuration</h2>
<h3>vault-init</h3>
<p>Initialize vault for repository.</p>
<pre class="language-scheme">
(vault-init #!key signing-key)
</pre>
<p>Sets up: - Signing key configuration - Audit trail directory - Metadata directory</p>
<h3>vault-config</h3>
<p>Get/set configuration.</p>
<pre class="language-scheme">
(vault-config 'signing-key)              ; Get
(vault-config 'signing-key some-key)     ; Set
</pre>
<p>Configuration Options:</p>
<table>
<tr><th>Key </th><th>Type </th><th>Description </th></tr>
<tr><td>signing-key </td><td>blob </td><td>Ed25519 private key for signing </td></tr>
<tr><td>verify-key </td><td>string </td><td>Path to verification public key </td></tr>
<tr><td>archive-format </td><td>symbol </td><td>Default: tarball, bundle, cryptographic, or zstd-age </td></tr>
<tr><td>age-recipients </td><td>list </td><td>Age public keys for encryption (zstd-age format) </td></tr>
<tr><td>age-identity </td><td>string </td><td>Path to age identity file for decryption </td></tr>
<tr><td>migration-dir </td><td>string </td><td>Directory for migration scripts </td></tr>
<tr><td>track-metadata </td><td>boolean </td><td>Auto-stage metadata files </td></tr>
<tr><td>publish-remote </td><td>string </td><td>Default publication target </td></tr>
<tr><td>subscribe-dir </td><td>string </td><td>Directory for subscriptions </td></tr>
</table>
</section>
<section>
<h2>Directory Structure</h2>
<pre>
project/
├── .vault/
│   ├── metadata/           # Commit metadata files
│   │   ├── abc123.sexp
│   │   └── def456.sexp
│   ├── releases/           # Release signatures
│   │   ├── 1.0.0.sig
│   │   └── 1.1.0.sig
│   ├── audit/              # Audit trail
│   │   ├── 1.sexp
│   │   └── 2.sexp
│   └── subscriptions/      # Downloaded releases
│       └── vault-1.0.0.archive
├── migrations/             # Version migration scripts
│   └── 1.0.0-to-2.0.0.scm
└── .git/                   # Git repository
</pre>
</section>
<section>
<h2>Migration Support</h2>
<h3>Creating Migrations</h3>
<pre class="language-scheme">
(seal-release "2.0.0" migrate-from: "1.0.0")
</pre>
<p>Generates template:</p>
<pre class="language-scheme">
;; migrations/1.0.0-to-2.0.0.scm
;;; Migration: 1.0.0 -&gt; 2.0.0
;;; Generated: 1767685100

(define (migrate-1.0.0-to-2.0.0)
  ;; Define migration logic here
  #t)

(migrate-1.0.0-to-2.0.0)
</pre>
<h3>Running Migrations</h3>
<pre class="language-scheme">
(seal-migrate "1.0.0" "2.0.0" #!key script dry-run)
</pre>
</section>
<section>
<h2>Integrity Checking</h2>
<h3>seal-check</h3>
<p>Verify vault integrity.</p>
<pre class="language-scheme">
(seal-check #!key deep)
</pre>
<p>Checks: - Git repository health (git fsck) - Release signature validity (if deep) - Audit trail chain (if deep)</p>
</section>
<section>
<h2>Security Model</h2>
<h3>Signing Key Handling</h3>
<pre class="language-scheme">
;; Key is 64-byte Ed25519 secret key
;; First 32 bytes: seed
;; Last 32 bytes: public key

(define (get-vault-principal signing-key)
  "Extract public key from signing key"
  (blob-copy signing-key 32 32))
</pre>
<h3>Authorization Flow</h3>
<p>1. Configure: (vault-init signing-key: key) 2. Operate: (seal-commit ...) signs with configured key 3. Audit: Entry includes actor's public key 4. Verify: (seal-verify ...) checks signature</p>
<h3>Threat Mitigations</h3>
<table>
<tr><th>Threat </th><th>Mitigation </th></tr>
<tr><td>Unauthorized commits </td><td>SPKI certificates required </td></tr>
<tr><td>Release tampering </td><td>Ed25519 signatures </td></tr>
<tr><td>History rewriting </td><td>Audit trail non-repudiation </td></tr>
<tr><td>Archive corruption </td><td>SHA-512 hash verification </td></tr>
</table>
</section>
<section>
<h2>Integration Points</h2>
<h3>With Audit Trail (RFC-003)</h3>
<p>All vault operations create audit entries:</p>
<pre class="language-scheme">
(audit-append
  actor: (get-vault-principal signing-key)
  action: '(seal-commit "hash123")
  motivation: message)
</pre>
<h3>With SPKI (RFC-004)</h3>
<p>Signing keys are SPKI principals:</p>
<pre class="language-scheme">
(make-key-principal (get-vault-principal signing-key))
</pre>
<h3>With Metadata (RFC-005)</h3>
<p>Progressive metadata via seal-commit parameters:</p>
<pre class="language-scheme">
(seal-commit "msg" preserve: #t)  ; Full preservation
</pre>
</section>
<section>
<h2>Usage Examples</h2>
<h3>Basic Workflow</h3>
<pre class="language-scheme">
;; Initialize
(vault-init signing-key: my-key)

;; Daily work
(seal-commit "Add feature")
(seal-commit "Fix bug")

;; Release
(seal-release "1.0.0" message: "Initial release")

;; Archive
(seal-archive "1.0.0" format: 'cryptographic)

;; Verify
(seal-verify "1.0.0" verify-key: "my.public")
</pre>
<h3>Federation Workflow</h3>
<pre class="language-scheme">
;; Publisher
(seal-release "1.0.0")
(seal-publish "1.0.0" remote: "/shared/releases")

;; Subscriber
(seal-subscribe "/shared/releases" verify-key: publisher-pub)

;; Bidirectional
(seal-synchronize peer-remote direction: 'both)
</pre>
</section>
<section>
<h2>Document Formats</h2>
<p>The Vault preserves documents in canonical open formats:</p>
<table>
<tr><th>Format </th><th>Extension </th><th>Purpose </th></tr>
<tr><td>Text </td><td>.txt </td><td>Universal compatibility, IETF tradition, immortal </td></tr>
<tr><td>PostScript </td><td>.ps </td><td>Archival, printing, open since 1984 </td></tr>
<tr><td>Hypertext Markup Language </td><td>.html </td><td>Web viewing </td></tr>
</table>
<p>All formats are first-class citizens in the Vault. RFCs and declarations SHOULD be published in all three formats for maximum preservation and accessibility. No proprietary formats.</p>
</section>
<section>
<h2>References</h2>
<p>1. Git Internals - Plumbing and Porcelain 2. RFC-001: Replication Layer 3. RFC-003: Cryptographic Audit Trail 4. RFC-004: SPKI Authorization 5. RFC-005: Progressive Metadata Levels 6. RFC-018: Sealed Archive Format 7. Semantic Versioning 2.0.0</p>
</section>
<section>
<h2>Changelog</h2>
<p>- 2026-01-06 - Initial specification</p>
</section>
</body>
</html>
