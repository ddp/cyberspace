RFC-035: Mobile Agents and Pub/Sub

Status: Draft Date: January 2026 Author: Derrell Piper ddp@eludom.net
Implementation: Proposed

------------------------------------------------------------------------------

Abstract

This RFC specifies the mobile agent architecture for the Library of
Cyberspace: Telescript-inspired agents that migrate between realms, carry SPKI
credentials, communicate via pub/sub channels, and operate under realm
coordinator supervision. Agents are first-class citizens with cryptographic
identity.

------------------------------------------------------------------------------

Motivation

Distributed computation requires mobile code:

- Latency - Move computation to data, not data to computation
- Autonomy - Agents act on behalf of principals when disconnected
- Coordination - Pub/sub enables loose coupling across realms
- Accountability - Every agent action is auditable

General Magic’s Telescript (1994) pioneered these ideas. We preserve the good
parts while integrating with SPKI capabilities and content-addressed storage.

------------------------------------------------------------------------------

Agent Model

What is an Agent?

An agent is:

1.  Mobile code - Scheme closures that can serialize and migrate
2.  Credentialed - Carries SPKI certificates granting capabilities
3.  Accountable - Every action recorded in audit trail
4.  Supervised - Realm coordinator can inspect, suspend, terminate

    (define-record-type <agent>
      (make-agent id principal code state credentials realm)
      agent?
      (id agent-id)                    ; Content hash of initial code+state
      (principal agent-principal)      ; SPKI key that spawned this agent
      (code agent-code)                ; Scheme closure (serializable)
      (state agent-state)              ; Mutable state (content-addressed)
      (credentials agent-credentials)  ; SPKI certificate chain
      (realm agent-realm))             ; Current realm location

Agent Lifecycle

    entangle → running → [teleport] → running → ... → decohere
                 ↓                       ↓
              suspend               superpose
                 ↓                       ↓
              resume                  collapse

Telescript Parallels

  Telescript   Cyberspace          Description
  ------------ ------------------- ---------------------------------
  go           teleport            Move agent to another realm
  meet         entangle            Two agents become correlated
  send         tunnel              Message passes through barriers
  permits      SPKI certificates   Capability credentials
  places       Realms              Execution environments
  telename     Content hash        Globally unique identity

Quantum Vocabulary

The fabric of cyberspace uses quantum metaphors:

  Operation         Name        Metaphor
  ----------------- ----------- ------------------------------------
  send message      tunnel      Quantum tunneling through barriers
  receive message   observe     Collapse the wave function
  spawn agent       entangle    Create correlated pair
  migrate agent     teleport    Quantum teleportation
  terminate         decohere    Loss of quantum coherence
  checkpoint        superpose   Exist in multiple states
  link processes    correlate   Spooky action at a distance

“A wilderness of mirrors” - James Angleton

Agents live in a cryptographic wilderness where: - They cannot see plaintext
(HE encryption) - They cannot trust other agents (capability-restricted) -
Every interaction is mediated by certificates - Identity is what you can
prove, not who you claim

------------------------------------------------------------------------------

Agent Operations

entangle (spawn)

Create a new agent in the current realm:

    (entangle
      code: (lambda (self msg) ...)
      state: initial-state
      credentials: cert-chain
      #!key name timeout)

    ;; Returns agent-id (content hash)

The spawning principal’s key signs the agent, establishing provenance. The new
agent is entangled with its creator - correlated through shared lineage.

teleport (migrate)

Move agent to another realm:

    (teleport agent-id target-realm
      #!key superpose)  ; checkpoint before teleport

Process: 1. Serialize agent code + state 2. Create migration certificate
(signed by current realm) 3. Transmit to target realm 4. Target validates
credentials against its policy 5. Resume execution

Migration Certificate:

    (spki-cert
      (issuer source-realm-key)
      (subject agent-id)
      (capability (action execute) (object target-realm))
      (validity (not-after migration-timeout)))

decohere (terminate)

End agent execution:

    (decohere agent-id
      #!key reason superpose-final)

Decoherence can be: - Self-initiated - Agent calls (decohere) -
Coordinator-initiated - Kill signal from realm coordinator - Timeout -
Exceeded allocated time - Revocation - Credentials revoked mid-execution

superpose / collapse (checkpoint / restore)

Save and restore agent state:

    (superpose agent-id)
    ;; Returns content hash of serialized state
    ;; Agent exists in multiple potential states

    (collapse checkpoint-hash realm)
    ;; Resurrects agent from superposition
    ;; Wave function collapses to specific state

Checkpoints are content-addressed, enabling: - Fault recovery - Time travel
debugging - Forking (spawn from checkpoint)

------------------------------------------------------------------------------

Quantum Messaging

Topics (Observation Points)

Topics are hierarchical, content-addressed channels where agents observe:

    (define-record-type <topic>
      (make-topic name realm observers)
      topic?
      (name topic-name)           ; Hierarchical name "realm/category/subject"
      (realm topic-realm)         ; Owning realm
      (observers topic-observers)); Set of observing agent-ids

observe (subscribe)

    (observe topic-pattern handler
      #!key filter replay-from)

    ;; topic-pattern: "realm/events/*" (glob supported)
    ;; handler: (lambda (topic message) ...)
    ;; filter: Predicate for message selection
    ;; replay-from: Sequence number for replay

When you observe, you collapse potential messages into actual received values.

tunnel (publish/send)

    (tunnel topic message
      #!key ttl priority)

    ;; message: Any serializable Scheme value
    ;; ttl: Time-to-live in seconds
    ;; priority: 'normal | 'high | 'critical

Messages tunnel through the fabric of cyberspace, passing barriers that would
block classical communication.

Message Structure

    (quantum-message
      (id "sha512:msg-hash...")
      (topic "realm/agents/status")
      (source agent-id)
      (timestamp 1767700000)
      (sequence 42)
      (payload (status running) (progress 0.73))
      (signature #${ed25519-sig}))

All messages are signed by the source agent.

Delivery Guarantees

  Mode            Guarantee
  --------------- ---------------------------
  at-most-once    Fire and forget (default)
  at-least-once   Retry until ack
  exactly-once    Deduplication + ack

------------------------------------------------------------------------------

Realm Coordination

What is a Realm?

A realm is an execution domain with:

- Coordinator - Supervises agents, enforces policy (quiescent until message)
- Policy - What agents can do (SPKI-based)
- Resources - CPU, memory, network quotas
- Pub/sub broker - Message routing

    (define-record-type <realm>
      (make-realm id coordinator policy agents topics)
      realm?
      (id realm-id)
      (coordinator realm-coordinator)  ; Coordinator agent-id
      (policy realm-policy)            ; SPKI authorization policy
      (agents realm-agents)            ; Hash table of active agents
      (topics realm-topics))           ; Hash table of topics

Quiescent Coordinator

Coordinators are event-driven, not polling. Zero CPU when idle:

    (define (coordinator-loop realm)
      (let loop ()
        ;; Block until message arrives (no busy-wait)
        (let ((msg (observe! (realm-inbox realm))))
          (case (message-type msg)
            ((heartbeat) (handle-heartbeat realm msg))
            ((entangle)  (handle-spawn realm msg))
            ((teleport)  (handle-migrate realm msg))
            ((decohere)  (handle-terminate realm msg))
            ((lock-req)  (handle-lock-request realm msg))
            ((signal)    (handle-signal realm msg)))
          (loop))))

Agent Heartbeat

Agents must heartbeat to their coordinator:

    (agent-heartbeat
      (agent-id "sha512:...")
      (realm "sha512:realm...")
      (timestamp 1767700000)
      (status running)
      (resources
        (cpu-ms 1234)
        (memory-kb 5678)
        (messages-sent 42)))

Missing heartbeats trigger investigation:

    0s    - heartbeat expected
    30s   - grace period
    60s   - coordinator pings agent
    90s   - agent marked unhealthy
    120s  - agent decohered (or superposed)

Remote Termination (Kill Signal)

Coordinators can terminate agents remotely:

    (coordinator-kill agent-id
      #!key reason grace-period)

Kill Signal:

    (kill-signal
      (target agent-id)
      (issuer coordinator-key)
      (reason (policy-violation "exceeded-cpu-quota"))
      (grace-period 5)  ; seconds to superpose
      (signature #${ed25519-sig}))

Agents MUST honor kill signals. Failure to terminate results in: 1. Resource
revocation (network, storage access removed) 2. Forced decoherence by runtime
3. Blacklisting of spawning principal

------------------------------------------------------------------------------

Distributed Locking (SCS-Style)

Lock Manager

Each realm has a lock manager for coordination:

    (define-record-type <lock-manager>
      (make-lock-manager realm locks waiters)
      lock-manager?
      (realm lm-realm)
      (locks lm-locks)      ; Hash table: resource → holder
      (waiters lm-waiters)) ; Hash table: resource → queue

Lock Operations

    (lock-acquire resource
      #!key timeout mode)
    ;; mode: 'exclusive | 'shared

    (lock-release resource)

    (lock-upgrade resource)  ; shared → exclusive

    (lock-downgrade resource)  ; exclusive → shared

Distributed Locks (Cross-Realm)

For resources spanning realms:

    (distributed-lock resource realms
      #!key timeout coordinator)

Uses two-phase locking: 1. Prepare - All realms vote to grant lock 2. Commit -
Lock granted if all vote yes 3. Abort - Any no vote aborts

Deadlock Detection

Lock manager maintains wait-for graph:

    (define (detect-deadlock lock-manager)
      "Find cycles in wait-for graph"
      (let ((graph (build-wait-for-graph lock-manager)))
        (find-cycles graph)))

Resolution: Youngest agent in cycle is aborted.

------------------------------------------------------------------------------

Security Considerations

TCSEC B2 Channel Security

Agent channels must resist covert channel analysis:

  Channel Type   Leak Vector                 Mitigation
  -------------- --------------------------- ---------------------------
  Storage        Message size, topic names   Pad to fixed sizes
  Timing         Response latency            Add jitter, batch windows
  Signaling      Pub/sub presence            Dummy traffic

Credential Validation

On every operation: 1. Verify agent’s SPKI certificate chain 2. Check
capability grants requested action 3. Validate certificates not revoked 4.
Enforce monotonic attenuation

Migration Security

    (define (validate-migration agent target-realm)
      (and (valid-credentials? (agent-credentials agent))
           (realm-admits? target-realm agent)
           (not-revoked? (agent-credentials agent))
           (within-quota? target-realm agent)))

Audit Trail

All agent actions recorded:

    (audit-append
      actor: (agent-principal agent)
      action: `(teleport ,agent-id ,target-realm)
      motivation: "data locality optimization")

------------------------------------------------------------------------------

Homomorphic Encryption Integration

When to Use HE

Use homomorphic encryption for narrow, well-defined operations:

  Use Case              HE Appropriate?
  --------------------- ---------------------------------------
  Vote tallying         Yes - sum encrypted votes
  Aggregate metrics     Yes - sum/average encrypted values
  Private analytics     Yes - fixed statistical operations
  General computation   No - too slow
  Dynamic branching     No - can’t branch on encrypted values

Encrypted Agent State

Agents can carry encrypted state they cannot read:

    (entangle
      code: aggregation-circuit  ; Pre-compiled HE circuit
      state: (encrypted-state
               (ciphertext #${...})
               (scheme 'bfv)
               (operations '(add multiply)))
      credentials: cert-chain)

The agent computes on encrypted data, returns encrypted result. Only the
principal with the decryption key can read the result.

------------------------------------------------------------------------------

References

1.  Telescript Language Reference - General Magic (preserved)
2.  Mobile Agents - Lange & Oshima (preserved)
3.  Distributed Lock Manager - VAX/VMS SCS (preserved)
4.  Concurrency Oriented Programming in Termite Scheme - Germain (preserved)
5.  RFC-003: Cryptographic Audit Trail
6.  RFC-004: SPKI Authorization
7.  RFC-010: Federation Protocol
8.  RFC-021: Capability Delegation
9.  RFC-023: Agent Sandboxing

------------------------------------------------------------------------------

Changelog

- 2026-01-07 - Initial draft with quantum vocabulary

------------------------------------------------------------------------------

Implementation Status: Proposed Dependencies: spki, vault, audit, federation
Integration: Realm coordinators, pub/sub broker, lock manager
