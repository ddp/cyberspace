<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RFC-024: Network Protocol</title>
  <link rel="stylesheet" href="rfc.css">
</head>
<body>
<h1>RFC-024: Network Protocol</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This RFC specifies the network protocol for the Library of Cyberspace: how vaults discover each other, authenticate, exchange objects, and synchronize state. The protocol is transport-agnostic, capability-authenticated, and optimized for content-addressed data.</p>
</section>
<section>
<h2>Motivation</h2>
<p>Vaults must communicate to:</p>
<ul>
<li>Replicate</li>
<li>Distribute objects across vaults</li>
<li>Federate</li>
<li>Link independent vaults into networks</li>
<li>Subscribe</li>
<li>Receive updates from publishers</li>
<li>Query</li>
<li>Search the distributed soup</li>
</ul>
<p>The protocol must handle:</p>
<ul>
<li>Intermittent connectivity</li>
<li>Vaults may be offline</li>
<li>Untrusted networks</li>
<li>All communication authenticated</li>
<li>Large objects</li>
<li>Efficient chunked transfer</li>
<li>Partial sync</li>
<li>Resume interrupted transfers</li>
</ul>
</section>
<section>
<h2>Protocol Layers</h2>
<pre>
┌─────────────────────────────────────────┐
│           APPLICATION LAYER             │
│  (vault operations, soup queries)       │
├─────────────────────────────────────────┤
│           MESSAGE LAYER                 │
│  (request/response, streaming)          │
├─────────────────────────────────────────┤
│           SECURITY LAYER                │
│  (authentication, encryption)           │
├─────────────────────────────────────────┤
│           TRANSPORT LAYER               │
│  (TCP, QUIC, Unix socket, etc.)         │
└─────────────────────────────────────────┘
</pre>
</section>
<section>
<h2>Transport Layer</h2>
<h3>Supported Transports</h3>
<pre class="language-scheme">
(define transports
  '((tcp "Traditional TCP/IP")
    (quic "UDP-based, multiplexed")
    (unix "Local Unix domain socket")
    (tor "Onion-routed TCP")
    (i2p "Garlic-routed")
    (bluetooth "Local mesh")
    (sneakernet "Physical media exchange")))
</pre>
<h3>Connection Establishment</h3>
<pre class="language-scheme">
(define (connect-vault address transport)
  "Establish connection to remote vault"
  (let* ((socket (transport-connect transport address))
         (connection (make-connection socket transport)))

    ;; Perform handshake
    (connection-handshake connection)

    ;; Return authenticated connection
    connection))
</pre>
<h3>Multiplexing</h3>
<p>Multiple streams over single connection:</p>
<pre class="language-scheme">
(define (open-stream connection stream-type)
  "Open multiplexed stream within connection"
  (let ((stream-id (allocate-stream-id connection)))
    (send-frame connection
      (frame type: 'stream-open
             stream-id: stream-id
             stream-type: stream-type))
    (make-stream connection stream-id stream-type)))
</pre>
</section>
<section>
<h2>Security Layer</h2>
<h3>Handshake Protocol</h3>
<p>Mutual authentication using SPKI certificates:</p>
<pre>
Client                                   Server
  │                                        │
  │──── ClientHello ──────────────────────▶│
  │     (protocol version, capabilities)   │
  │                                        │
  │◀──── ServerHello ─────────────────────│
  │      (protocol version, certificate)   │
  │                                        │
  │──── ClientAuth ───────────────────────▶│
  │     (certificate, challenge-response)  │
  │                                        │
  │◀──── ServerAuth ──────────────────────│
  │      (challenge-response)              │
  │                                        │
  │══════ Encrypted Channel ══════════════│
</pre>
<h3>Handshake Implementation</h3>
<pre class="language-scheme">
(define (connection-handshake connection)
  "Perform mutual authentication handshake"

  ;; Send ClientHello
  (send-message connection
    (client-hello
      (version ,protocol-version)
      (capabilities ,(local-capabilities))))

  ;; Receive ServerHello
  (let ((server-hello (receive-message connection)))
    (verify-protocol-version (server-hello-version server-hello))

    ;; Verify server certificate
    (let ((server-cert (server-hello-certificate server-hello)))
      (unless (verify-certificate server-cert)
        (error "Server certificate invalid"))

      ;; Generate session key using X25519
      (let* ((ephemeral-keypair (x25519-keypair))
             (shared-secret (x25519-shared (keypair-secret ephemeral-keypair)
                                          (cert-public-key server-cert))))

        ;; Send ClientAuth
        (send-message connection
          (client-auth
            (certificate ,(local-certificate))
            (ephemeral-public ,(keypair-public ephemeral-keypair))
            (signature ,(sign-challenge server-hello))))

        ;; Receive ServerAuth
        (let ((server-auth (receive-message connection)))
          (unless (verify-server-signature server-auth server-cert)
            (error "Server authentication failed"))

          ;; Derive session keys
          (derive-session-keys connection shared-secret))))))
</pre>
<h3>Session Encryption</h3>
<pre class="language-scheme">
(define (derive-session-keys connection shared-secret)
  "Derive symmetric keys for session"
  (let* ((key-material (hkdf shared-secret
                             info: "library-session"
                             length: 64))
         (client-key (subbytes key-material 0 32))
         (server-key (subbytes key-material 32 64)))

    (set-connection-keys! connection
      (if (connection-is-client? connection)
          (keys send: client-key receive: server-key)
          (keys send: server-key receive: client-key)))))

(define (encrypt-message connection message)
  "Encrypt message with session key"
  (let ((nonce (connection-next-nonce connection)))
    (chacha20-poly1305-encrypt
      (connection-send-key connection)
      nonce
      (serialize message))))

(define (decrypt-message connection ciphertext)
  "Decrypt message with session key"
  (let ((nonce (connection-next-nonce connection)))
    (deserialize
      (chacha20-poly1305-decrypt
        (connection-receive-key connection)
        nonce
        ciphertext))))
</pre>
</section>
<section>
<h2>Message Layer</h2>
<h3>Message Format</h3>
<pre class="language-scheme">
(library-message
  (version 1)
  (type request|response|stream|error)
  (id &lt;message-id&gt;)
  (in-reply-to &lt;message-id&gt;|#f)
  (capability &lt;spki-cert&gt;|#f)
  (body &lt;payload&gt;))
</pre>
<h3>Request Types</h3>
<pre class="language-scheme">
(define request-types
  '(;; Object operations
    (get-object hash)
    (put-object hash data)
    (has-object hash)

    ;; Bulk operations
    (get-objects hashes)
    (get-tree root-hash)
    (sync-objects bloom-filter)

    ;; Soup queries
    (soup-query query)
    (soup-subscribe query)

    ;; Vault operations
    (get-refs pattern)
    (get-head)
    (get-releases)

    ;; Discovery
    (get-capabilities)
    (get-peers)))
</pre>
<h3>Request/Response</h3>
<pre class="language-scheme">
(define (vault-request connection request #!key capability timeout)
  "Send request, wait for response"
  (let ((message-id (generate-message-id)))

    ;; Send request
    (send-message connection
      (library-message
        version: 1
        type: 'request
        id: message-id
        capability: capability
        body: request))

    ;; Wait for response
    (let ((response (receive-response connection message-id timeout)))
      (if (eq? (message-type response) 'error)
          (error (message-body response))
          (message-body response)))))
</pre>
<h3>Streaming</h3>
<p>For large transfers:</p>
<pre class="language-scheme">
(define (stream-object connection hash)
  "Stream large object in chunks"
  (let ((stream (open-stream connection 'object-transfer)))

    ;; Send chunks
    (let ((data (cas-get hash)))
      (let loop ((offset 0))
        (when (&lt; offset (blob-length data))
          (let ((chunk (blob-copy data offset chunk-size)))
            (stream-send stream chunk)
            (loop (+ offset chunk-size)))))

      ;; End stream
      (stream-close stream))))

(define (receive-stream connection stream callback)
  "Receive streamed data"
  (let loop ((chunks '()))
    (let ((chunk (stream-receive stream)))
      (if (stream-ended? stream)
          (apply bytes-append (reverse chunks))
          (begin
            (callback chunk)
            (loop (cons chunk chunks)))))))
</pre>
</section>
<section>
<h2>Object Exchange</h2>
<h3>Get Object</h3>
<pre class="language-scheme">
;; Request
(get-object
  (hash "sha256:abc123..."))

;; Response (small object)
(object-data
  (hash "sha256:abc123...")
  (size 1024)
  (data #${...}))

;; Response (large object - streaming)
(object-stream
  (hash "sha256:abc123...")
  (size 10485760)
  (stream-id 42))
</pre>
<h3>Put Object</h3>
<pre class="language-scheme">
;; Request
(put-object
  (hash "sha256:abc123...")
  (data #${...}))

;; Response
(put-result
  (hash "sha256:abc123...")
  (status stored|duplicate|rejected)
  (reason #f|"quota exceeded"))
</pre>
<h3>Batch Operations</h3>
<pre class="language-scheme">
;; Request multiple objects
(get-objects
  (hashes ("sha256:aaa..." "sha256:bbb..." "sha256:ccc...")))

;; Response
(objects-batch
  (objects
    ((hash "sha256:aaa..." data #${...})
     (hash "sha256:bbb..." data #${...})
     (hash "sha256:ccc..." status: missing))))
</pre>
<h3>Tree Transfer</h3>
<p>Efficient Merkle tree sync:</p>
<pre class="language-scheme">
;; Request tree
(get-tree
  (root "sha256:root...")
  (depth 3)  ; How deep to fetch
  (exclude ("sha256:already-have...")))

;; Response
(tree-data
  (root "sha256:root...")
  (objects
    ((hash "sha256:root..." data #${...})
     (hash "sha256:child1..." data #${...})
     (hash "sha256:child2..." data #${...}))))
</pre>
</section>
<section>
<h2>Synchronization</h2>
<h3>Bloom Filter Exchange</h3>
<p>Efficient "what do you have?" queries:</p>
<pre class="language-scheme">
;; Step 1: Exchange bloom filters
(define (sync-init local-vault remote-connection)
  (let ((local-bloom (vault-bloom-filter local-vault)))

    ;; Send our bloom filter
    (send-message remote-connection
      `(sync-bloom
        (filter ,local-bloom)
        (population ,(bloom-population local-bloom))))

    ;; Receive their bloom filter
    (let ((remote-bloom (receive-bloom remote-connection)))

      ;; Compute what they might want
      (let ((to-send (filter (lambda (hash)
                               (not (bloom-contains? remote-bloom hash)))
                             (vault-all-hashes local-vault))))
        to-send))))

;; Step 2: Exchange missing objects
(define (sync-exchange to-send to-receive connection)
  (parallel
    ;; Send what they need
    (for-each (lambda (hash)
                (stream-object connection hash))
              to-send)
    ;; Receive what we need
    (for-each (lambda (hash)
                (receive-object connection hash))
              to-receive)))
</pre>
<h3>Incremental Sync</h3>
<pre class="language-scheme">
(define (incremental-sync local-vault remote-connection since)
  "Sync changes since timestamp or commit"

  ;; Get remote changes
  (let ((remote-changes (vault-request remote-connection
                          `(changes-since ,since))))

    ;; Get local changes
    (let ((local-changes (vault-changes-since local-vault since)))

      ;; Bidirectional merge
      (sync-merge local-vault remote-connection
                  local-changes remote-changes))))
</pre>
<h3>Conflict Resolution</h3>
<pre class="language-scheme">
(define (sync-merge local-vault remote changes-local changes-remote)
  "Merge changes with conflict resolution"

  (for-each
    (lambda (hash)
      (cond
        ;; Only local has it - push
        ((and (member hash changes-local)
              (not (member hash changes-remote)))
         (push-object local-vault remote hash))

        ;; Only remote has it - pull
        ((and (member hash changes-remote)
              (not (member hash changes-local)))
         (pull-object local-vault remote hash))

        ;; Both have it - verify same
        ((and (member hash changes-local)
              (member hash changes-remote))
         ;; Content-addressed, so same hash = same content
         #t)))
    (union changes-local changes-remote)))
</pre>
</section>
<section>
<h2>Discovery</h2>
<h3>Peer Discovery</h3>
<pre class="language-scheme">
;; Well-known peers (bootstrap)
(define (discover-bootstrap)
  (map parse-address
       (read-file "/etc/library/bootstrap-peers")))

;; mDNS/DNS-SD for local network
(define (discover-local)
  (mdns-browse "library.tcp.local"))

;; DHT for global discovery
(define (discover-dht target-hash)
  (dht-find-providers target-hash))

;; Peer exchange
(define (discover-pex connection)
  (vault-request connection '(get-peers)))
</pre>
<h3>Capability Advertisement</h3>
<pre class="language-scheme">
;; Query vault capabilities
(get-capabilities)

;; Response
(vault-capabilities
  (protocol-version 1)
  (features (bloom-sync tree-transfer streaming soup-query))
  (max-object-size 104857600)  ; 100MB
  (storage-available 10737418240)  ; 10GB
  (public-key "ed25519:abc...")
  (services
    ((soup-query rate-limit: 100/minute)
     (object-transfer rate-limit: 10MB/second))))
</pre>
</section>
<section>
<h2>Soup Queries</h2>
<h3>Remote Query</h3>
<pre class="language-scheme">
;; Query remote soup
(soup-query
  (type certificate)
  (issuer "vault-admin")
  (limit 100))

;; Response
(soup-results
  (count 47)
  (objects
    ((name "cert/alice" type certificate ...)
     (name "cert/bob" type certificate ...)
     ...)))
</pre>
<h3>Subscription</h3>
<pre class="language-scheme">
;; Subscribe to soup changes
(soup-subscribe
  (query (type release))
  (callback-url "library://my-vault/callbacks/releases"))

;; Subscription confirmation
(subscription
  (id "sub-123")
  (query (type release))
  (expires "2026-02-07T00:00:00Z"))

;; Push notification (when matching object appears)
(soup-notification
  (subscription-id "sub-123")
  (object (name "release/1.2.0" type release ...)))
</pre>
</section>
<section>
<h2>Error Handling</h2>
<h3>Error Types</h3>
<pre class="language-scheme">
(define error-types
  '((not-found "Object not found")
    (unauthorized "Capability required")
    (forbidden "Capability insufficient")
    (quota-exceeded "Storage quota exceeded")
    (rate-limited "Too many requests")
    (timeout "Operation timed out")
    (invalid-request "Malformed request")
    (internal-error "Server error")
    (unavailable "Service temporarily unavailable")))
</pre>
<h3>Error Response</h3>
<pre class="language-scheme">
(library-message
  (type error)
  (id &lt;message-id&gt;)
  (in-reply-to &lt;request-id&gt;)
  (body
    (error-response
      (code not-found)
      (message "Object sha256:abc... not found")
      (retry-after #f))))
</pre>
<h3>Retry Logic</h3>
<pre class="language-scheme">
(define (vault-request-with-retry connection request #!key max-retries)
  "Request with exponential backoff retry"
  (let loop ((attempt 0) (delay 1000))
    (let ((result (vault-request connection request)))
      (if (and (error-response? result)
               (retryable-error? result)
               (&lt; attempt max-retries))
          (begin
            (sleep delay)
            (loop (+ attempt 1) (* delay 2)))
          result))))
</pre>
</section>
<section>
<h2>Security Considerations</h2>
<h3>Capability Verification</h3>
<pre class="language-scheme">
(define (verify-request-capability request connection)
  "Verify request has sufficient capability"
  (let ((required-cap (request-&gt;capability request))
        (presented-cap (message-capability request)))

    (unless presented-cap
      (error 'unauthorized "Capability required"))

    (unless (valid-certificate? presented-cap)
      (error 'unauthorized "Invalid capability certificate"))

    (unless (capability-grants? presented-cap required-cap)
      (error 'forbidden "Insufficient capability"))

    ;; Verify capability chain back to trusted root
    (unless (verify-capability-chain presented-cap)
      (error 'forbidden "Capability chain invalid"))))
</pre>
<h3>Denial of Service Protection</h3>
<pre class="language-scheme">
(define (rate-limit connection request-type)
  "Apply rate limiting"
  (let ((limit (get-rate-limit request-type))
        (current (connection-request-count connection request-type)))
    (when (&gt; current limit)
      (error 'rate-limited
             (format "Rate limit exceeded: ~a/~a" current limit)))))

(define (size-limit request)
  "Enforce size limits"
  (when (&gt; (request-size request) max-request-size)
    (error 'invalid-request "Request too large")))
</pre>
<h3>Replay Prevention</h3>
<pre class="language-scheme">
(define (verify-nonce connection message)
  "Prevent replay attacks"
  (let ((nonce (message-nonce message)))
    (when (nonce-seen? connection nonce)
      (error 'invalid-request "Replay detected"))
    (record-nonce connection nonce)))
</pre>
</section>
<section>
<h2>Implementation Notes</h2>
<h3>Wire Format</h3>
<p>Messages serialized as canonical S-expressions:</p>
<pre class="language-scheme">
(define (serialize-message message)
  "Canonical S-expression serialization"
  (canonical-sexp-&gt;bytes message))

(define (deserialize-message bytes)
  "Parse S-expression"
  (bytes-&gt;canonical-sexp bytes))
</pre>
<h3>Compression</h3>
<p>Optional compression for large payloads:</p>
<pre class="language-scheme">
(define (maybe-compress data)
  (if (&gt; (blob-length data) compression-threshold)
      (values (zstd-compress data) 'zstd)
      (values data 'none)))
</pre>
<h3>Connection Pooling</h3>
<pre class="language-scheme">
(define connection-pool (make-hash-table))

(define (get-connection address)
  "Get pooled connection or create new"
  (or (hash-table-ref connection-pool address #f)
      (let ((conn (connect-vault address)))
        (hash-table-set! connection-pool address conn)
        conn)))
</pre>
</section>
<section>
<h2>References</h2>
<p>1. [QUIC Protocol - RFC 9000](https://tools.ietf.org/html/rfc9000) 2. [Noise Protocol Framework](http://noiseprotocol.org/) 3. [RFC-020: Content-Addressed Storage](rfc-020-content-addressed-storage.html) 4. [RFC-021: Capability Delegation](rfc-021-capability-delegation.html) 5. [IPFS Bitswap Protocol](https://docs.ipfs.tech/concepts/bitswap/) 6. [libp2p Specifications](https://github.com/libp2p/specs)</p>
</section>
<section>
<h2>Changelog</h2>
<ul>
<li>2026-01-07</li>
<li>Initial draft</li>
</ul>
</section>
</body>
</html>
