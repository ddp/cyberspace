<!DOCTYPE html>
<html><head><meta charset="UTF-8"><title>RFC-013: TLA+ Formal Specification</title>
<style>body{font-family:monospace;max-width:80ch;margin:2rem auto;padding:1rem;line-height:1.4;}
pre{white-space:pre-wrap;}</style>
</head><body><pre>RFC-013: TLA+ Formal Specification

**Status:** Proposed
**Date:** January 2026
**Author:** Derrell Piper &lt;ddp@eludom.net&gt;

---

Abstract

This RFC specifies the use of TLA+ (Temporal Logic of Actions) for formal specification and model checking of Cyberspace protocols, ensuring correctness before implementation.

---

Motivation

Running code is necessary but not sufficient:

- **Tests check examples**: Not all possible executions
- **Reviews check logic**: Not all interleavings
- **Bugs hide in corners**: Race conditions, edge cases

TLA+ provides:

1. **Precise specification**: Mathematical description of behavior
2. **Model checking**: Exhaustive state space exploration
3. **Proof capability**: Formal verification of properties
4. **Design tool**: Find bugs before writing code

From Lamport:

&gt; *If you're thinking without writing, you only think you're thinking.*

---

Specification

TLA+ Overview

TLA+ describes systems as state machines:

```tla
VARIABLES state, messages, decisions

Init ==
  /\ state = [n \in Nodes |-&gt; "idle"]
  /\ messages = {}
  /\ decisions = {}

Next ==
  \/ Propose(...)
  \/ Prepare(...)
  \/ Commit(...)
  \/ Decide(...)

Spec == Init /\ [][Next]_&lt;&lt;state, messages, decisions&gt;&gt;
```

Safety Properties

**Invariants** that must always hold:

```tla
TypeOK ==
  /\ state \in [Nodes -&gt; {"idle", "prepared", "committed"}]
  /\ messages \subseteq Message
  /\ decisions \subseteq Value

Agreement ==
  \A n1, n2 \in Nodes:
    (decisions[n1] # {} /\ decisions[n2] # {}) =&gt;
      decisions[n1] = decisions[n2]
```

Liveness Properties

**Temporal** properties about progress:

```tla
Termination ==
  &lt;&gt;(\A n \in Nodes: decisions[n] # {})

EventualConsistency ==
  []&lt;&gt;(\A n1, n2 \in Nodes: state[n1] = state[n2])
```

---

Cyberspace Protocol Specifications

Threshold Signatures (RFC-007)

```tla
--------------------------- MODULE ThresholdSig ---------------------------
EXTENDS Integers, FiniteSets

CONSTANTS Signers, Threshold, Script

VARIABLES signatures, verified

Init ==
  /\ signatures = {}
  /\ verified = FALSE

Sign(s) ==
  /\ s \in Signers
  /\ s \notin {sig.signer : sig \in signatures}
  /\ signatures' = signatures \union
       {[signer |-&gt; s, script |-&gt; Script, valid |-&gt; TRUE]}
  /\ verified' = verified

Verify ==
  /\ Cardinality({sig \in signatures : sig.valid}) &gt;= Threshold
  /\ verified' = TRUE
  /\ UNCHANGED signatures

Next ==
  \/ \E s \in Signers: Sign(s)
  \/ Verify

\* Safety: Never verify with insufficient signatures
Safety ==
  verified =&gt; Cardinality({sig \in signatures : sig.valid}) &gt;= Threshold

\* Liveness: If enough sign, eventually verify
Liveness ==
  (Cardinality(Signers) &gt;= Threshold) =&gt; &lt;&gt;(verified)

=============================================================================
```

Audit Trail (RFC-003)

```tla
--------------------------- MODULE AuditTrail ---------------------------
EXTENDS Integers, Sequences

CONSTANTS Actors, Actions

VARIABLES log, sequence

Init ==
  /\ log = &lt;&lt;&gt;&gt;
  /\ sequence = 0

Append(actor, action) ==
  /\ actor \in Actors
  /\ action \in Actions
  /\ sequence' = sequence + 1
  /\ log' = Append(log, [
       seq |-&gt; sequence',
       actor |-&gt; actor,
       action |-&gt; action,
       parent |-&gt; IF sequence = 0 THEN "genesis" ELSE log[sequence].hash
     ])

\* Invariant: Chain integrity
ChainIntegrity ==
  \A i \in 1..Len(log)-1:
    log[i+1].parent = log[i].hash

\* Invariant: Monotonic sequence
MonotonicSequence ==
  \A i \in 1..Len(log)-1:
    log[i+1].seq = log[i].seq + 1

=============================================================================
```

Byzantine Consensus (RFC-011)

```tla
--------------------------- MODULE PBFT ---------------------------
EXTENDS Integers, FiniteSets

CONSTANTS Nodes, f, Values

ASSUME Cardinality(Nodes) &gt;= 3*f + 1

VARIABLES
  view,
  prepares,
  commits,
  decisions

Init ==
  /\ view = 0
  /\ prepares = [n \in Nodes |-&gt; {}]
  /\ commits = [n \in Nodes |-&gt; {}]
  /\ decisions = [n \in Nodes |-&gt; {}]

PrePrepare(primary, v) ==
  /\ primary = Leader(view)
  /\ v \in Values
  /\ \A n \in Nodes:
       prepares' = [prepares EXCEPT ![n] = @ \union {[view |-&gt; view, value |-&gt; v]}]
  /\ UNCHANGED &lt;&lt;view, commits, decisions&gt;&gt;

Prepare(n, v) ==
  /\ [view |-&gt; view, value |-&gt; v] \in prepares[n]
  /\ Cardinality({m \in Nodes : [view |-&gt; view, value |-&gt; v] \in prepares[m]}) &gt;= 2*f + 1
  /\ commits' = [commits EXCEPT ![n] = @ \union {[view |-&gt; view, value |-&gt; v]}]
  /\ UNCHANGED &lt;&lt;view, prepares, decisions&gt;&gt;

Commit(n, v) ==
  /\ [view |-&gt; view, value |-&gt; v] \in commits[n]
  /\ Cardinality({m \in Nodes : [view |-&gt; view, value |-&gt; v] \in commits[m]}) &gt;= 2*f + 1
  /\ decisions' = [decisions EXCEPT ![n] = {v}]
  /\ UNCHANGED &lt;&lt;view, prepares, commits&gt;&gt;

\* Safety: Agreement
Agreement ==
  \A n1, n2 \in Nodes:
    (decisions[n1] # {} /\ decisions[n2] # {}) =&gt;
      decisions[n1] = decisions[n2]

=============================================================================
```

---

Model Checking Process

1. Write Specification

Define state machine and properties.

2. Configure Model

```tla
CONSTANTS
  Nodes = {n1, n2, n3, n4}
  f = 1
  Values = {v1, v2}
```

3. Run TLC Model Checker

```bash
$ tlc PBFT.tla
TLC2 Version 2.18
...
Model checking completed. No errors found.
  States explored: 847293
  Distinct states: 12847
```

4. Analyze Counterexamples

If property violated, TLC shows trace:

```
Error: Invariant Agreement is violated.
Trace:
  State 1: &lt;Initial&gt;
  State 2: PrePrepare(n1, v1)
  State 3: Prepare(n2, v1)
  ...
  State 12: decisions = [n1 |-&gt; {v1}, n2 |-&gt; {v2}]  &lt;&lt; VIOLATION
```

---

Integration with Implementation

Specification → Implementation

```
TLA+ Spec          Scheme Implementation
-----------        ---------------------
VARIABLES state    (define-record-type &lt;state&gt; ...)
Init ==            (define (init) ...)
Action(x) ==       (define (action x) ...)
Invariant          (assert (invariant? state))
```

Runtime Assertions

```scheme
(define (append-audit! entry)
  ;; TLA+ invariant: MonotonicSequence
  (assert (&gt; (entry-sequence entry)
             (entry-sequence (last-entry))))
  ;; TLA+ invariant: ChainIntegrity
  (assert (equal? (entry-parent entry)
                  (entry-hash (last-entry))))
  ;; Proceed with append
  ...)
```

---

PlusCal (Algorithmic TLA+)

Higher-level syntax that compiles to TLA+:

```tla
--algorithm ThresholdSign {
  variables signatures = {}, verified = FALSE;

  process (signer \in Signers)
  {
    sign:
      signatures := signatures \union {self};
  }

  process (verifier = "v")
  {
    verify:
      await Cardinality(signatures) &gt;= Threshold;
      verified := TRUE;
  }
}
```

---

Benefits

| Aspect | Without TLA+ | With TLA+ |
|--------|--------------|-----------|
| Design | Informal, ambiguous | Precise, mathematical |
| Bugs | Found in testing/production | Found before coding |
| Confidence | "Seems to work" | "Proven correct" |
| Documentation | Natural language | Executable specification |
| Maintenance | Risky changes | Verify changes |

---

Limitations

- **State explosion**: Large state spaces take time
- **Learning curve**: TLA+ is different
- **Abstraction gap**: Spec ≠ implementation
- **Finite models**: Cannot check infinite systems directly

Mitigations:
- Symmetry reduction
- Abstraction
- Proof for infinite cases

---

References

1. Lamport, L. (2002). Specifying Systems: The TLA+ Language.
2. Lamport, L. (2009). The PlusCal Algorithm Language.
3. Newcombe, C., et al. (2015). How Amazon Web Services Uses Formal Methods.
4. TLA+ Tools: https://lamport.azurewebsites.net/tla/tools.html

---

Changelog

- **2026-01-06** - Initial specification

---

**Implementation Status:** Proposed
**Tool:** TLA+ / TLC Model Checker
**Target Protocols:** RFC-003, RFC-007, RFC-011</pre></body></html>
