<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RFC-013: TLA+ Formal Specification</title>
  <link rel="stylesheet" href="rfc.css">
</head>
<body>
<h1>RFC-013: TLA+ Formal Specification</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This RFC specifies the use of TLA+ (Temporal Logic of Actions) for formal specification and model checking of Cyberspace protocols, ensuring correctness before implementation.</p>
</section>
<section>
<h2>Motivation</h2>
<p>Running code is necessary but not sufficient:</p>
<ul>
<li>Tests check examples: Not all possible executions</li>
<li>Reviews check logic: Not all interleavings</li>
<li>Bugs hide in corners: Race conditions, edge cases</li>
</ul>
<p>TLA+ provides:</p>
<p>1. Precise specification: Mathematical description of behavior 2. Model checking: Exhaustive state space exploration 3. Proof capability: Formal verification of properties 4. Design tool: Find bugs before writing code</p>
<p>From Lamport:</p>
<blockquote>
<p>If you're thinking without writing, you only think you're thinking.</p>
</blockquote>
</section>
<section>
<h2>Specification</h2>
<h3>TLA+ Overview</h3>
<p>TLA+ describes systems as state machines:</p>
<pre class="language-tla">
VARIABLES state, messages, decisions

Init ==
  /\ state = [n \in Nodes |-&gt; "idle"]
  /\ messages = {}
  /\ decisions = {}

Next ==
  \/ Propose(...)
  \/ Prepare(...)
  \/ Commit(...)
  \/ Decide(...)

Spec == Init /\ [][Next]_&lt;&lt;state, messages, decisions&gt;&gt;
</pre>
<h3>Safety Properties</h3>
<p>Invariants that must always hold:</p>
<pre class="language-tla">
TypeOK ==
  /\ state \in [Nodes -&gt; {"idle", "prepared", "committed"}]
  /\ messages \subseteq Message
  /\ decisions \subseteq Value

Agreement ==
  \A n1, n2 \in Nodes:
    (decisions[n1] # {} /\ decisions[n2] # {}) =&gt;
      decisions[n1] = decisions[n2]
</pre>
<h3>Liveness Properties</h3>
<p>Temporal properties about progress:</p>
<pre class="language-tla">
Termination ==
  &lt;&gt;(\A n \in Nodes: decisions[n] # {})

EventualConsistency ==
  []&lt;&gt;(\A n1, n2 \in Nodes: state[n1] = state[n2])
</pre>
</section>
<section>
<h2>Cyberspace Protocol Specifications</h2>
<h3>Threshold Signatures (RFC-007)</h3>
<pre class="language-tla">
--------------------------- MODULE ThresholdSig ---------------------------
EXTENDS Integers, FiniteSets

CONSTANTS Signers, Threshold, Script

VARIABLES signatures, verified

Init ==
  /\ signatures = {}
  /\ verified = FALSE

Sign(s) ==
  /\ s \in Signers
  /\ s \notin {sig.signer : sig \in signatures}
  /\ signatures' = signatures \union
       {[signer |-&gt; s, script |-&gt; Script, valid |-&gt; TRUE]}
  /\ verified' = verified

Verify ==
  /\ Cardinality({sig \in signatures : sig.valid}) &gt;= Threshold
  /\ verified' = TRUE
  /\ UNCHANGED signatures

Next ==
  \/ \E s \in Signers: Sign(s)
  \/ Verify

\ Safety: Never verify with insufficient signatures
Safety ==
  verified =&gt; Cardinality({sig \in signatures : sig.valid}) &gt;= Threshold

\ Liveness: If enough sign, eventually verify
Liveness ==
  (Cardinality(Signers) &gt;= Threshold) =&gt; &lt;&gt;(verified)

=============================================================================
</pre>
<h3>Audit Trail (RFC-003)</h3>
<pre class="language-tla">
--------------------------- MODULE AuditTrail ---------------------------
EXTENDS Integers, Sequences

CONSTANTS Actors, Actions

VARIABLES log, sequence

Init ==
  /\ log = &lt;&lt;&gt;&gt;
  /\ sequence = 0

Append(actor, action) ==
  /\ actor \in Actors
  /\ action \in Actions
  /\ sequence' = sequence + 1
  /\ log' = Append(log, [
       seq |-&gt; sequence',
       actor |-&gt; actor,
       action |-&gt; action,
       parent |-&gt; IF sequence = 0 THEN "genesis" ELSE log[sequence].hash
     ])

\ Invariant: Chain integrity
ChainIntegrity ==
  \A i \in 1..Len(log)-1:
    log[i+1].parent = log[i].hash

\ Invariant: Monotonic sequence
MonotonicSequence ==
  \A i \in 1..Len(log)-1:
    log[i+1].seq = log[i].seq + 1

=============================================================================
</pre>
<h3>Byzantine Consensus (RFC-011)</h3>
<pre class="language-tla">
--------------------------- MODULE PBFT ---------------------------
EXTENDS Integers, FiniteSets

CONSTANTS Nodes, f, Values

ASSUME Cardinality(Nodes) &gt;= 3f + 1

VARIABLES
  view,
  prepares,
  commits,
  decisions

Init ==
  /\ view = 0
  /\ prepares = [n \in Nodes |-&gt; {}]
  /\ commits = [n \in Nodes |-&gt; {}]
  /\ decisions = [n \in Nodes |-&gt; {}]

PrePrepare(primary, v) ==
  /\ primary = Leader(view)
  /\ v \in Values
  /\ \A n \in Nodes:
       prepares' = [prepares EXCEPT ![n] = @ \union {[view |-&gt; view, value |-&gt; v]}]
  /\ UNCHANGED &lt;&lt;view, commits, decisions&gt;&gt;

Prepare(n, v) ==
  /\ [view |-&gt; view, value |-&gt; v] \in prepares[n]
  /\ Cardinality({m \in Nodes : [view |-&gt; view, value |-&gt; v] \in prepares[m]}) &gt;= 2f + 1
  /\ commits' = [commits EXCEPT ![n] = @ \union {[view |-&gt; view, value |-&gt; v]}]
  /\ UNCHANGED &lt;&lt;view, prepares, decisions&gt;&gt;

Commit(n, v) ==
  /\ [view |-&gt; view, value |-&gt; v] \in commits[n]
  /\ Cardinality({m \in Nodes : [view |-&gt; view, value |-&gt; v] \in commits[m]}) &gt;= 2f + 1
  /\ decisions' = [decisions EXCEPT ![n] = {v}]
  /\ UNCHANGED &lt;&lt;view, prepares, commits&gt;&gt;

\ Safety: Agreement
Agreement ==
  \A n1, n2 \in Nodes:
    (decisions[n1] # {} /\ decisions[n2] # {}) =&gt;
      decisions[n1] = decisions[n2]

=============================================================================
</pre>
</section>
<section>
<h2>Model Checking Process</h2>
<h3>1. Write Specification</h3>
<p>Define state machine and properties.</p>
<h3>2. Configure Model</h3>
<pre class="language-tla">
CONSTANTS
  Nodes = {n1, n2, n3, n4}
  f = 1
  Values = {v1, v2}
</pre>
<h3>3. Run TLC Model Checker</h3>
<pre class="language-bash">
$ tlc PBFT.tla
TLC2 Version 2.18
...
Model checking completed. No errors found.
  States explored: 847293
  Distinct states: 12847
</pre>
<h3>4. Analyze Counterexamples</h3>
<p>If property violated, TLC shows trace:</p>
<pre>
Error: Invariant Agreement is violated.
Trace:
  State 1: &lt;Initial&gt;
  State 2: PrePrepare(n1, v1)
  State 3: Prepare(n2, v1)
  ...
  State 12: decisions = [n1 |-&gt; {v1}, n2 |-&gt; {v2}]  &lt;&lt; VIOLATION
</pre>
</section>
<section>
<h2>Integration with Implementation</h2>
<h3>Specification → Implementation</h3>
<pre>
TLA+ Spec          Scheme Implementation
-----------        ---------------------
VARIABLES state    (define-record-type &lt;state&gt; ...)
Init ==            (define (init) ...)
Action(x) ==       (define (action x) ...)
Invariant          (assert (invariant? state))
</pre>
<h3>Runtime Assertions</h3>
<pre class="language-scheme">
(define (append-audit! entry)
  ;; TLA+ invariant: MonotonicSequence
  (assert (&gt; (entry-sequence entry)
             (entry-sequence (last-entry))))
  ;; TLA+ invariant: ChainIntegrity
  (assert (equal? (entry-parent entry)
                  (entry-hash (last-entry))))
  ;; Proceed with append
  ...)
</pre>
</section>
<section>
<h2>PlusCal (Algorithmic TLA+)</h2>
<p>Higher-level syntax that compiles to TLA+:</p>
<pre class="language-tla">
--algorithm ThresholdSign {
  variables signatures = {}, verified = FALSE;

  process (signer \in Signers)
  {
    sign:
      signatures := signatures \union {self};
  }

  process (verifier = "v")
  {
    verify:
      await Cardinality(signatures) &gt;= Threshold;
      verified := TRUE;
  }
}
</pre>
</section>
<section>
<h2>Benefits</h2>
<table>
<tr><th>Aspect </th><th>Without TLA+ </th><th>With TLA+ </th></tr>
<tr><td>Design </td><td>Informal, ambiguous </td><td>Precise, mathematical </td></tr>
<tr><td>Bugs </td><td>Found in testing/production </td><td>Found before coding </td></tr>
<tr><td>Confidence </td><td>"Seems to work" </td><td>"Proven correct" </td></tr>
<tr><td>Documentation </td><td>Natural language </td><td>Executable specification </td></tr>
<tr><td>Maintenance </td><td>Risky changes </td><td>Verify changes </td></tr>
</table>
</section>
<section>
<h2>Limitations</h2>
<ul>
<li>State explosion: Large state spaces take time</li>
<li>Learning curve: TLA+ is different</li>
<li>Abstraction gap: Spec ≠ implementation</li>
<li>Finite models: Cannot check infinite systems directly</li>
</ul>
<p>Mitigations: - Symmetry reduction - Abstraction - Proof for infinite cases</p>
</section>
<section>
<h2>References</h2>
<p>1. Lamport, L. (2002). Specifying Systems: The TLA+ Language. 2. Lamport, L. (2009). The PlusCal Algorithm Language. 3. Newcombe, C., et al. (2015). How Amazon Web Services Uses Formal Methods. 4. TLA+ Tools: https://lamport.azurewebsites.net/tla/tools.html</p>
</section>
<section>
<h2>Changelog</h2>
<ul>
<li>2026-01-06</li>
<li>Initial specification</li>
</ul>
</section>
</body>
</html>
