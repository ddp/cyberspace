<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RFC-044: Cryptographic Entropy Sources</title>
  <link rel="stylesheet" href="rfc.css">
</head>
<body>
<h1>RFC-044: Cryptographic Entropy Sources</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>All cryptographic operations in Cyberspace require high-quality entropy. This RFC specifies the canonical entropy sources for each platform, ensuring consistent, auditable, and secure randomness across the entire system.</p>
</section>
<section>
<h2>Motivation</h2>
<h3>The Fundamental Requirement</h3>
<p>All cryptography requires true quantum randomness. The math doesn't work otherwise.</p>
<p>Cryptographic proofs assume a source of bits that are: 1. Statistically uniform - Each bit equally likely 0 or 1 2. Independent - No correlations between bits 3. Unpredictable in principle - Not just hard to predict, but impossible</p>
<p>Only quantum mechanical processes satisfy condition 3. Classical chaotic systems (lava lamps, thermal noise, ring oscillators) are deterministic - an adversary with sufficient knowledge of initial conditions could, in theory, predict their output. Quantum processes have no "initial conditions" to know - the randomness is fundamental to physics itself.</p>
<p>Why this matters: - Security proofs assume perfect randomness - Key security = min(algorithmbits, entropybits) - A 256-bit key from a 32-bit PRNG seed provides only 32 bits of security - Nation-state adversaries may have capabilities to model classical entropy sources</p>
<h3>Cryptographic Operations Requiring Entropy</h3>
<p>- Key generation (Ed25519, X25519) - Nonce generation (XSalsa20-Poly1305) - Salt generation (Argon2id) - Shamir secret sharing - Challenge-response protocols - Zero-knowledge proofs</p>
<p>Weak or predictable entropy destroys security completely. A realm's sovereignty depends on unpredictable secrets.</p>
</section>
<section>
<h2>Specification</h2>
<h3>Canonical Source: libsodium</h3>
<p>All Cyberspace implementations MUST use libsodium's randombytes_buf() as the primary entropy source:</p>
<pre>
randombytes_buf(buffer, size)
</pre>
<p>libsodium automatically selects the best available source: - Linux: getrandom(2) syscall, falls back to /dev/urandom - macOS/iOS: arc4randombuf() - Windows: RtlGenRandom() - OpenBSD: arc4randombuf() (ChaCha20-based)</p>
<h3>Why libsodium?</h3>
<p>1. Cross-platform consistency - Same API everywhere 2. Automatic best-source selection - No platform-specific code 3. Initialization safety - Blocks until entropy available 4. Fork safety - Handles process forking correctly 5. Audited implementation - Widely reviewed cryptographic library</p>
<h3>Platform Requirements</h3>
<p>#### Scheme (CHICKEN)</p>
<pre class="language-scheme">
;; crypto-ffi.scm provides:
(define (random-bytes n)
  "Generate n cryptographically secure random bytes"
  (let ((buf (make-blob n)))
    ((foreign-lambda void "randombytes_buf" scheme-pointer unsigned-integer)
     buf n)
    buf))
</pre>
<p>All Scheme code MUST use random-bytes from crypto-ffi. NEVER use: - (chicken random) - Uses PRNG, not cryptographically secure - /dev/random directly - Platform-specific, may block - Custom PRNGs - Unaudited, likely insecure</p>
<p>#### OCaml</p>
<p>Status: Open Issue</p>
<p>OCaml implementations should use one of: - mirage-crypto-rng with Nocrypto.Rng.generate - Direct FFI to libsodium via ctypes</p>
<p>Decision pending based on: - Multicore OCaml compatibility - Domain-local PRNG state handling - Build system integration (dune vs opam)</p>
<h3>Entropy Initialization</h3>
<p>Before ANY cryptographic operation, ensure libsodium is initialized:</p>
<pre class="language-scheme">
(define (sodium-init)
  (let ((result ((foreign-lambda int "sodiuminit"))))
    (when (= result -1)
      (error "sodiuminit failed - entropy source unavailable"))))
</pre>
<p>sodium_init() is idempotent and thread-safe. Call it early in program startup.</p>
<h3>Key Generation</h3>
<p>All key generation MUST use libsodium's key generation functions, which internally use randombytes_buf():</p>
<table>
<tr><th>Operation </th><th>Function </th></tr>
<tr><td>Ed25519 signing key </td><td>cryptosignkeypair() </td></tr>
<tr><td>X25519 key exchange </td><td>cryptoboxkeypair() </td></tr>
<tr><td>Symmetric key </td><td>cryptosecretboxkeygen() </td></tr>
<tr><td>Generic random </td><td>randombytes_buf() </td></tr>
</table>
<h3>Nonce Generation</h3>
<p>Nonces MUST be generated fresh for each encryption:</p>
<pre class="language-scheme">
(define (generate-nonce)
  (random-bytes (secretbox-noncebytes)))  ;; 24 bytes
</pre>
<p>For XSalsa20-Poly1305 with 24-byte nonces, random nonces are safe: - 2^192 possible nonces - Birthday collision after ~2^96 messages - Practical limit: ~2^64 messages per key (still astronomical)</p>
<h3>Salt Generation</h3>
<p>For Argon2id key derivation:</p>
<pre class="language-scheme">
(define (generate-salt)
  (random-bytes 16))  ;; cryptopwhashSALTBYTES
</pre>
<p>Salts prevent rainbow table attacks. Each salt MUST be unique per derived key.</p>
</section>
<section>
<h2>Deep Dive: Entropy Sources</h2>
<p>Randomness is the foundation of all cryptography. This section explores the physics and engineering of true randomness.</p>
<h3>The Entropy Hierarchy</h3>
<pre>
┌─────────────────────────────────────────────────────────────┐
│                    Entropy Quality Pyramid                   │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│                    ┌───────────────┐                         │
│           ★★★     │  Quantum RNG  │  ← TRUE RANDOMNESS      │
│                    └───────────────┘    (required for        │
│                         ▲                cryptographic       │
│                         │                security)           │
│                    ─────┴─────                               │
│                    SECURITY BOUNDARY                         │
│                    ───────────────                           │
│                         │                                    │
│                         ▼                                    │
│                  ┌───────────────────┐                       │
│                  │  Hardware TRNG    │  ← Best effort       │
│                  └───────────────────┘    (should feed       │
│                ┌───────────────────────┐   quantum source)   │
│                │  Environmental/Analog │                     │
│                └───────────────────────┘                     │
│              ┌───────────────────────────┐                   │
│              │  Public Beacons (NIST)    │  ← Verifiable     │
│              └───────────────────────────┘                   │
│            ┌───────────────────────────────┐                 │
│            │  OS Entropy Pool              │  ← Mixed        │
│            └───────────────────────────────┘                 │
│          ┌───────────────────────────────────┐               │
│          │  CSPRNG (seeded from above)       │  ← Expansion  │
│          └───────────────────────────────────┘               │
│                                                              │
└─────────────────────────────────────────────────────────────┘

   ★★★ = Cryptographic operations MUST ultimately trace to quantum sources
</pre>
<p>Critical distinction: Everything below the security boundary is computationally secure (hard to predict), not information-theoretically secure (impossible to predict). For operations like key generation that must withstand future advances in computation and modeling, only quantum sources provide provable security.</p>
<h3>Practical Access to Quantum Randomness</h3>
<p>The ideal: Every cryptographic operation sources entropy from a local quantum RNG.</p>
<p>Current reality: Most systems rely on: 1. Hardware RNG (thermal noise, ring oscillators) - classical, but unpredictable at human scales 2. OS mixing of multiple sources - defense in depth 3. NIST beacon - quantum-sourced, publicly verifiable, but network-dependent</p>
<p>Path forward for Cyberspace: - Phase 1 (Now): libsodium with OS entropy (relies on hardware quality) - Phase 2: Optional quantum RNG hardware support (USB devices, PCIe cards) - Phase 3: Attestation of entropy source in realm metadata - Phase 4: Quantum RNG as standard infrastructure (as quantum internet develops)</p>
<p>Minimum acceptable: Modern Intel/AMD RDSEED instruction, which samples thermal noise at the silicon level. While not provably quantum, it has no known exploits and is mixed with other sources.</p>
<p>Goal: True quantum randomness as the foundation. The math requires it; the engineering will catch up.</p>
<h3>Cyberspace as Entropy Provider</h3>
<p>We will provide all the randomness that our users need - on demand, for whatever their cryptographic desires.</p>
<p>Cyberspace realms can serve as entropy sources for their users:</p>
<pre class="language-scheme">
;; Request entropy from the realm
(realm-entropy-request
  (bytes 32)
  (purpose "key-generation")
  (attestation-required #t))

;; Response includes attestation of entropy source
(realm-entropy-response
  (value #${...32 bytes...})
  (source "quantum-rng")
  (attestation (signed-by realm-principal)
               (hardware "ID-Quantique-QUANTIS")
               (timestamp 1736344800)))
</pre>
<p>Entropy services: 1. Local generation - Realm uses its best available source 2. Federated entropy - Request quantum entropy from realms with quantum hardware 3. Beacon aggregation - Mix NIST + drand + realm sources 4. Attestation chain - Prove the entropy source for audit</p>
<p>Long-term vision: A network of realms with quantum RNG hardware providing verifiable, quantum-sourced entropy to all participants. The soup carries randomness as naturally as it carries data.</p>
<h3>True Random Number Generators (TRNG)</h3>
<p>True randomness comes from physical processes that are fundamentally unpredictable:</p>
<p>#### Quantum Sources (Required for Provable Security)</p>
<p>The only sources that satisfy cryptographic assumptions. Quantum mechanics guarantees unpredictability:</p>
<p>- Photon beam splitters - Single photon hits 50/50 beam splitter, detection is truly random - Vacuum fluctuations - Measuring quantum vacuum state - Quantum tunneling - Electron tunneling through barriers - Nuclear decay - Timing of radioactive decay events</p>
<p>Commercial quantum RNGs: ID Quantique (QUANTIS), Quintessence Labs, Crypta Labs</p>
<p>#### Silicon-Based TRNG</p>
<p>Modern CPUs include hardware random number generators:</p>
<table>
<tr><th>CPU </th><th>Instruction </th><th>Mechanism </th></tr>
<tr><td>Intel </td><td>RDRAND/RDSEED </td><td>Thermal noise + AES-CBC-MAC </td></tr>
<tr><td>AMD </td><td>RDRAND/RDSEED </td><td>Ring oscillator jitter </td></tr>
<tr><td>ARM </td><td>TRNG </td><td>Metastable flip-flops </td></tr>
<tr><td>RISC-V </td><td>Zkr extension </td><td>Implementation-defined </td></tr>
</table>
<p>Security note: Intel's RDRAND has faced scrutiny. Mix with other sources.</p>
<h3>Environmental Entropy: Lavarand</h3>
<p>The most famous entropy source in computing.</p>
<p>Silicon Graphics (SGI) invented Lavarand in 1996. Cloudflare operates the modern successor.</p>
<p>#### How It Works</p>
<pre>
┌─────────────────────────────────────────────────────────────┐
│                     LAVARAND SYSTEM                          │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   ┌─────────┐    ┌─────────┐    ┌─────────────────────┐     │
│   │  Lava   │    │ Camera  │    │  Image → Hash       │     │
│   │  Lamp   │───▶│  Feed   │───▶│  SHA-256 per frame  │     │
│   │  Wall   │    │         │    │                     │     │
│   └─────────┘    └─────────┘    └──────────┬──────────┘     │
│                                            │                 │
│                                            ▼                 │
│                                  ┌─────────────────────┐     │
│                                  │  Entropy Pool       │     │
│                                  │  (mix with CSPRNG)  │     │
│                                  └─────────────────────┘     │
│                                                              │
└─────────────────────────────────────────────────────────────┘
</pre>
<p>#### Why Lava Lamps?</p>
<p>1. Chaotic fluid dynamics - Wax movement is unpredictable 2. Thermal convection - Heat creates complex flow patterns 3. High bandwidth - Each video frame yields fresh entropy 4. Tamper-evident - Physical installation is visible 5. Independent source - Not correlated with CPU state</p>
<p>Cloudflare's wall of 100 lava lamps generates entropy for ~10% of internet HTTPS traffic.</p>
<p>#### Other Environmental Sources</p>
<table>
<tr><th>Source </th><th>Mechanism </th><th>Bandwidth </th></tr>
<tr><td>Lava lamps </td><td>Fluid dynamics </td><td>~100 Kbit/s </td></tr>
<tr><td>Radioactive decay </td><td>Nuclear physics </td><td>~1-10 Kbit/s </td></tr>
<tr><td>Atmospheric noise </td><td>RF antenna </td><td>~1 Mbit/s </td></tr>
<tr><td>Thermal camera </td><td>Johnson-Nyquist noise </td><td>~10 Kbit/s </td></tr>
<tr><td>Double pendulum </td><td>Chaotic motion </td><td>~100 bit/s </td></tr>
<tr><td>Keyboard timing </td><td>Human unpredictability </td><td>~1-10 bit/keystroke </td></tr>
</table>
<h3>Public Randomness Beacons</h3>
<p>Beacons provide verifiable public randomness - useful for: - Lottery systems - Audit sampling - Distributed protocols - Zero-knowledge proofs</p>
<p>#### NIST Randomness Beacon</p>
<p>The National Institute of Standards and Technology operates a public randomness beacon since 2013.</p>
<pre>
https://beacon.nist.gov/beacon/2.0/pulse/last
</pre>
<p>Architecture:</p>
<pre>
┌─────────────────────────────────────────────────────────────┐
│                   NIST BEACON 2.0                            │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  Sources:           Processing:         Output:              │
│  ┌─────────┐       ┌───────────┐      ┌──────────────┐      │
│  │ Quantum │──┐    │           │      │ Pulse Record │      │
│  │   RNG   │  │    │  SHA-512  │      ├──────────────┤      │
│  └─────────┘  │    │  mixing   │      │ timestamp    │      │
│  ┌─────────┐  ├───▶│     +     │─────▶│ localRandom  │      │
│  │Photonic │  │    │  signing  │      │ outputValue  │      │
│  │  Noise  │──┘    │           │      │ signatureVal │      │
│  └─────────┘       └───────────┘      └──────────────┘      │
│                                                              │
│  Pulse interval: 60 seconds                                  │
│  Hash chain: Each pulse includes hash of previous            │
│  Signature: RSA-2048 (Beacon 2.0)                           │
│                                                              │
└─────────────────────────────────────────────────────────────┘
</pre>
<p>Pulse Record Contents: - uri - Unique pulse identifier - version - Beacon protocol version - timeStamp - Unix timestamp - localRandomValue - 512 bits from quantum sources - outputValue - SHA-512 hash (the public random value) - statusCode - Health indicator - signatureValue - Digital signature</p>
<p>Properties: - Unpredictable - Cannot be known before publication - Verifiable - Anyone can verify the signature chain - Non-manipulable - NIST cannot control output - Archived - Full history publicly available</p>
<p>Use in Cyberspace:</p>
<pre class="language-scheme">
;; For ceremonies, audits, public verifiability
(define (fetch-nist-beacon)
  (let* ((response (http-get "https://beacon.nist.gov/beacon/2.0/pulse/last"))
         (pulse (json-parse response))
         (output (assoc-ref pulse "outputValue")))
    (hex-&gt;blob output)))
</pre>
<p>#### Other Public Beacons</p>
<table>
<tr><th>Beacon </th><th>Operator </th><th>Source </th><th>Interval </th></tr>
<tr><td>NIST Beacon </td><td>US NIST </td><td>Quantum + photonic </td><td>60 seconds </td></tr>
<tr><td>Chile UChile </td><td>University of Chile </td><td>Seismic + radio </td><td>60 seconds </td></tr>
<tr><td>Cloudflare drand </td><td>League of Entropy </td><td>Distributed threshold </td><td>30 seconds </td></tr>
<tr><td>IRISA </td><td>French research </td><td>Multiple physical </td><td>60 seconds </td></tr>
</table>
<p>#### League of Entropy (drand)</p>
<p>Distributed randomness beacon - no single party controls the output:</p>
<pre>
┌─────────────────────────────────────────────────────────────┐
│              DRAND DISTRIBUTED BEACON                        │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   Cloudflare ──┐                                            │
│                │                                             │
│   EPFL ────────┼─── Threshold ───▶ Public Random           │
│                │    BLS Sig          (t-of-n nodes          │
│   Protocol ────┤    (t-of-n)          must participate)     │
│   Labs         │                                             │
│                │                                             │
│   Kudelski ────┘                                            │
│                                                              │
│   Endpoint: https://api.drand.sh/public/latest              │
│   Chain: 8990e7a9aaed2ffed73dbd7092123d6f289930540d7651336225dc172e51b2ce │
│                                                              │
└─────────────────────────────────────────────────────────────┘
</pre>
<h3>Entropy Mixing</h3>
<p>Real systems mix multiple sources for defense in depth:</p>
<pre class="language-scheme">
;; Conceptual entropy mixer
(define (mix-entropy-sources)
  (let ((hw (hardware-random-bytes 32))      ;; RDRAND
        (os (os-entropy-pool-bytes 32))       ;; /dev/urandom
        (env (environmental-entropy 32))      ;; If available
        (beacon (cached-nist-beacon)))        ;; Public verifiability
    ;; Mix with HKDF or similar
    (hkdf-sha512
      (blob-append hw os env beacon)
      "cyberspace-entropy-v1"
      64)))
</pre>
<h3>Historical Entropy Failures</h3>
<p>Learning from disasters:</p>
<table>
<tr><th>Incident </th><th>Year </th><th>Cause </th><th>Impact </th></tr>
<tr><td>Netscape SSL </td><td>1995 </td><td>PID + timestamp = predictable </td><td>All SSL broken </td></tr>
<tr><td>Debian OpenSSL </td><td>2006-2008 </td><td>Valgrind "fix" removed entropy </td><td>32,767 possible keys </td></tr>
<tr><td>Android SecureRandom </td><td>2013 </td><td>PRNG state reuse </td><td>Bitcoin wallets drained </td></tr>
<tr><td>DualECDRBG </td><td>2013 </td><td>NSA backdoor in constants </td><td>Unknown surveillance </td></tr>
<tr><td>Taiwan smart cards </td><td>2013 </td><td>Shared PRNG state </td><td>Factored RSA keys </td></tr>
</table>
<p>Lesson: Defense in depth. Mix multiple independent sources.</p>
<h3>Entropy Requirements by Operation</h3>
<table>
<tr><th>Operation </th><th>Entropy Needed </th><th>Notes </th></tr>
<tr><td>Ed25519 keypair </td><td>32 bytes </td><td>Full key security </td></tr>
<tr><td>X25519 keypair </td><td>32 bytes </td><td>Full key security </td></tr>
<tr><td>XSalsa20 nonce </td><td>24 bytes </td><td>Random OK (large space) </td></tr>
<tr><td>AES-GCM nonce </td><td>12 bytes </td><td>Counter preferred (small space) </td></tr>
<tr><td>Argon2id salt </td><td>16 bytes </td><td>Unique per derivation </td></tr>
<tr><td>Session ID </td><td>16-32 bytes </td><td>Unpredictable </td></tr>
<tr><td>ECDSA k-value </td><td>32 bytes </td><td>CRITICAL - must not repeat </td></tr>
</table>
</section>
<section>
<h2>Security Considerations</h2>
<h3>Entropy Exhaustion</h3>
<p>libsodium's randombytes_buf() never blocks on modern systems: - Uses ChaCha20 CSPRNG seeded from OS entropy - OS entropy pools are continuously replenished - Hardware RNG (RDRAND/RDSEED) available on modern CPUs</p>
<h3>VM/Container Considerations</h3>
<p>Virtual machines may have limited entropy at boot: - Use virtio-rng to pass host entropy to guests - Ensure haveged or rng-tools if entropy-limited - libsodium will block until sufficient entropy available</p>
<h3>Fork Safety</h3>
<p>libsodium handles fork correctly: - Automatic re-seeding after fork() - No duplicate random sequences in child processes</p>
<h3>Deterministic Testing</h3>
<p>For reproducible tests ONLY (never production):</p>
<pre class="language-scheme">
(define (set-test-seed seed)
  "WARNING: Deterministic mode - testing only"
  ((foreign-lambda void "randombytes_stir")))
</pre>
<p>Production code MUST use true entropy.</p>
</section>
<section>
<h2>Implementation Notes</h2>
<h3>Current Status</h3>
<table>
<tr><th>Component </th><th>Entropy Source </th><th>Status </th></tr>
<tr><td>crypto-ffi.scm </td><td>randombytes_buf() </td><td>Implemented </td></tr>
<tr><td>vault.scm (keystore) </td><td>random-bytes </td><td>Implemented </td></tr>
<tr><td>OCaml core </td><td>TBD </td><td>Open Issue </td></tr>
</table>
<h3>Audit Trail</h3>
<p>All key generation events should be logged (not the keys themselves):</p>
<pre class="language-scheme">
(seal-commit #f
  `(entropy-event
    (type "key-generation")
    (algorithm "ed25519")
    (timestamp ,(current-seconds))
    (entropy-source "libsodium")))
</pre>
<h3>Hardware Entropy</h3>
<p>When available, hardware entropy sources enhance security:</p>
<table>
<tr><th>Platform </th><th>Hardware RNG </th></tr>
<tr><td>Intel/AMD </td><td>RDRAND, RDSEED instructions </td></tr>
<tr><td>ARM </td><td>TRNG (True Random Number Generator) </td></tr>
<tr><td>Apple Silicon </td><td>Secure Enclave entropy </td></tr>
</table>
<p>libsodium automatically uses hardware entropy when available.</p>
</section>
<section>
<h2>Migration</h2>
<h3>Phase 1: Audit (Current)</h3>
<p>- Identify all randomness usage in codebase - Replace non-libsodium sources</p>
<h3>Phase 2: Standardize</h3>
<p>- All Scheme uses random-bytes from crypto-ffi - Document OCaml approach</p>
<h3>Phase 3: Verify</h3>
<p>- Entropy quality testing - Audit logging for key generation</p>
</section>
<section>
<h2>References</h2>
<p>- libsodium documentation: https://doc.libsodium.org/ - NIST SP 800-90A: Recommendations for Random Number Generation - RFC 4086: Randomness Requirements for Security - ChaCha20: https://cr.yp.to/chacha.html</p>
</section>
<section>
<h2>Appendix: Entropy Quality Testing</h2>
<p>For paranoid verification:</p>
<pre class="language-bash">
# Generate random data
csi -e "(import crypto-ffi) (display (random-bytes 1000000))" &gt; random.bin

# Run NIST statistical tests
ent random.bin
dieharder -a -f random.bin
</pre>
<p>Expected results: - Entropy: ~7.9999 bits per byte - Chi-square: p-value 0.01-0.99 - All dieharder tests: PASSED</p>
</section>
</body>
</html>
