<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RFC-016: Lazy Clustering</title>
  <link rel="stylesheet" href="rfc.css">
</head>
<body>
<h1>RFC-016: Lazy Clustering</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This RFC specifies Lazy Clustering for Cyberspace federation: a relaxed synchronization model where nodes sync when convenient, not continuously. Optimized for the "loose confederacy of friends" model.</p>
</section>
<section>
<h2>Motivation</h2>
<p>Not every deployment needs Byzantine consensus:</p>
<p>- Friends trust friends: No active adversary - Bandwidth costs: Continuous sync is expensive - Offline operation: Internet isn't always available - Simplicity: Complex protocols have complex bugs</p>
<p>Lazy Clustering provides:</p>
<p>1. Sync when ready: Push/pull at human pace 2. Offline-first: Work without network 3. Conflict detection: Know when divergence happens 4. Manual resolution: Humans resolve, not algorithms 5. Audit everything: Full history preserved</p>
<blockquote>
<p>The best protocol is the one you don't run.</p>
</blockquote>
</section>
<section>
<h2>Specification</h2>
<h3>Cluster Model</h3>
<pre>
     ┌─────────┐
     │  Alice  │
     │ (lazy)  │
     └────┬────┘
          │
          │ sync when ready @ 10Gb/s
          │
     ┌────▼────┐         ┌─────────┐
     │   Bob   │◄───────►│  Carol  │
     │ (lazy)  │ 10Gb/s  │ (lazy)  │
     └─────────┘         └─────────┘

No heartbeats. No leader election. No quorum.
Just friends sharing when they're ready.
At line speed when they do.
</pre>
<h3>Performance Model</h3>
<p>Lazy semantics, line speed execution.</p>
<pre>
Line speed (10 Gb/s):
  Typical release: 10 MB archive
  Transfer time:   8 ms
  Effective rate:  ~1000 releases/second

Starlink (100-200 Mb/s, 20-40ms latency):
  Typical release: 10 MB archive
  Transfer time:   400-800 ms
  Effective rate:  ~1-2 releases/second
  Optimized for:   Bursty, high-latency satellite links

Minimum bandwidth:
  Floor:           128 Kb/s (dual-ISDN)
  Target:          1 Mb/s (T1)
  Typical release: 10 MB archive
  Transfer time:   ~80 sec (T1), ~10 min (dual-ISDN)
  Strategy:        Delta sync, compressed archives
</pre>
<p>Crypto overhead (constant):</p>
<pre>
Signature verify: ~10 μs (Ed25519)
Hash verify:      ~1 ms (SHA-512, 10MB)
Total overhead:   ~1 ms (negligible vs transfer)
</pre>
<p>"Lazy" means when, not how fast. When you sync, it saturates the pipe.</p>
<p>Design priorities: 1. Optimized for Starlink and satellite links 2. Tolerant of high latency (no chatty protocols) 3. Graceful degradation to minimum bandwidth 4. Bursty transfer patterns (sync then idle)</p>
<h3>Heartbeat and Timekeeping</h3>
<p>No mandatory heartbeat. That's the design.</p>
<pre>
Traditional cluster:  ping → pong → ping → pong → ...
Lazy cluster:         ... silence ... (sync) ... silence ...
</pre>
<p>Timekeeping: Lamport clocks (RFC-012), not wall clocks. - Causality without synchronization - No NTP dependency - No GPS required - Works across time zones, planets</p>
<p>When you need consensus: Byzantine consensus (RFC-011) + Lamport clocks. - Lazy clustering for everyday sync - Byzantine consensus for critical decisions - Same Lamport clock across both modes</p>
<p>Optional presence beacon:</p>
<pre class="language-scheme">
(cluster-beacon
  (peer "alice")
  (lamport-time 4271)
  (last-release "2.1.0")
  (status available)
  (next-expected "when ready"))
</pre>
<p>Beacons are: - Pull-based (query, don't push) - Cached (no flood) - Stale-tolerant (hours/days old is fine) - Unsigned (advisory only)</p>
<h3>Sync Modes</h3>
<p>#### Push (I have something)</p>
<pre class="language-scheme">
(lazy-push peer)
;; Sends my new releases to peer
;; Non-blocking, fire-and-forget
</pre>
<p>#### Pull (What do you have?)</p>
<pre class="language-scheme">
(lazy-pull peer)
;; Fetches peer's new releases
;; Verifies signatures, stores locally
</pre>
<p>#### Sync (Bidirectional)</p>
<pre class="language-scheme">
(lazy-sync peer)
;; Push then pull
;; Returns conflict report if any
</pre>
<h3>Lazy Semantics</h3>
<p>No continuous connection. Nodes are offline by default.</p>
<p>No consistency guarantees. Nodes may diverge.</p>
<p>No automatic resolution. Conflicts flagged for humans.</p>
<p>No urgency. Sync happens when convenient.</p>
</section>
<section>
<h2>State Tracking</h2>
<h3>Version Vector</h3>
<p>Each node tracks what it knows about others:</p>
<pre class="language-scheme">
(define-record-type &lt;version-vector&gt;
  (make-version-vector entries)
  version-vector?
  (entries vv-entries))  ; Hash: node-id → latest-sequence

;; Alice's view:
;; { alice: 42, bob: 37, carol: 29 }
</pre>
<h3>Sync Calculation</h3>
<pre class="language-scheme">
(define (compute-sync-set local-vv remote-vv)
  "What to send/receive"
  (let ((to-send '())
        (to-receive '()))
    (for-each
      (lambda (node)
        (let ((local-seq (vv-get local-vv node))
              (remote-seq (vv-get remote-vv node)))
          (cond
            ((&gt; local-seq remote-seq)
             (push! to-send (releases-between node remote-seq local-seq)))
            ((&lt; local-seq remote-seq)
             (push! to-receive (list node remote-seq local-seq))))))
      (all-nodes local-vv remote-vv))
    (values to-send to-receive)))
</pre>
</section>
<section>
<h2>Conflict Detection</h2>
<h3>Divergence</h3>
<p>Same version, different content:</p>
<pre class="language-scheme">
(lazy-sync "bob")
;; =&gt;
;; ⚠ Conflict detected:
;;   Version 2.1.0
;;   Local:  sha512:abc123...
;;   Remote: sha512:def456...
;;
;;   Both modified since common ancestor 2.0.0
</pre>
<h3>Conflict Record</h3>
<pre class="language-scheme">
(conflict
  (version "2.1.0")
  (local-hash "sha512:abc123...")
  (remote-hash "sha512:def456...")
  (common-ancestor "2.0.0")
  (detected "2026-01-06T15:30:00Z")
  (status pending))  ; pending, resolved-local, resolved-remote, merged
</pre>
<h3>Resolution</h3>
<p>Manual resolution required:</p>
<pre class="language-scheme">
(lazy-resolve "2.1.0" prefer: 'local)
;; or
(lazy-resolve "2.1.0" prefer: 'remote)
;; or
(lazy-resolve "2.1.0" merged: "2.1.0-merged")
</pre>
</section>
<section>
<h2>Offline Operation</h2>
<h3>Work Offline</h3>
<pre class="language-scheme">
(seal-commit "Add feature")
(seal-release "2.2.0")
;; All local, no network required
</pre>
<h3>Queue for Sync</h3>
<pre class="language-scheme">
(lazy-queue)
;; =&gt;
;; Pending sync:
;;   2.1.1  (local, not pushed)
;;   2.2.0  (local, not pushed)
;;
;; To sync: (lazy-push "bob")
</pre>
<h3>Reconnect and Sync</h3>
<pre class="language-scheme">
(lazy-sync "bob")
;; Sends 2.1.1, 2.2.0
;; Receives bob's changes
;; Reports any conflicts
</pre>
</section>
<section>
<h2>Cluster Operations</h2>
<h3>Join Cluster</h3>
<pre class="language-scheme">
(lazy-join "bob"
  uri: "git@github.com:bob/vault.git"
  key: bob-public-key)
;; Registers peer, doesn't sync yet
</pre>
<h3>Initial Sync</h3>
<pre class="language-scheme">
(lazy-pull "bob")
;; Gets bob's full history
;; Verifies all signatures
</pre>
<h3>Leave Cluster</h3>
<pre class="language-scheme">
(lazy-leave "bob")
;; Removes peer from sync list
;; Keeps local copies of bob's releases
</pre>
<h3>Cluster Status</h3>
<pre class="language-scheme">
(lazy-status)
;; =&gt;
;; Cluster peers:
;;   bob    last-sync: 2026-01-05  versions: 1.0.0-2.1.0  ✓
;;   carol  last-sync: 2026-01-03  versions: 1.0.0-2.0.0  (2 behind)
;;   dave   last-sync: never       versions: none         (not synced)
;;
;; Local: 2.2.0 (2 ahead of cluster)
</pre>
</section>
<section>
<h2>Sync Strategies</h2>
<h3>Manual (Default)</h3>
<pre class="language-scheme">
(vault-config 'sync-strategy 'manual)
;; User explicitly calls lazy-sync
</pre>
<h3>Periodic</h3>
<pre class="language-scheme">
(vault-config 'sync-strategy 'periodic)
(vault-config 'sync-interval 3600)  ; hourly
;; Background sync when network available
</pre>
<h3>On-Commit</h3>
<pre class="language-scheme">
(vault-config 'sync-strategy 'on-commit)
;; Push after each seal-commit
;; Still lazy (non-blocking, best-effort)
</pre>
<h3>On-Release</h3>
<pre class="language-scheme">
(vault-config 'sync-strategy 'on-release)
;; Push only after seal-release
;; Most conservative
</pre>
</section>
<section>
<h2>Consistency Guarantees</h2>
<h3>What We Guarantee</h3>
<p>- Signature integrity: All releases verified - Causal ordering: Within single node - Conflict detection: Divergence detected - Audit preservation: Full history kept</p>
<h3>What We Don't Guarantee</h3>
<p>- Global ordering: Nodes may see different orders - Consistency: Nodes may have different content - Availability: Offline nodes are offline - Automatic resolution: Humans must resolve</p>
<h3>CAP Theorem Position</h3>
<pre>
      Consistency
          /\
         /  \
        /    \
       / Lazy \
      / Cluster\
     /    ✓     \
    /\
Availability    Partition
    ✓           Tolerance ✓
</pre>
<p>We choose AP: Available and Partition-tolerant, eventually consistent.</p>
</section>
<section>
<h2>Comparison with Other Modes</h2>
<table>
<tr><th>Aspect </th><th>Lazy Cluster </th><th>Federation (RFC-010) </th><th>Byzantine (RFC-011) </th></tr>
<tr><td>Trust </td><td>Friends </td><td>Verified peers </td><td>Adversarial </td></tr>
<tr><td>Sync </td><td>Manual/periodic </td><td>Announcement-based </td><td>Consensus </td></tr>
<tr><td>Conflicts </td><td>Manual resolve </td><td>Detect + flag </td><td>Prevented </td></tr>
<tr><td>Offline </td><td>Full support </td><td>Partial </td><td>Requires quorum </td></tr>
<tr><td>Complexity </td><td>Minimal </td><td>Medium </td><td>High </td></tr>
<tr><td>Use case </td><td>Small groups </td><td>Organizations </td><td>Critical systems </td></tr>
</table>
</section>
<section>
<h2>Example Session</h2>
<pre class="language-scheme">
;; Morning: Alice works offline
(seal-commit "Add authentication")
(seal-commit "Add authorization")
(seal-release "2.3.0")

;; Lunch: Alice syncs with Bob
(lazy-sync "bob")
;; =&gt; Pushed 2.3.0 to bob
;; =&gt; Pulled 2.2.1 from bob
;; =&gt; No conflicts

;; Evening: Alice syncs with Carol
(lazy-sync "carol")
;; =&gt; Pushed 2.2.1, 2.3.0 to carol
;; =&gt; Pulled nothing (carol hasn't released)
;; =&gt; ⚠ Carol has unsynced commits (not our concern)
</pre>
</section>
<section>
<h2>Security Considerations</h2>
<h3>Trust Model</h3>
<p>Lazy clustering assumes good-faith peers:</p>
<p>- Peers won't inject malicious releases - Peers won't withhold releases maliciously - Peers will eventually sync</p>
<p>Not suitable for: Adversarial environments, high-value targets.</p>
<p>Suitable for: Research groups, open source projects, friend networks.</p>
<h3>Signature Verification</h3>
<p>All releases still verified:</p>
<pre class="language-scheme">
(lazy-pull "bob")
;; Each release:
;;   1. Verify Ed25519 signature
;;   2. Verify hash matches content
;;   3. Check against known bob public key
;;   4. Store only if valid
</pre>
<h3>Conflict Attacks</h3>
<p>Malicious peer creates conflicting release.</p>
<p>Mitigation: - Conflicts flagged, not auto-resolved - Full audit trail of conflict - Peer reputation tracking</p>
</section>
<section>
<h2>Implementation Notes</h2>
<h3>Dependencies</h3>
<p>- crypto-ffi - Signature verification - audit - Sync logging - Transport (git/HTTP/filesystem)</p>
<h3>Storage</h3>
<pre>
.vault/
  lazy/
    peers.sexp        # Registered peers
    vectors.sexp      # Version vectors
    conflicts/        # Unresolved conflicts
    queue/            # Pending pushes
</pre>
</section>
<section>
<h2>References</h2>
<p>1. Saito, Y., &amp; Shapiro, M. (2005). Optimistic Replication. 2. Terry, D., et al. (1995). Managing Update Conflicts in Bayou. 3. DeCandia, G., et al. (2007). Dynamo: Amazon's Key-Value Store. 4. RFC-010: Federation Protocol 5. RFC-012: Lamport Logical Clocks</p>
</section>
<section>
<h2>Changelog</h2>
<p>- 2026-01-06 - Set minimum bandwidth: 128 Kb/s floor (dual-ISDN), 1 Mb/s target (T1) - 2026-01-06 - Initial specification</p>
</section>
</body>
</html>
