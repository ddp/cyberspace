<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RFC-011: Byzantine Consensus</title>
  <link rel="stylesheet" href="rfc.css">
</head>
<body>
<h1>RFC-011: Byzantine Consensus</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This RFC specifies Byzantine fault-tolerant consensus for Cyberspace federation, enabling agreement among distributed vaults even when some participants are faulty or malicious. N nodes tolerate up to f failures where N ≥ 3f + 1.</p>
</section>
<section>
<h2>Motivation</h2>
<p>Federation (RFC-010) assumes honest peers. Reality differs:</p>
<ul>
<li>Crash failures: Nodes go offline</li>
<li>Byzantine failures: Nodes lie, equivocate, or attack</li>
<li>Network partitions: Messages delayed or lost</li>
<li>Sybil attacks: Fake identities flood the network</li>
</ul>
<p>Byzantine consensus provides:</p>
<p>1. Safety: Honest nodes agree on same value 2. Liveness: System makes progress despite failures 3. Fault tolerance: Survives f failures with 3f+1 nodes</p>
<p>From Lamport, Shostak, and Pease (1982):</p>
<blockquote>
<p>The Byzantine Generals Problem: reaching agreement in the presence of traitors.</p>
</blockquote>
</section>
<section>
<h2>Specification</h2>
<h3>System Model</h3>
<pre>
Nodes:        N = 3f + 1 (tolerates f Byzantine faults)
Network:      Asynchronous with eventual delivery
Cryptography: Ed25519 signatures (authenticated channels)
</pre>
<h3>Consensus Properties</h3>
<p>Agreement: If honest node i decides v, honest node j decides v.</p>
<p>Validity: If all honest nodes propose v, decision is v.</p>
<p>Termination: All honest nodes eventually decide.</p>
<h3>Protocol: Practical Byzantine Fault Tolerance (PBFT)</h3>
<pre>
Phase 1: PRE-PREPARE
  Primary broadcasts ⟨PRE-PREPARE, v, n, sig⟩

Phase 2: PREPARE
  On valid PRE-PREPARE, broadcast ⟨PREPARE, v, n, sig⟩
  Collect 2f PREPARE messages

Phase 3: COMMIT
  On 2f+1 PREPARE, broadcast ⟨COMMIT, v, n, sig⟩
  Collect 2f+1 COMMIT messages

Decision:
  On 2f+1 COMMIT, decide v
</pre>
<h3>Message Formats</h3>
<pre class="language-scheme">
(consensus-message
  (type pre-prepare)
  (view 0)
  (sequence 42)
  (value-hash "sha512:...")
  (from #${primary-pubkey})
  (signature #${ed25519-sig}))

(consensus-message
  (type prepare)
  (view 0)
  (sequence 42)
  (value-hash "sha512:...")
  (from #${replica-pubkey})
  (signature #${ed25519-sig}))

(consensus-message
  (type commit)
  (view 0)
  (sequence 42)
  (from #${replica-pubkey})
  (signature #${ed25519-sig}))
</pre>
</section>
<section>
<h2>View Change</h2>
<p>When primary fails or is Byzantine:</p>
<pre>
1. Replica timeout on PRE-PREPARE
2. Broadcast ⟨VIEW-CHANGE, v+1, prepared-proofs⟩
3. New primary collects 2f+1 VIEW-CHANGE
4. New primary broadcasts ⟨NEW-VIEW, v+1, proofs⟩
5. Resume protocol in new view
</pre>
</section>
<section>
<h2>Application to Cyberspace</h2>
<h3>Federation Ordering</h3>
<pre class="language-scheme">
(consensus-propose
  (action release-publish)
  (version "2.0.0")
  (proposer #${alice-key}))

;; After consensus:
(consensus-decided
  (sequence 42)
  (action release-publish)
  (version "2.0.0")
  (decided-by (quorum ...)))
</pre>
<h3>Threshold Governance Integration</h3>
<p>Combine with RFC-007: - Consensus on what to do - Threshold signatures on authorization</p>
<pre class="language-scheme">
(governance-decision
  (consensus-sequence 42)
  (action deploy-production)
  (threshold-met 3-of-5)
  (signers (alice carol dave)))
</pre>
</section>
<section>
<h2>Optimizations</h2>
<h3>Speculation</h3>
<p>Execute optimistically before commit:</p>
<pre>
Tentative execution after 2f+1 PREPARE
Rollback if COMMIT fails
</pre>
<h3>Batching</h3>
<p>Amortize consensus over multiple operations:</p>
<pre>
(consensus-batch
  (sequence 42)
  (operations
    (release-publish "2.0.0")
    (release-publish "2.0.1")
    (config-update ...)))
</pre>
<h3>Fast Path</h3>
<p>When all replicas agree initially:</p>
<pre>
Skip PREPARE phase
Direct to COMMIT with 3f+1 matching responses
</pre>
</section>
<section>
<h2>Security Considerations</h2>
<h3>Threat Model</h3>
<p>Tolerates: - f Byzantine nodes (arbitrary behavior) - Network delays and reordering - Message loss (with retransmission)</p>
<p>Requires: - N ≥ 3f + 1 total nodes - Authenticated channels (signatures) - Eventual message delivery</p>
<h3>Attack Resistance</h3>
<table>
<tr><th>Attack </th><th>Mitigation </th></tr>
<tr><td>Equivocation </td><td>Signatures prove inconsistency </td></tr>
<tr><td>Replay </td><td>Sequence numbers, view numbers </td></tr>
<tr><td>Denial of service </td><td>View change, rate limiting </td></tr>
<tr><td>Sybil </td><td>SPKI admission control </td></tr>
</table>
</section>
<section>
<h2>Complexity</h2>
<table>
<tr><th>Metric </th><th>Value </th></tr>
<tr><td>Message complexity </td><td>O(N²) per decision </td></tr>
<tr><td>Communication rounds </td><td>3 (normal case) </td></tr>
<tr><td>Cryptographic operations </td><td>O(N) signatures/verifies </td></tr>
</table>
</section>
<section>
<h2>Implementation Notes</h2>
<h3>State Machine</h3>
<pre class="language-scheme">
(define-record-type &lt;pbft-state&gt;
  (make-pbft-state view sequence log prepared committed)
  pbft-state?
  (view pbft-view)
  (sequence pbft-sequence)
  (log pbft-log)              ; sequence → messages
  (prepared pbft-prepared)    ; sequence → value
  (committed pbft-committed)) ; sequence → value
</pre>
<h3>Dependencies</h3>
<ul>
<li>crypto-ffi</li>
<li>Ed25519 signatures - audit</li>
<li>Decision logging</li>
<li>Network transport (TCP, QUIC)</li>
</ul>
</section>
<section>
<h2>References</h2>
<p>1. Lamport, L., Shostak, R., &amp; Pease, M. (1982). The Byzantine Generals Problem. 2. Castro, M., &amp; Liskov, B. (1999). Practical Byzantine Fault Tolerance. 3. Yin, M., et al. (2019). HotStuff: BFT Consensus with Linearity and Responsiveness. 4. RFC-007: Threshold Signature Governance 5. RFC-010: Federation Protocol</p>
</section>
<section>
<h2>Changelog</h2>
<ul>
<li>2026-01-06</li>
<li>Initial specification</li>
</ul>
</section>
</body>
</html>
