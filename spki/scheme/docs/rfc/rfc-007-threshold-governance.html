<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RFC-007: Threshold Signature Governance</title>
  <link rel="stylesheet" href="rfc.css">
</head>
<body>
<h1>RFC-007: Threshold Signature Governance</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This RFC specifies the threshold signature system for Cyberspace governance, enabling K-of-N multi-party authorization for critical operations. Democracy in code: no single point of failure, no rogue administrator.</p>
</section>
<section>
<h2>Motivation</h2>
<p>Critical operations require collective authorization:</p>
<p>- Release signing: Multiple maintainers must approve - Deployment: Operations team quorum required - Key ceremonies: Distributed trust for root keys - Emergency response: Prevent unilateral action</p>
<p>Traditional approaches fail: - Shared passwords: Who has it? Who used it? - Sudo access: Root is root - Approval workflows: Soft controls, bypassable</p>
<p>Threshold signatures provide cryptographic enforcement:</p>
<blockquote>
<p>K valid signatures required. Not K-1. Not bypass. Mathematics.</p>
</blockquote>
</section>
<section>
<h2>Specification</h2>
<h3>Tiered Signing Model</h3>
<pre>
┌─────────────────────────────────────────────────────────────┐
│                    SIGNING TIERS                            │
├─────────────────────────────────────────────────────────────┤
│  Development     1-of-1    Single developer can iterate    │
│  Staging         2-of-2    Peer review required             │
│  Production      3-of-5    Governance council quorum        │
│  Emergency       5-of-7    Full council for critical ops    │
└─────────────────────────────────────────────────────────────┘
</pre>
<h3>Script Signature Record</h3>
<pre class="language-scheme">
(define-record-type &lt;script-signature&gt;
  (make-script-signature signer signature timestamp)
  script-signature?
  (signer signature-signer)        ; Ed25519 public key (32 bytes)
  (signature signature-value)      ; Ed25519 signature (64 bytes)
  (timestamp signature-timestamp)) ; Unix epoch seconds
</pre>
<h3>Signing a Script</h3>
<pre class="language-scheme">
(define (sign-script script-content private-key #!optional public-key)
  "Sign script content with a private key"
  ...)
</pre>
<p>Process: 1. Convert content to blob if string 2. Derive public key from private (if not provided) 3. Sign content with Ed25519 4. Record timestamp 5. Return script-signature record</p>
<h3>Verifying Single Signature</h3>
<pre class="language-scheme">
(define (verify-script script-content signature-record)
  "Verify a script signature"
  (ed25519-verify (signature-signer signature-record)
                  content-blob
                  (signature-value signature-record)))
</pre>
<h3>Threshold Verification</h3>
<pre class="language-scheme">
(define (verify-threshold-script script-content signature-records threshold)
  "Verify threshold signatures on a script
   Returns: #t if at least K signatures are valid"
  (let* ((valid-sigs (filter (lambda (sig)
                               (verify-script script-content sig))
                             signature-records))
         (valid-count (length valid-sigs)))
    (&gt;= valid-count threshold)))
</pre>
</section>
<section>
<h2>Signature File Format</h2>
<pre class="language-scheme">
;; deploy.sig
((signature "hex-signature" "hex-pubkey" 1767685100)
 (signature "hex-signature" "hex-pubkey" 1767685200)
 (signature "hex-signature" "hex-pubkey" 1767685300))
</pre>
<p>Each entry contains: - Signature bytes (hex-encoded) - Signer public key (hex-encoded) - Timestamp (Unix epoch)</p>
</section>
<section>
<h2>CLI Interface</h2>
<h3>cyberspace verify</h3>
<pre class="language-bash">
$ cyberspace verify deploy.scm deploy.sig \
    --threshold 3 \
    --keys alice.pub bob.pub carol.pub dave.pub eve.pub

=== Cyberspace Script Verification ===

Script:     deploy.scm
Signatures: deploy.sig
Threshold:  3
Keys:       5 provided

Found 3 signature(s) in file
  Signature 1: ✓ VALID (signer: cbc9b260da65f6a7...)
  Signature 2: ✓ VALID (signer: a5f8c9e3d2b1f0e4...)
  Signature 3: ✓ VALID (signer: 7d3e8b2c1a0f5e4d...)

✓ SUCCESS: Script verified with 3-of-3 threshold
</pre>
<h3>cyberspace run</h3>
<pre class="language-bash">
$ cyberspace run deploy.scm deploy.sig \
    --threshold 3 \
    --keys alice.pub bob.pub carol.pub dave.pub eve.pub

=== Cyberspace Script Verification ===
...
✓ SUCCESS: Script verified with 3-of-5 threshold

=== Executing Script ===
(seal-release "2.0.0"
  message: "Major release with new governance model"
  preserve: #t)
</pre>
</section>
<section>
<h2>Governance Scenarios</h2>
<h3>Production Deployment (3-of-5)</h3>
<pre class="language-scheme">
;; Governance Council: Alice, Bob, Carol, Dave, Eve
;; Threshold: 3 signatures required

(define deployment-script
  "(seal-release \"2.0.0\"
    message: \"Major release\"
    preserve: #t)")

;; Alice signs
(define sig-alice
  (sign-script deployment-script alice-private alice-public))

;; Carol signs
(define sig-carol
  (sign-script deployment-script carol-private carol-public))

;; Dave signs
(define sig-dave
  (sign-script deployment-script dave-private dave-public))

;; Verify threshold
(verify-threshold-script deployment-script
                        (list sig-alice sig-carol sig-dave)
                        3)
;; =&gt; #t
</pre>
<h3>Insufficient Signatures</h3>
<pre class="language-scheme">
;; Only 2 signatures
(define insufficient-sigs
  (list sig-alice sig-carol))

(verify-threshold-script deployment-script insufficient-sigs 3)
;; =&gt; #f (rejected: need 3, got 2)
</pre>
<h3>Tampered Script Detection</h3>
<pre class="language-scheme">
;; Attacker modifies script
(define tampered-script
  "(seal-release \"2.0.0\"
    message: \"HACKED - deploying malware\"
    preserve: #t)")

(verify-threshold-script tampered-script sufficient-sigs 3)
;; =&gt; #f (signatures don't match modified content)
</pre>
</section>
<section>
<h2>Multi-Signature vs Shamir</h2>
<p>Two threshold approaches exist:</p>
<h3>Multi-Signature (This RFC)</h3>
<pre>
Each party: own keypair
Signing:    each signs independently
Verify:     count valid signatures ≥ K
Use case:   governance, approvals
</pre>
<p>Advantages: - Each party maintains own key - Clear audit trail (who signed) - Simple revocation (by key) - No key reconstruction</p>
<h3>Shamir Splitting (RFC-008)</h3>
<pre>
Single key: split into N shares
Signing:    K parties reconstruct, sign once
Verify:     single signature
Use case:   key backup, recovery
</pre>
<p>Advantages: - Single signature output - Key never fully assembled (in advanced schemes) - Smaller signature files</p>
<p>For governance, multi-signature is preferred: - Accountability (which individuals approved) - No reconstruction ceremony - Works asynchronously</p>
</section>
<section>
<h2>Security Considerations</h2>
<h3>Threat Model</h3>
<p>Protected against: - Single compromised key (need K) - Rogue administrator (need quorum) - Script tampering (signatures fail) - Replay of old scripts (timestamps, context)</p>
<p>Not protected against: - K compromised keys - All parties colluding - Side-channel on signing devices</p>
<h3>Key Management</h3>
<p>1. Generation: Secure random via libsodium 2. Storage: Hardware tokens preferred, encrypted files acceptable 3. Distribution: Out-of-band verification of public keys 4. Rotation: New ceremony, revoke old keys</p>
<h3>Threshold Selection</h3>
<table>
<tr><th>Scenario </th><th>Threshold </th><th>Rationale </th></tr>
<tr><td>Development </td><td>1-of-1 </td><td>Fast iteration </td></tr>
<tr><td>Staging </td><td>2-of-2 </td><td>Peer review </td></tr>
<tr><td>Production </td><td>3-of-5 </td><td>Majority quorum </td></tr>
<tr><td>Root key </td><td>5-of-7 </td><td>Supermajority </td></tr>
<tr><td>Emergency </td><td>N-of-N </td><td>Full consensus </td></tr>
</table>
</section>
<section>
<h2>Audit Integration</h2>
<p>Every verified execution records:</p>
<pre class="language-scheme">
(audit-append
  actor: (threshold-verifier-list)
  action: (list 'script-execute script-hash)
  motivation: "Production deployment authorized"
  context: (list 'threshold 3 'signatures 3))
</pre>
<p>Audit trail shows: - Which signers authorized - What script was executed - When authorization occurred - Threshold requirements met</p>
</section>
<section>
<h2>Implementation Notes</h2>
<h3>Dependencies</h3>
<p>- crypto-ffi - Ed25519 operations - cert - SPKI integration - audit - Trail recording</p>
<h3>Performance</h3>
<p>- Signature verification: ~10μs per Ed25519 verify - Threshold check: O(N) where N = signature count - No network round-trips (offline verification)</p>
</section>
<section>
<h2>References</h2>
<p>1. Boneh, D., et al. (2001). Short Signatures from the Weil Pairing. 2. Gennaro, R., et al. (2016). Threshold-optimal DSA/ECDSA signatures. 3. NIST SP 800-57. Recommendation for Key Management. 4. RFC-004: SPKI Authorization Integration</p>
</section>
<section>
<h2>Changelog</h2>
<p>- 2026-01-06 - Initial specification</p>
</section>
</body>
</html>
