<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RFC-010: Federation Protocol</title>
  <link rel="stylesheet" href="rfc.css">
</head>
<body>
<h1>RFC-010: Federation Protocol</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This RFC specifies the Federation Protocol for the Library of Cyberspace: a peer-to-peer synchronization system enabling loose confederacies of friends to share and preserve cryptographically sealed artifacts without central authority.</p>
</section>
<section>
<h2>E Pluribus Unum</h2>
<p>Out of many, one.</p>
<pre>
    ┌─────────┐         ┌─────────┐         ┌─────────┐
    │  Alice  │◄───────►│   Bob   │◄───────►│  Carol  │
    │  Vault  │         │  Vault  │         │  Vault  │
    └────┬────┘         └────┬────┘         └────┬────┘
         │                   │                   │
         │    ┌──────────────┴──────────────┐    │
         │    │                             │    │
         └────►    No Central Authority    ◄────┘
              │                             │
              │   Just keys, seals, trust   │
              │                             │
              └─────────────────────────────┘
</pre>
</section>
<section>
<h2>Motivation</h2>
<p>Centralized systems fail:</p>
<p>- Single point of failure: Server goes down, everyone stops - Censorship: Authority can deny access - Trust concentration: Must trust operator - Survival: Company folds, data lost</p>
<p>Federation provides:</p>
<p>1. Decentralized - No master server 2. Resilient - Survives node failures 3. Autonomous - Each peer controls own data 4. Cryptographic - Trust through math, not authority 5. Eventual consistency - Convergence without coordination</p>
</section>
<section>
<h2>Federation Model</h2>
<h3>Peer Relationships</h3>
<pre>
Peer: A vault instance with identity (SPKI principal)

Relationships:
  - Publisher:  I push releases to you
  - Subscriber: I pull releases from you
  - Peer:       Bidirectional sync
</pre>
<h3>Trust Model</h3>
<pre class="language-scheme">
(federation-trust
  (peer alice-pubkey
    (role publisher)
    (trust-level verified)     ; Signature verified
    (sync-policy automatic))

  (peer bob-pubkey
    (role subscriber)
    (trust-level known)        ; Key known, not verified
    (sync-policy manual)))
</pre>
<p>Trust levels: - unknown: Never seen, reject - known: Key registered, manual approval - verified: Signature chain verified via SPKI - trusted: Full automatic sync</p>
</section>
<section>
<h2>Protocol Operations</h2>
<h3>Peer Discovery</h3>
<pre class="language-scheme">
(federation-discover)
;; Returns: List of known peers and their status
</pre>
<p>Discovery mechanisms: 1. Explicit configuration: Known peer list 2. Git remotes: Extract from repository 3. Directory service: Optional, not required 4. mDNS/Bonjour: Local network discovery via cyberspace.tcp</p>
<h3>mDNS Service Discovery</h3>
<p>Cyberspace nodes announce themselves via mDNS using the cyberspace.tcp service type:</p>
<pre class="language-scheme">
;; Announce this node
(announce-presence 'starlight)
;; Registers: starlight.cyberspace.tcp.local. port 7654

;; Discover peers
(discover-peers)
;; Scans for cyberspace.tcp services on local network
</pre>
<p>Platform support: - macOS: dns-sd -R for registration, dns-sd -B for browsing - Linux: avahi-publish for registration, avahi-browse for browsing</p>
<h3>Peer Registration</h3>
<pre class="language-scheme">
(federation-register peer-uri
  #!key public-key trust-level)
</pre>
<p>Registers a new peer with: - URI (git remote, HTTP endpoint, filesystem path) - Public key for verification - Initial trust level</p>
<h3>Release Announcement</h3>
<pre class="language-scheme">
(federation-announce version
  #!key peers message)
</pre>
<p>Pushes release notification to peers: 1. Create signed announcement 2. Send to specified peers (or all) 3. Peers verify signature 4. Peers decide whether to pull</p>
<h3>Release Request</h3>
<pre class="language-scheme">
(federation-request version peer
  #!key verify-key)
</pre>
<p>Pulls specific release from peer: 1. Request release metadata 2. Verify signature 3. Download archive 4. Verify integrity 5. Record in audit trail</p>
<h3>Synchronization</h3>
<pre class="language-scheme">
(federation-sync peer
  #!key direction verify-key)
</pre>
<p>Bidirectional sync (from RFC-001): 1. Exchange release lists 2. Identify missing releases 3. Push/pull as configured 4. Verify all signatures 5. Update audit trails</p>
</section>
<section>
<h2>Message Format</h2>
<h3>Announcement Message</h3>
<pre class="language-scheme">
(federation-message
  (type announcement)
  (from #${alice-pubkey})
  (timestamp 1767685100)
  (payload
    (release "2.0.0")
    (hash "sha512:...")
    (archive-size 1048576)
    (notes "Major release"))
  (signature #${ed25519-sig}))
</pre>
<h3>Request Message</h3>
<pre class="language-scheme">
(federation-message
  (type request)
  (from #${bob-pubkey})
  (timestamp 1767685200)
  (payload
    (release "2.0.0")
    (format cryptographic))
  (signature #${ed25519-sig}))
</pre>
<h3>Response Message</h3>
<pre class="language-scheme">
(federation-message
  (type response)
  (from #${alice-pubkey})
  (in-reply-to "sha512:request-hash")
  (timestamp 1767685300)
  (payload
    (release "2.0.0")
    (archive-uri "/releases/vault-2.0.0.archive")
    (hash "sha512:...")
    (signature "ed25519:..."))
  (signature #${ed25519-sig}))
</pre>
</section>
<section>
<h2>Transport Bindings</h2>
<h3>Git Transport</h3>
<pre>
Origin: git@github.com:alice/vault.git
Mechanism: Tags + release assets

Announce: git push origin v2.0.0
Request:  git fetch origin --tags
Sync:     git fetch origin &amp;&amp; git push origin
</pre>
<h3>HTTP Transport</h3>
<pre>
Endpoint: https://alice.example.com/federation

Announce: POST /federation/announce
Request:  GET /federation/releases/2.0.0
Sync:     POST /federation/sync
</pre>
<h3>Filesystem Transport</h3>
<pre>
Path: /shared/federation/alice

Announce: Copy to /shared/federation/alice/announce/
Request:  Read from /shared/federation/alice/releases/
Sync:     rsync --update
</pre>
</section>
<section>
<h2>Conflict Resolution</h2>
<h3>Version Conflicts</h3>
<p>Same version, different content:</p>
<pre class="language-scheme">
(federation-conflict
  (version "2.0.0")
  (local-hash "sha512:abc...")
  (remote-hash "sha512:def...")
  (resolution reject))  ; Or: prefer-local, prefer-remote, rename
</pre>
<p>Default: Reject conflicts, require human decision.</p>
<h3>Resolution Strategies</h3>
<p>1. Reject: Stop sync, alert human 2. Prefer-local: Keep local version 3. Prefer-remote: Take remote version 4. Rename: Keep both as 2.0.0-local, 2.0.0-remote 5. Merge: If content mergeable (future)</p>
</section>
<section>
<h2>Consistency Model</h2>
<h3>Eventual Consistency</h3>
<p>- No global ordering required - Each peer has local view - Convergence through sync - Conflicts resolved locally</p>
<h3>Causal Ordering</h3>
<p>Within a peer's releases: - Version numbers are monotonic - Audit trail provides causality - Hash chains prevent reordering</p>
<h3>No Coordination</h3>
<p>- No consensus protocol required - No distributed lock - No leader election - Each peer autonomous</p>
</section>
<section>
<h2>Security Considerations</h2>
<h3>Threat Model</h3>
<p>Protected: - Unauthenticated release injection (signature verification) - Content tampering (hash verification) - Impersonation (SPKI principal binding) - Replay attacks (timestamps, sequence numbers)</p>
<p>Not protected: - Denial of service (rate limiting helps) - Privacy of release metadata (encrypted transport helps) - Sybil attacks (trust management helps)</p>
<h3>Trust Verification</h3>
<pre class="language-scheme">
(define (verify-peer-message msg peer-key)
  (and (verify-signature msg peer-key)
       (verify-timestamp msg (current-seconds))
       (verify-not-replayed msg)))
</pre>
<h3>Rate Limiting</h3>
<pre class="language-scheme">
(federation-config
  (rate-limit
    (announcements-per-hour 10)
    (requests-per-minute 60)
    (sync-interval-minimum 300)))
</pre>
</section>
<section>
<h2>Gossip Protocol (Future)</h2>
<p>For larger networks:</p>
<pre>
Alice announces to Bob and Carol
Bob announces to Dave and Eve
Eve announces to Frank

Result: Epidemic spread without central broadcast
</pre>
<p>Properties: - Logarithmic propagation time - Resilient to node failures - No single bottleneck</p>
</section>
<section>
<h2>Bootstrap Procedure</h2>
<h3>New Peer Joining</h3>
<p>1. Generate keypair 2. Register with known peer 3. Exchange public keys (out-of-band verification) 4. Initial sync to get current releases 5. Begin participating in federation</p>
<h3>Network Partitions</h3>
<p>- Partitions heal automatically on reconnection - Conflicting releases detected and flagged - Audit trails show partition history</p>
</section>
<section>
<h2>Configuration</h2>
<pre class="language-scheme">
(federation-config
  ;; Identity
  (identity my-private-key)

  ;; Peers
  (peers
    (peer "alice" uri: "git@github.com:alice/vault.git"
                  key: alice-pubkey
                  trust: verified)
    (peer "bob"   uri: "/shared/bob-vault"
                  key: bob-pubkey
                  trust: known))

  ;; Policies
  (auto-sync #t)
  (sync-interval 3600)  ; seconds
  (verify-before-accept #t)

  ;; Security
  (require-signature #t)
  (trust-on-first-use #f))
</pre>
</section>
<section>
<h2>Implementation Status</h2>
<h3>Implemented (RFC-001)</h3>
<p>- seal-publish: Push to single remote - seal-subscribe: Pull from single remote - seal-synchronize: Bidirectional with single peer - Transport: git, HTTP, filesystem</p>
<h3>Proposed (This RFC)</h3>
<p>- Multi-peer management - Trust levels and policies - Announcement protocol - Gossip propagation - Conflict resolution UI</p>
</section>
<section>
<h2>References</h2>
<p>1. Birman, K. (2007). The Promise, and Limitations, of Gossip Protocols. 2. Demers, A., et al. (1987). Epidemic Algorithms for Replicated Database Maintenance. 3. Shapiro, M., et al. (2011). Conflict-Free Replicated Data Types. 4. RFC-001: Replication Layer 5. RFC-004: SPKI Authorization</p>
</section>
<section>
<h2>Changelog</h2>
<p>- 2026-01-06 - Initial specification</p>
</section>
</body>
</html>
