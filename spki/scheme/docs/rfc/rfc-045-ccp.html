<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>rfc-045-ccp</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="" />
</head>
<body>
<h1 id="rfc-045-cookie-capability-protocol-ccp">RFC-045:
Cookie-Capability Protocol (CCP)</h1>
<p><strong>Status:</strong> Implemented <strong>Date:</strong> January
2026 <strong>Author:</strong> Library of Cyberspace Contributors
<strong>Inspiration:</strong> PHOTURIS (Karn/Simpson, RFC 2522)
<strong>Implementation:</strong> cyberspace-repl</p>
<hr />
<h2 id="abstract">Abstract</h2>
<p>CCP establishes secure channels between Cyberspace nodes using
stateless cookies for DoS resistance, ephemeral key exchange for forward
secrecy, and capability attestation for authorization. No X.509. No CA
hierarchy. No algorithm negotiation.</p>
<hr />
<h2 id="motivation">Motivation</h2>
<p>TLS is complex: - Certificate chains require PKI - Algorithm
negotiation invites downgrade attacks - State allocated before client
proven real - Identity exposed before encryption</p>
<p>PHOTURIS (1995) had better ideas: - Cookies before crypto - Identity
under encryption - Simple state machine</p>
<p>CCP resurrects these ideas with modern primitives.</p>
<hr />
<h2 id="protocol-overview">Protocol Overview</h2>
<pre><code>Initiator                          Responder
    |                                   |
    |-------- KNOCK (version) --------&gt;|  Stateless
    |&lt;-------- COOKIE -----------------|  Stateless
    |                                   |
    |-------- EXCHANGE (eph key) -----&gt;|  State committed
    |&lt;------- EXCHANGE (eph key) ------|
    |                                   |
    |========= encrypted below ========|
    |                                   |
    |-------- ATTEST (identity) ------&gt;|
    |&lt;------- ATTEST (identity) -------|
    |                                   |
    |-------- OFFER (capabilities) ---&gt;|
    |&lt;------- OFFER (capabilities) ----|
    |                                   |
    |-------- CONFIRM (transcript) ---&gt;|
    |&lt;------- CONFIRM (transcript) ----|
    |                                   |
    |========= CHANNEL OPEN ===========|
    |                                   |
    |&lt;----------- DATA --------------&gt;|</code></pre>
<p>10 messages to establish. Unlimited encrypted DATA after.</p>
<hr />
<h2 id="message-format">Message Format</h2>
<p>All messages use TLV encoding:</p>
<pre><code>+------+--------+------------------+
| Type | Length | Payload          |
| 1B   | 4B BE  | variable         |
+------+--------+------------------+</code></pre>
<h3 id="message-types">Message Types</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Name</th>
<th>Direction</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x01</td>
<td>KNOCK</td>
<td>I → R</td>
</tr>
<tr>
<td>0x02</td>
<td>COOKIE</td>
<td>R → I</td>
</tr>
<tr>
<td>0x03</td>
<td>EXCHANGE</td>
<td>bidirectional</td>
</tr>
<tr>
<td>0x04</td>
<td>ATTEST</td>
<td>bidirectional</td>
</tr>
<tr>
<td>0x05</td>
<td>OFFER</td>
<td>bidirectional</td>
</tr>
<tr>
<td>0x06</td>
<td>CONFIRM</td>
<td>bidirectional</td>
</tr>
<tr>
<td>0x10</td>
<td>DATA</td>
<td>bidirectional</td>
</tr>
<tr>
<td>0xFF</td>
<td>CLOSE</td>
<td>bidirectional</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="phase-1-knock">Phase 1: KNOCK</h2>
<p>Initiator announces intent and protocol version.</p>
<pre><code>KNOCK payload:
  &quot;CCP/&quot; VERSION_MAJOR &quot;.&quot; VERSION_MINOR

Example: &quot;CCP/1.0&quot;</code></pre>
<p>Responder checks version compatibility: - Major mismatch: reject
(incompatible suites) - Minor mismatch: accept (backward compatible)</p>
<p><strong>Responder allocates no state.</strong></p>
<hr />
<h2 id="phase-2-cookie">Phase 2: COOKIE</h2>
<p>Responder returns stateless cookie.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="fu">make-cookie </span>remote-addr remote-port)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let*</span> ((data (<span class="kw">string-append</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>                (blob-&gt;string *cookie-secret*)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>                remote-addr</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>                (<span class="kw">number-&gt;string</span> remote-port)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>                (<span class="kw">number-&gt;string</span> *cookie-epoch*)))</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>         (hash (blake2b-hash (string-&gt;blob data))))</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">substring</span> hash <span class="dv">0</span> <span class="dv">16</span>)))</span></code></pre></div>
<p>Cookie properties: - <strong>Stateless</strong>: Responder doesn’t
store it - <strong>Unforgeable</strong>: Requires server secret -
<strong>Expiring</strong>: Epoch rotation invalidates old cookies -
<strong>Address-bound</strong>: Different address = different cookie</p>
<p><strong>Responder still allocates no state.</strong></p>
<hr />
<h2 id="phase-3-exchange">Phase 3: EXCHANGE</h2>
<p>Both parties exchange ephemeral public keys.</p>
<p>Initiator sends:</p>
<pre><code>EXCHANGE payload:
  cookie-r &quot;|&quot; cookie-i &quot;|&quot; ephemeral-public-hex</code></pre>
<ul>
<li><code>cookie-r</code>: Echo of responder’s cookie (proves
receipt)</li>
<li><code>cookie-i</code>: Initiator’s random cookie (for key
derivation)</li>
<li><code>ephemeral-public</code>: X25519 public key</li>
</ul>
<p>Responder verifies cookie echo, then responds with same format.</p>
<p><strong>State now committed. Keys derived.</strong></p>
<h3 id="key-derivation">Key Derivation</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="fu">derive-session-keys </span>shared-secret cookie-i cookie-r)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let*</span> ((ikm (blob-append shared-secret</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>                           (string-&gt;blob cookie-i)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>                           (string-&gt;blob cookie-r)))</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>         (prk (blake2b-hash ikm))</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>         (k-ir (blake2b-hash (blob-append prk <span class="st">&quot;initiator-&gt;responder&quot;</span>)))</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>         (k-ri (blake2b-hash (blob-append prk <span class="st">&quot;responder-&gt;initiator&quot;</span>))))</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">values</span> (take k-ir <span class="dv">32</span>) (take k-ri <span class="dv">32</span>))))</span></code></pre></div>
<p>Directional keys prevent reflection attacks.</p>
<hr />
<h2 id="phase-4-attest">Phase 4: ATTEST</h2>
<p><strong>All subsequent messages encrypted.</strong></p>
<p>Both parties prove identity using SPKI principals.</p>
<pre><code>ATTEST payload (encrypted):
  principal-hash &quot;|&quot; signature</code></pre>
<ul>
<li><code>principal-hash</code>: SPKI principal (hex-encoded public key
hash)</li>
<li><code>signature</code>: Ed25519 signature over transcript</li>
</ul>
<p><strong>Identity is cryptographic, not nominal.</strong> A principal
is identified solely by its public key hash, never by a human-readable
name. This is a prime directive.</p>
<p>Transcript for signing:</p>
<pre><code>cookie-i || cookie-r || ephemeral-public</code></pre>
<h3 id="anonymous-attestation-optional">Anonymous Attestation
(Optional)</h3>
<p>For privacy, use Chaum-style blind signatures:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="fu">blind-attest </span>capability-hash)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">;; Prove authorization without revealing identity</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  (blind-sign capability-hash (blind-factor)))</span></code></pre></div>
<hr />
<h2 id="phase-5-offer">Phase 5: OFFER</h2>
<p>Exchange authorized capabilities as SPKI tags.</p>
<pre><code>OFFER payload (encrypted):
  (tag (* set capability ...))

Example: &quot;(tag (* set read write replicate))&quot;</code></pre>
<p>Capabilities follow RFC-021 (Capability Delegation): - Only offer
what you hold - Attenuation only, no amplification - Explicit, not
ambient - <strong>Expressed as SPKI tag s-expressions</strong></p>
<p>Future: Full SPKI auth-certs with issuer signatures.</p>
<hr />
<h2 id="phase-6-confirm">Phase 6: CONFIRM</h2>
<p>Bind entire transcript.</p>
<pre><code>CONFIRM payload (encrypted):
  BLAKE2b(cookie-i || cookie-r || their-principal)</code></pre>
<p>Both parties must produce matching hashes. Any tampering
detected.</p>
<hr />
<h2 id="data-phase">DATA Phase</h2>
<p>Channel open. Encrypted messaging.</p>
<pre><code>DATA payload:
  ChaCha20-Poly1305(key, nonce, plaintext)</code></pre>
<p>Nonce construction:</p>
<pre><code>nonce = sequence-number (8 bytes) || 0x00000000 (4 bytes)</code></pre>
<p>Sequence numbers: - Start at 0 - Increment per message - Prevent
replay - Separate counters per direction</p>
<hr />
<h2 id="algorithm-suites">Algorithm Suites</h2>
<p><strong>No runtime negotiation.</strong> Version determines
suite.</p>
<h3 id="ccp1.x-current">CCP/1.x (Current)</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Algorithm</th>
</tr>
</thead>
<tbody>
<tr>
<td>Key Exchange</td>
<td>X25519</td>
</tr>
<tr>
<td>Signatures</td>
<td>Ed25519</td>
</tr>
<tr>
<td>AEAD</td>
<td>ChaCha20-Poly1305</td>
</tr>
<tr>
<td>Hash</td>
<td>BLAKE2b</td>
</tr>
<tr>
<td>KDF</td>
<td>HKDF-BLAKE2b</td>
</tr>
</tbody>
</table>
<h3 id="ccp2.x-reserved-post-quantum">CCP/2.x (Reserved:
Post-Quantum)</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Algorithm</th>
</tr>
</thead>
<tbody>
<tr>
<td>Key Exchange</td>
<td>Kyber-1024</td>
</tr>
<tr>
<td>Signatures</td>
<td>Dilithium3</td>
</tr>
<tr>
<td>AEAD</td>
<td>ChaCha20-Poly1305</td>
</tr>
<tr>
<td>Hash</td>
<td>BLAKE2b</td>
</tr>
</tbody>
</table>
<h3 id="ccp3.x-reserved-hybrid">CCP/3.x (Reserved: Hybrid)</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Algorithm</th>
</tr>
</thead>
<tbody>
<tr>
<td>Key Exchange</td>
<td>X25519 + Kyber</td>
</tr>
<tr>
<td>Signatures</td>
<td>Ed25519 + Dilithium</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="security-properties">Security Properties</h2>
<h3 id="dos-resistance">DoS Resistance</h3>
<table>
<thead>
<tr>
<th>Attack</th>
<th>Defense</th>
</tr>
</thead>
<tbody>
<tr>
<td>SYN flood</td>
<td>Cookie proves return path</td>
</tr>
<tr>
<td>Amplification</td>
<td>No response until cookie echo</td>
</tr>
<tr>
<td>State exhaustion</td>
<td>No state until Phase 3</td>
</tr>
</tbody>
</table>
<h3 id="forward-secrecy">Forward Secrecy</h3>
<p>Ephemeral X25519 keys: - Generated per session - Destroyed after key
derivation - Compromise of long-term key doesn’t expose past
sessions</p>
<h3 id="identity-protection-spki-native">Identity Protection (SPKI
Native)</h3>
<p>Principal identity: - <strong>Is the public key hash</strong> (not a
name, not a certificate) - Only revealed after encryption established -
Only revealed to authenticated peer - Never in plaintext on wire -
Self-certifying: principal = hash(public_key)</p>
<h3 id="replay-protection">Replay Protection</h3>
<ul>
<li>Sequence numbers per direction</li>
<li>Nonce never reused (fatal if violated)</li>
<li>AEAD authentication fails on replay</li>
</ul>
<hr />
<h2 id="comparison">Comparison</h2>
<table>
<thead>
<tr>
<th>Property</th>
<th>TLS 1.3</th>
<th>IKEv2</th>
<th>CCP</th>
</tr>
</thead>
<tbody>
<tr>
<td>Messages to establish</td>
<td>2-3</td>
<td>4+</td>
<td>10</td>
</tr>
<tr>
<td>DoS resistance</td>
<td>Limited</td>
<td>Cookies</td>
<td>Cookies</td>
</tr>
<tr>
<td>Algorithm negotiation</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Certificate required</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Identity protection</td>
<td>Partial</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Capability binding</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>CCP trades fewer round-trips for simplicity and capability
integration.</p>
<hr />
<h2 id="implementation">Implementation</h2>
<div class="sourceCode" id="cb14"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">;; Initiator</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> ch </span>(node-connect <span class="st">&quot;remote.host&quot;</span> <span class="dv">4433</span>))</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>(channel-send ch &#39;(request object-hash))</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>(channel-recv ch)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="co">;; Responder</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>(node-listen <span class="dv">4433</span> <span class="st">&quot;my-node&quot;</span>)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> ch </span>(node-accept))</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> ((msg (channel-recv ch)))</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>  (channel-send ch (process msg)))</span></code></pre></div>
<hr />
<h2 id="references">References</h2>
<ol type="1">
<li>Karn, P. &amp; Simpson, W. (1999). PHOTURIS. RFC 2522.</li>
<li>Karn, P. &amp; Simpson, W. (1999). PHOTURIS Extended Schemes. RFC
2523.</li>
<li>Bernstein, D.J. (2006). Curve25519.</li>
<li>Bernstein, D.J. (2008). ChaCha20.</li>
<li>RFC-021: Capability Delegation</li>
<li>RFC-040: Security Architecture</li>
</ol>
<hr />
<h2 id="changelog">Changelog</h2>
<ul>
<li><strong>2026-01-07</strong>: Initial specification</li>
</ul>
<hr />
<p><strong>Implementation Status:</strong> Complete (placeholder crypto)
<strong>Test Status:</strong> Passing (two-node handshake + messaging)
<strong>Next:</strong> Real libsodium AEAD bindings</p>
</body>
</html>
