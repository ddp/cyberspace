<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <title>RFC-045: Cookie-Capability Protocol (CCP)</title>
  <link rel="stylesheet" href="rfc.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<h1>RFC-045: Cookie-Capability Protocol (CCP)</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>CCP establishes secure channels between Cyberspace nodes using stateless cookies for DoS resistance, ephemeral key exchange for forward secrecy, and capability attestation for authorization. No X.509. No CA hierarchy. No algorithm negotiation.</p>
</section>
<section>
<h2>Motivation</h2>
<p>TLS is complex: - Certificate chains require PKI - Algorithm negotiation invites downgrade attacks - State allocated before client proven real - Identity exposed before encryption</p>
<p>PHOTURIS (1995) had better ideas: - Cookies before crypto - Identity under encryption - Simple state machine</p>
<p>CCP resurrects these ideas with modern primitives.</p>
</section>
<section>
<h2>Protocol Overview</h2>
<pre>
Initiator                          Responder
    |                                   |
    |-------- KNOCK (version) --------&gt;|  Stateless
    |&lt;-------- COOKIE -----------------|  Stateless
    |                                   |
    |-------- EXCHANGE (eph key) -----&gt;|  State committed
    |&lt;------- EXCHANGE (eph key) ------|
    |                                   |
    |========= encrypted below ========|
    |                                   |
    |-------- ATTEST (identity) ------&gt;|
    |&lt;------- ATTEST (identity) -------|
    |                                   |
    |-------- OFFER (capabilities) ---&gt;|
    |&lt;------- OFFER (capabilities) ----|
    |                                   |
    |-------- CONFIRM (transcript) ---&gt;|
    |&lt;------- CONFIRM (transcript) ----|
    |                                   |
    |========= CHANNEL OPEN ===========|
    |                                   |
    |&lt;----------- DATA --------------&gt;|
</pre>
<p>10 messages to establish. Unlimited encrypted DATA after.</p>
</section>
<section>
<h2>Message Format</h2>
<p>All messages use TLV encoding:</p>
<pre>
+------+--------+------------------+
| Type | Length | Payload          |
| 1B   | 4B BE  | variable         |
+------+--------+------------------+
</pre>
<h3>Message Types</h3>
<table>
<tr><th>Type </th><th>Name </th><th>Direction </th></tr>
<tr><td>0x01 </td><td>KNOCK </td><td>I → R </td></tr>
<tr><td>0x02 </td><td>COOKIE </td><td>R → I </td></tr>
<tr><td>0x03 </td><td>EXCHANGE </td><td>bidirectional </td></tr>
<tr><td>0x04 </td><td>ATTEST </td><td>bidirectional </td></tr>
<tr><td>0x05 </td><td>OFFER </td><td>bidirectional </td></tr>
<tr><td>0x06 </td><td>CONFIRM </td><td>bidirectional </td></tr>
<tr><td>0x10 </td><td>DATA </td><td>bidirectional </td></tr>
<tr><td>0xFF </td><td>CLOSE </td><td>bidirectional </td></tr>
</table>
</section>
<section>
<h2>Phase 1: KNOCK</h2>
<p>Initiator announces intent and protocol version.</p>
<pre>
KNOCK payload:
  "CCP/" VERSIONMAJOR "." VERSIONMINOR

Example: "CCP/1.0"
</pre>
<p>Responder checks version compatibility: - Major mismatch: reject (incompatible suites) - Minor mismatch: accept (backward compatible)</p>
<p>Responder allocates no state.</p>
</section>
<section>
<h2>Phase 2: COOKIE</h2>
<p>Responder returns stateless cookie.</p>
<pre class="language-scheme">
(define (make-cookie remote-addr remote-port)
  (let ((data (string-append
                (blob-&gt;string cookie-secret)
                remote-addr
                (number-&gt;string remote-port)
                (number-&gt;string cookie-epoch*)))
         (hash (blake2b-hash (string-&gt;blob data))))
    (substring hash 0 16)))
</pre>
<p>Cookie properties: - Stateless: Responder doesn't store it - Unforgeable: Requires server secret - Expiring: Epoch rotation invalidates old cookies - Address-bound: Different address = different cookie</p>
<p>Responder still allocates no state.</p>
</section>
<section>
<h2>Phase 3: EXCHANGE</h2>
<p>Both parties exchange ephemeral public keys.</p>
<p>Initiator sends:</p>
<pre>
EXCHANGE payload:
  cookie-r "|" cookie-i "|" ephemeral-public-hex
</pre>
<p>- cookie-r: Echo of responder's cookie (proves receipt) - cookie-i: Initiator's random cookie (for key derivation) - ephemeral-public: X25519 public key</p>
<p>Responder verifies cookie echo, then responds with same format.</p>
<p>State now committed. Keys derived.</p>
<h3>Key Derivation</h3>
<pre class="language-scheme">
(define (derive-session-keys shared-secret cookie-i cookie-r)
  (let* ((ikm (blob-append shared-secret
                           (string-&gt;blob cookie-i)
                           (string-&gt;blob cookie-r)))
         (prk (blake2b-hash ikm))
         (k-ir (blake2b-hash (blob-append prk "initiator-&gt;responder")))
         (k-ri (blake2b-hash (blob-append prk "responder-&gt;initiator"))))
    (values (take k-ir 32) (take k-ri 32))))
</pre>
<p>Directional keys prevent reflection attacks.</p>
</section>
<section>
<h2>Phase 4: ATTEST</h2>
<p>All subsequent messages encrypted.</p>
<p>Both parties prove identity using SPKI principals.</p>
<pre>
ATTEST payload (encrypted):
  principal-hash "|" signature
</pre>
<p>- principal-hash: SPKI principal (hex-encoded public key hash) - signature: Ed25519 signature over transcript</p>
<p>Identity is cryptographic, not nominal. A principal is identified solely by its public key hash, never by a human-readable name. This is a prime directive.</p>
<p>Transcript for signing:</p>
<pre>
cookie-i || cookie-r || ephemeral-public
</pre>
<h3>Anonymous Attestation (Optional)</h3>
<p>For privacy, use Chaum-style blind signatures:</p>
<pre class="language-scheme">
(define (blind-attest capability-hash)
  ;; Prove authorization without revealing identity
  (blind-sign capability-hash (blind-factor)))
</pre>
</section>
<section>
<h2>Phase 5: OFFER</h2>
<p>Exchange authorized capabilities as SPKI tags.</p>
<pre>
OFFER payload (encrypted):
  (tag ( set capability ...))

Example: "(tag ( set read write replicate))"
</pre>
<p>Capabilities follow RFC-021 (Capability Delegation): - Only offer what you hold - Attenuation only, no amplification - Explicit, not ambient - Expressed as SPKI tag s-expressions</p>
<p>Future: Full SPKI auth-certs with issuer signatures.</p>
</section>
<section>
<h2>Phase 6: CONFIRM</h2>
<p>Bind entire transcript.</p>
<pre>
CONFIRM payload (encrypted):
  BLAKE2b(cookie-i || cookie-r || their-principal)
</pre>
<p>Both parties must produce matching hashes. Any tampering detected.</p>
</section>
<section>
<h2>DATA Phase</h2>
<p>Channel open. Encrypted messaging.</p>
<pre>
DATA payload:
  ChaCha20-Poly1305(key, nonce, plaintext)
</pre>
<p>Nonce construction:</p>
<pre>
nonce = sequence-number (8 bytes) || 0x00000000 (4 bytes)
</pre>
<p>Sequence numbers: - Start at 0 - Increment per message - Prevent replay - Separate counters per direction</p>
</section>
<section>
<h2>Algorithm Suites</h2>
<p>No runtime negotiation. Version determines suite.</p>
<h3>CCP/1.x (Current)</h3>
<table>
<tr><th>Function </th><th>Algorithm </th></tr>
<tr><td>Key Exchange </td><td>X25519 </td></tr>
<tr><td>Signatures </td><td>Ed25519 </td></tr>
<tr><td>AEAD </td><td>ChaCha20-Poly1305 </td></tr>
<tr><td>Hash </td><td>BLAKE2b </td></tr>
<tr><td>KDF </td><td>HKDF-BLAKE2b </td></tr>
</table>
<h3>CCP/2.x (Reserved: Post-Quantum)</h3>
<table>
<tr><th>Function </th><th>Algorithm </th></tr>
<tr><td>Key Exchange </td><td>Kyber-1024 </td></tr>
<tr><td>Signatures </td><td>Dilithium3 </td></tr>
<tr><td>AEAD </td><td>ChaCha20-Poly1305 </td></tr>
<tr><td>Hash </td><td>BLAKE2b </td></tr>
</table>
<h3>CCP/3.x (Reserved: Hybrid)</h3>
<table>
<tr><th>Function </th><th>Algorithm </th></tr>
<tr><td>Key Exchange </td><td>X25519 + Kyber </td></tr>
<tr><td>Signatures </td><td>Ed25519 + Dilithium </td></tr>
</table>
</section>
<section>
<h2>Security Properties</h2>
<h3>DoS Resistance</h3>
<table>
<tr><th>Attack </th><th>Defense </th></tr>
<tr><td>SYN flood </td><td>Cookie proves return path </td></tr>
<tr><td>Amplification </td><td>No response until cookie echo </td></tr>
<tr><td>State exhaustion </td><td>No state until Phase 3 </td></tr>
</table>
<h3>Forward Secrecy</h3>
<p>Ephemeral X25519 keys: - Generated per session - Destroyed after key derivation - Compromise of long-term key doesn't expose past sessions</p>
<h3>Identity Protection (SPKI Native)</h3>
<p>Principal identity: - Is the public key hash (not a name, not a certificate) - Only revealed after encryption established - Only revealed to authenticated peer - Never in plaintext on wire - Self-certifying: principal = hash(public_key)</p>
<h3>Replay Protection</h3>
<ul>
<li>Sequence numbers per direction</li>
<li>Nonce never reused (fatal if violated)</li>
<li>AEAD authentication fails on replay</li>
</ul>
</section>
<section>
<h2>Comparison</h2>
<table>
<tr><th>Property </th><th>TLS 1.3 </th><th>IKEv2 </th><th>CCP </th></tr>
<tr><td>Messages to establish </td><td>2-3 </td><td>4+ </td><td>10 </td></tr>
<tr><td>DoS resistance </td><td>Limited </td><td>Cookies </td><td>Cookies </td></tr>
<tr><td>Algorithm negotiation </td><td>Yes </td><td>Yes </td><td>No </td></tr>
<tr><td>Certificate required </td><td>Yes </td><td>Yes </td><td>No </td></tr>
<tr><td>Identity protection </td><td>Partial </td><td>Yes </td><td>Yes </td></tr>
<tr><td>Capability binding </td><td>No </td><td>No </td><td>Yes </td></tr>
</table>
<p>CCP trades fewer round-trips for simplicity and capability integration.</p>
</section>
<section>
<h2>Implementation</h2>
<pre class="language-scheme">
;; Initiator
(define ch (node-connect "remote.host" 4433))
(channel-send ch '(request object-hash))
(channel-recv ch)

;; Responder
(node-listen 4433 "my-node")
(define ch (node-accept))
(let ((msg (channel-recv ch)))
  (channel-send ch (process msg)))
</pre>
</section>
<section>
<h2>References</h2>
<p>1. Karn, P. &amp; Simpson, W. (1999). PHOTURIS. RFC 2522. 2. Karn, P. &amp; Simpson, W. (1999). PHOTURIS Extended Schemes. RFC 2523. 3. Bernstein, D.J. (2006). Curve25519. 4. Bernstein, D.J. (2008). ChaCha20. 5. RFC-021: Capability Delegation 6. RFC-040: Security Architecture</p>
</section>
<section>
<h2>Changelog</h2>
<p>- 2026-01-07: Initial specification</p>
</section>
<script>
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
}
(function() {
  const saved = localStorage.getItem('theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
  } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script>
</body>
</html>
