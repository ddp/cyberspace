RFC-055: Compilation and Debugging Manual


------------------------------------------------------------------------

------------------------------------------------------------------------
ABSTRACT
------------------------------------------------------------------------

This RFC is the compilation and debugging manual for Cyberspace Scheme.
It specifies type inference conventions, build system architecture,
debugging infrastructure, exception handling, and inspector design. The
guiding principles are Ada's "declare everything, infer nothing" and
Dylan's "inspect everything, hide nothing."


------------------------------------------------------------------------
PART I: COMPILATION
------------------------------------------------------------------------



------------------------------------------------------------------------
1. TYPE SYSTEM OVERVIEW
------------------------------------------------------------------------


1.1 Chicken's Scrutinizer
-------------------------

Chicken Scheme includes a flow-sensitive type analyzer called the
scrutinizer. When invoked with -strict-types, it performs whole-program
type inference and reports errors when types cannot be proven safe.

The scrutinizer tracks type information through:

  * Variable bindings and assignments
  * Conditional branches (if, cond, case)
  * Procedure calls and returns
  * Special forms (let, let*, letrec)


1.2 The Inference Problem
-------------------------

Whole-program type inference without declarations can exhibit
exponential complexity. The scrutinizer's flow-sensitive analysis
becomes intractable when:

  * Functions contain many conditional branches with side effects
  * Format strings (sprintf) create implicit polymorphic constraints
  * Type information cannot flow through set! mutations
  * Multiple paths merge with incompatible inferred types

Empirical observation: A function with 30 conditional sprintf calls can
take 5+ minutes to analyze. The same function with type declarations
compiles in under 1 second.


1.3 The Ada Principle
---------------------

Ada's compilation model requires explicit type declarations everywhere.
The compiler is a checker, not a guesser. Jean Ichbiah's design traded
verbosity for predictability - when Ada compiles, it tends to run
correctly.

For Cyberspace modules, we adopt this principle:


    DECLARE EVERYTHING, INFER NOTHING

Benefits:

  * Predictable compilation times
  * Better error messages (mismatch against declaration, not inference)
  * Documentation of programmer intent
  * Enables separate compilation


------------------------------------------------------------------------
2. TYPE DECLARATION CONVENTIONS
------------------------------------------------------------------------


2.1 Required Import
-------------------

Modules using type declarations must import the type system:


    (import (chicken type))

Place this import with other chicken imports, before srfi and cyberspace
modules.


2.2 Declaration Placement
-------------------------

Type declarations are placed in a dedicated section after imports,
before any function definitions:


    (module example
      (export1 export2)
      (import scheme
              (chicken base)
              (chicken type)
              ...)
      ;;; ============================================================
      ;;; Type Declarations
      ;;; ============================================================
      (: export1 (string -> boolean))
      (: export2 (fixnum fixnum -> fixnum))
      (: internal-helper (list -> (or string false)))
      ;;; ============================================================
      ;;; Implementation
      ;;; ============================================================
      (define (export1 s) ...)
      ...)


2.3 Declaration Syntax
----------------------

The (: name type) form declares the type of a binding:


    ;; Simple function types
    (: add1 (fixnum -> fixnum))
    (: string-empty? (string -> boolean))
    ;; Multiple arguments
    (: substring (string fixnum fixnum -> string))
    ;; Optional arguments
    (: open-file (string #!optional symbol -> port))
    ;; Rest arguments
    (: format (string #!rest * -> string))
    ;; Union types
    (: find-item (symbol -> (or item false)))
    ;; Procedures as arguments
    (: map-items ((item -> result) (list-of item) -> (list-of result)))
    ;; No return (exits or loops forever)
    (: fatal-error (string -> noreturn))


2.4 Common Type Names
---------------------


  Type           Description          Example Values         
  fixnum         Small exact integer  0, 42, -17             
  flonum         Floating point       3.14, -2.5e10          
  number         Any number           fixnum or flonum       
  string         Character string     "hello"                
  symbol         Symbolic atom        'foo, 'bar             
  boolean        Truth value          #t, #f                 
  char           Single character     #\a, #\newline         
  list           Proper list          '(1 2 3)               
  (list-of T)    Homogeneous list     (list-of string)       
  pair           Cons cell            '(a . b)               
  vector         Fixed-size array     #(1 2 3)               
  blob           Byte vector          (make-blob 16)         
  port           I/O port             (current-input-port)   
  procedure      Any procedure        car, +                 
  (T1 -> T2)     Specific procedure   (string -> fixnum)     
  (or T1 T2)     Union type           (or string false)      
  (struct name)  C struct wrapper     (struct tcp-listener)  
  false          The #f value         #f                     
  *              Any type             anything               
  noreturn       Never returns        for exit, error        


2.5 When Declarations Are Required
----------------------------------

Type declarations are REQUIRED for:

  * Functions with more than 5 conditional branches
  * Functions using set! on local variables
  * Functions with multiple sprintf/format calls
  * All exported (public API) functions
  * Functions that call other modules' exported functions

Type declarations are OPTIONAL for:

  * Simple leaf functions (< 5 lines, no branching)
  * Local helper functions with obvious types
  * Functions used only in one place


------------------------------------------------------------------------
3. TYPED HELPER PATTERN
------------------------------------------------------------------------


3.1 The Problem
---------------

A common pattern causes exponential inference:


    ;; BAD: Exponential type inference
    (define (session-summary)
      (let ((stats '()))
        (when (> (session-stat 'reads) 0)
          (set! stats (cons (sprintf "~a read~a"
                                      (session-stat 'reads)
                                      (if (= 1 (session-stat 'reads)) "" "s"))
                            stats)))
        (when (> (session-stat 'writes) 0)
          (set! stats (cons (sprintf "~a write~a" ...) stats)))
        ;; ... 28 more similar blocks ...
        (reverse stats)))

The scrutinizer must analyze all 2^30 possible paths through this
function.


3.2 The Solution
----------------

Factor into small typed helpers:


    ;; GOOD: Linear type inference
    (: format-stat (symbol string string -> (or string false)))
    (define (format-stat key singular plural-suffix)
      "Format a session stat with pluralization, or #f if zero."
      (let ((n (session-stat key)))
        (if (> n 0)
            (string-append (number->string n) " " singular
                           (if (= n 1) "" plural-suffix))
            #f)))
    (: format-stat-irregular (symbol string string -> (or string false)))
    (define (format-stat-irregular key singular plural)
      "Format with irregular plural."
      (let ((n (session-stat key)))
        (if (> n 0)
            (string-append (number->string n) " "
                           (if (= n 1) singular plural))
            #f)))
    (: session-summary (-> (list-of string)))
    (define (session-summary)
      "Generate session statistics summary."
      (filter identity
        (list
          (format-stat 'reads "read" "s")
          (format-stat 'writes "write" "s")
          (format-stat-irregular 'queries "query" "queries")
          ...)))

Each helper is independently typed. The scrutinizer analyzes them
separately, giving O(n) instead of O(2^n) complexity.


3.3 Composition via filter
--------------------------

The pattern (filter identity (list ...)) collects non-#f results:


    (filter identity (list "a" #f "b" #f "c"))
    ;; => ("a" "b" "c")

This replaces imperative set!/cons accumulation with functional
composition.


------------------------------------------------------------------------
4. BUILD SYSTEM ARCHITECTURE
------------------------------------------------------------------------


4.1 The Forge
-------------

The forge is the build system for Cyberspace modules. It compiles Scheme
to shared libraries (.so) with import specifications (.import.scm).

The name is deliberate. Not CompilationManager or BuildSystem - forge.
Words a squirrel would use. The same MIT hackers who gave us LISP,
Scheme, and the λ-calculus named things to mean something: lambda,
cons, car, cdr. We continue that tradition: forge, vault, portal,
gossip, bloom, keyring.

Invocation:


    (bootstrap-modules!)  ; Called automatically at REPL start

Output format:


    +---------------- forge: portal ----------------+
    | csc -shared -J -strict-types portal.scm       |
    | ✓ 241K + 677B import in 921ms                 |
    |   296 LOC · 42 λ · 7 LOC/λ                    |
    +-----------------------------------------------+

The SICP metrics line shows:

  * LOC: Lines of code (excluding blanks and comments)
  * λ: Procedure definitions (define + lambda forms)
  * LOC/λ: Average lines per procedure (smaller = more compositional)

The fundamental unit is not the line - it's the λ. This is the heritage
of computer science invented at MIT by smart squirrel/hackers:
McCarthy's LISP, Sussman and Steele's Scheme, the AI Lab, Building 20.
They saw computation as pure thought, λ as the primitive, parentheses
as liberation not burden.

Measuring λ-density is measuring compositional discipline. A module
with 6 LOC/λ has crystallized more thought per line than one with 10.
The ratio tells you how SICP-minded the code is.

Metrics are stored in .forge/<module>.meta as s-expressions:


    ((module . "vault")
     (timestamp . 1768359548)
     (so-size . 951016)
     (import-size . 3258)
     (compile-time-ms . 12686)
     (metrics (loc . 2793) (lambdas . 260) (imports . 1) (loc/lambda . 10)))

The forge knows how λ-dense your code is. Each compilation records:
timestamp (Unix epoch), artifact sizes, build time, and the metrics that
matter - lines of code, lambda count, λ-density ratio.

Queryable via:


    (forged "portal")     ; Single module metrics
    (forged-all)          ; Bitfarm harvest: all modules
    (sicp)                ; Live analysis (no forge metadata needed)

Standalone script for shell usage:


    $ ./sicp              # From spki/scheme directory
    $ lscs                # Shell alias (defined in .zshrc)

Compositional threshold:


    LOC/λ < 10  (enforced)

Modules exceeding 10 LOC/λ trigger a warning during forge and are
flagged in sicp output. This enforces SICP-style compositional
discipline: small procedures composed to build complex behavior.

Current totals (v0.61):


    Σ 8502 LOC · 920 λ · 9 LOC/λ ✓


4.2 Compiler Invocation
-----------------------

The forge invokes csc (Chicken Scheme Compiler) with these flags:


  Flag           Purpose                                  
  -shared        Produce shared library (.so)             
  -J             Generate import library (.import.scm)    
  -strict-types  Enable scrutinizer type checking (beta)  
  -I path        Add include path (for FFI)               
  -L path        Add library path (for FFI)               
  -l lib         Link library (e.g., -lsodium)            

Example invocations:


    # Standard module
    csc -shared -J -strict-types portal.scm
    # FFI module with libsodium
    csc -shared -J -strict-types crypto-ffi.scm \
        -I/opt/homebrew/include -L/opt/homebrew/lib -lsodium


4.3 Dependency Levels
---------------------

Modules are organized into dependency levels. Modules within a level
have no mutual dependencies and compile in parallel.


    ;; Level 0: Foundation (no cyberspace dependencies)
    ("os" "crypto-ffi" "sexp" "capability")
    ;; Level 1: Core utilities (depend on Level 0 only)
    ("mdns" "fips" "audit" "wordlist" "bloom"
     "catalog" "keyring" "portal")
    ;; Level 2: Certificates and enrollment (depend on Levels 0-1)
    ("cert" "enroll")
    ;; Level 3: Protocols (depend on Levels 0-2)
    ("gossip" "security")
    ;; Level 4: High-level operations (depend on Levels 0-3)
    ("vault" "auto-enroll")
    ;; Level 5: User interface (depend on all prior)
    ("ui")

To determine a module's level, examine its imports:

  * If it imports only chicken/srfi modules: Level 0
  * If it imports Level 0 modules: Level 1
  * If it imports Level N modules: Level N+1 or higher


4.4 Parallel Compilation
------------------------

Each level compiles in parallel using process-fork:


    (define (rebuild-level-parallel! modules)
      (let ((pids (map (lambda (module)
                         (process-fork
                           (lambda ()
                             (rebuild-module! module)
                             (exit 0))))
                       modules)))
        (for-each process-wait pids)
        (length modules)))

The build blocks until all processes in a level complete before starting
the next level. This ensures dependencies are satisfied.


4.5 Architecture Neutrality
---------------------------

The weave must be universal. Only content-addressed,
architecture-neutral artifacts flow through the weave: s-expressions,
signatures, proofs. Binary artifacts (.so, .o, the REPL executable) are
local materializations - ephemeral as the hardware they run on.

Machine code is gibberish outside the local realm. Could be ARM64, could
be x86_64, could be a JPEG of a cat. The weave cannot inspect it, cannot
verify it, cannot reason about it. Only the s-expression source has
universal meaning - it parses the same on lambda as on fluffy as on
whatever Linux box joins the realm next.

Consequently, compiled artifacts are excluded from version control and
replication:


    # .gitignore
    spki/scheme/cyberspace-repl
    spki/scheme/*.so
    spki/scheme/*.o
    spki/scheme/*.import.scm
    spki/scheme/.*.arch

Each node compiles its own. Lambda is portable. Machine code is not.


4.6 Rebuild Detection
---------------------

A module needs rebuilding when any of these conditions hold:

  * The .so file does not exist
  * The .import.scm file does not exist
  * The source .scm is newer than the .so (mtime comparison)
  * The platform stamp doesn't match (e.g., Darwin-arm64 vs Linux-x86_64)


    (define (needs-rebuild? module)
      (or (not (file-exists? (string-append module ".so")))
          (not (file-exists? (string-append module ".import.scm")))
          (> (file-mtime (string-append module ".scm"))
             (file-mtime (string-append module ".so")))
          (not (string=? (read-arch-stamp module) (current-arch)))))


------------------------------------------------------------------------
5. BETA VS PRODUCTION BUILDS
------------------------------------------------------------------------


5.1 Build Mode Flag
-------------------

The *beta-build* flag controls strict type checking:


    ;; In cyberspace-repl.scm
    (define *beta-build* #t)  ; Enable for development
    (define *beta-build* #f)  ; Disable for release


5.2 Beta Mode Benefits
----------------------

With *beta-build* = #t:

  * All modules compile with -strict-types
  * Type mismatches are compile-time errors
  * Invalid arguments are detected
  * Deprecated identifiers are flagged
  * Format string errors are caught

Build time impact: ~20-25 seconds for full rebuild


5.3 Production Mode
-------------------

With *beta-build* = #f:

  * Modules compile without -strict-types
  * Type declarations remain as documentation
  * Faster compilation
  * Smaller binaries (no type metadata)

Build time impact: ~10-15 seconds for full rebuild


5.4 When to Use Each Mode
-------------------------


  Scenario             Mode        Rationale                 
  Active development   Beta        Catch type errors early   
  CI/CD pipeline       Beta        Prevent type regressions  
  Release builds       Production  Optimize for users        
  Debugging issues     Beta        Better error context      
  Performance testing  Production  Measure real performance  


------------------------------------------------------------------------
PART II: DEBUGGING
------------------------------------------------------------------------



------------------------------------------------------------------------
6. EXCEPTION HANDLING
------------------------------------------------------------------------


6.1 Condition System
--------------------

Chicken uses the SRFI-12 condition system. Exceptions are condition
objects with properties:


    (handle-exceptions exn
      ;; Handler: exn is the condition object
      (print "Error: " (get-condition-property exn 'exn 'message))
      ;; Protected code
      (dangerous-operation))


6.2 Standard Condition Properties
---------------------------------


  Property          Type    Description                     
  'exn 'message     string  Human-readable error message    
  'exn 'location    symbol  Procedure where error occurred  
  'exn 'arguments   list    Arguments that caused error     
  'exn 'call-chain  list    Stack trace                     


    (define (safe-operation x)
      (handle-exceptions exn
        (let ((msg (get-condition-property exn 'exn 'message "unknown"))
              (loc (get-condition-property exn 'exn 'location #f))
              (chain (get-condition-property exn 'exn 'call-chain '())))
          (printf "Error in ~a: ~a~n" loc msg)
          (print-call-chain chain)
          #f)
        (actual-operation x)))


6.3 Rich Exception Display
--------------------------

The REPL provides rich exception display with box formatting:


    +-------------- Exception ---------------+
    | division by zero                       |
    | Location: quotient                     |
    | Arguments: (42 0)                      |
    +-----------------------------------------+
    | Call Chain:                            |
    |   divide-values                        |
    |   process-input                        |
    |   main-loop                            |
    +-----------------------------------------+

Implementation uses the centralized box-drawing API from os.scm.


------------------------------------------------------------------------
7. TRACING AND PROFILING
------------------------------------------------------------------------


7.1 Procedure Tracing
---------------------

Trace procedure calls and returns:


    ;; Enable tracing
    (trace foo)
    (trace bar baz)
    ;; Disable tracing
    (untrace foo)
    (untrace)  ; untrace all

Trace output:


    (foo 1 2 3)
      |(bar 1)
      | (baz 2)
      | baz -> 4
      |bar -> 5
    foo -> 8


7.2 REPL Trace Commands
-----------------------

CSI provides trace commands:


    ,trace proc     ; trace procedure
    ,trace         ; show traced procedures
    ,untrace proc  ; stop tracing
    ,untrace       ; stop all tracing


7.3 Call Chain
--------------

Get the current call chain at any point:


    (define (debug-here)
      (print-call-chain (get-call-chain)))
    ;; Or after an error in the REPL:
    ,n              ; show call chain
    ,c              ; continue
    ,d              ; describe exception


7.4 Time Profiling
------------------

Measure execution time:


    (time (expensive-operation))
    ;; => 0.142s CPU, 0.145s real, 12345 bytes allocated

For more detailed profiling, compile with -profile and use
chicken-profile.


------------------------------------------------------------------------
8. INSPECTOR DESIGN
------------------------------------------------------------------------

Inspired by Dylan's inspector - the gold standard for interactive
debugging.


8.1 Design Principles
---------------------

The Dylan inspector philosophy:

  * INSPECT EVERYTHING: Any object can be inspected
  * HIDE NOTHING: Internal structure is visible
  * NAVIGATE FREELY: Drill down into any component
  * MODIFY CAREFULLY: Live patching with safety checks
  * HISTORY MATTERS: Navigation history, bookmarks


8.2 Inspector Commands (Planned)
--------------------------------


  Command      Action                     
  :i obj       Inspect object             
  :s           Show current object        
  :d N         Descend into slot N        
  :u           Up to parent object        
  :h           Show inspection history    
  :b           Bookmark current object    
  :m slot val  Modify slot value          
  :t           Show object type info      
  :r           Show references to object  


8.3 Object Display Format
-------------------------


    +---------- Inspecting: pair -------------+
    | Type: pair                             |
    | Address: 0x7fff5fbff8a0                |
    +-----------------------------------------+
    | [0] car: symbol 'foo                   |
    | [1] cdr: pair (...)                    |
    +-----------------------------------------+
    | :d 0  - inspect car                    |
    | :d 1  - inspect cdr                    |
    | :u    - go back                        |
    +-----------------------------------------+


8.4 Type-Specific Inspectors
----------------------------

Specialized display for common types:

  * Procedures: arity, source location, closure variables
  * Ports: direction, filename, position
  * Blobs: hex dump, ASCII preview
  * Hash tables: key count, load factor, entries
  * SPKI certs: issuer, subject, validity, delegation
  * Audit entries: timestamp, actor, operation


------------------------------------------------------------------------
9. REPL DEBUGGING COMMANDS
------------------------------------------------------------------------


9.1 Built-in Commands
---------------------


  Command    Description                  
  ,?         Show help                    
  ,l file    Load file                    
  ,r         Show recent expressions      
  ,s         Show current module          
  ,m module  Enter module                 
  ,n         Show call chain after error  
  ,d         Describe last exception      
  ,c         Continue after break         
  ,q         Quit REPL                    
  ,t proc    Trace procedure              
  ,u proc    Untrace procedure            


9.2 Cyberspace Extensions
-------------------------


  Command       Description                
  :rebuild      Force rebuild all modules  
  :status       Show session statistics    
  :soup         Enter soup browser         
  :inspect obj  Inspect object (planned)   
  :audit        Show recent audit entries  
  :keys         Show loaded keys           


9.3 Error Recovery
------------------

After an error, the REPL captures context:


    > (/ 1 0)
    +-------------- Exception ---------------+
    | division by zero                       |
    +-----------------------------------------+
    > ,n
    Call chain:
      (/ 1 0)
      <toplevel>
    > ,d
    Condition: exn
      message: "division by zero"
      location: /
      arguments: (1 0)


------------------------------------------------------------------------
10. COMPILER WARNINGS REFERENCE
------------------------------------------------------------------------


10.1 Type Warnings
------------------


    Warning: Invalid argument
      Argument #1 to procedure `tcp-accept' has an invalid type:
        false
      The expected type is:
        (struct tcp-listener)

Fix: Add type check or adjust control flow to ensure correct type.


10.2 Deprecation Warnings
-------------------------


    Warning: Deprecated identifier `current-milliseconds'
      Use of deprecated identifier from module `chicken.time'.

Fix: Use current-process-milliseconds instead.


10.3 Format String Warnings
---------------------------


    Warning: `printf', in format string "~.2f",
      illegal format-string character `.'

Fix: Chicken format doesn't support precision specifiers. Use manual
rounding.


10.4 Redefinition Warnings
--------------------------


    Warning: redefinition of imported value binding: blob=?

Fix: Either don't redefine, or explicitly shadow with (only (chicken
blob) (not blob=?))


10.5 Warning Policy
-------------------

For production code:

  * Zero warnings is the goal
  * All warnings should be investigated
  * Known acceptable warnings should be documented
  * CI should fail on new warnings


------------------------------------------------------------------------
11. PERFORMANCE TUNING
------------------------------------------------------------------------


11.1 Compilation Performance
----------------------------


  Module Size           Without -strict-types  With -strict-types  
  < 500 LOC             ~500ms                 ~700ms              
  500-2000 LOC          ~1s                    ~2s                 
  > 2000 LOC (typed)    ~2s                    ~7s                 
  > 2000 LOC (untyped)  ~2s                    exponential         

Full bootstrap (21 modules): ~20-25s with strict types


11.2 Runtime Performance
------------------------

Type declarations have no runtime cost - they're only used at compile
time.

For runtime optimization:

  * Use fixnum operations for integer math (fx+, fx<, etc.)
  * Use flonum operations for float math (fp+, fp<, etc.)
  * Avoid unnecessary string allocation
  * Prefer vectors over lists for random access
  * Use hash tables for lookup-heavy operations


11.3 Memory Profiling
---------------------

Track allocations:


    (gc #t)  ; Force GC and print statistics
    (memory-statistics)  ; Show current memory use

For detailed profiling, compile with -profile flag.


------------------------------------------------------------------------
12. MODULE CONVENTIONS
------------------------------------------------------------------------


12.1 File Structure
-------------------


    ;;; module.scm - One line description
    ;;;
    ;;; Longer description of purpose, heritage, references.
    ;;;
    ;;; Copyright (c) 2026 Author. See LICENSE.
    (module module-name
      (;; Exports grouped by category
       export1
       export2
       ;; Internal (for testing/debugging)
       internal-helper)
      (import scheme
              (chicken base)
              (chicken type)
              ...)
      ;;; ============================================================
      ;;; Type Declarations
      ;;; ============================================================
      (: export1 ...)
      (: export2 ...)
      ;;; ============================================================
      ;;; Section Name
      ;;; ============================================================
      (define (export1 ...) ...)
    ) ; end module


12.2 Naming Conventions
-----------------------


  Type        Convention    Example                           
  Procedure   verb-noun     read-file, parse-cert             
  Predicate   noun?         empty?, valid-cert?               
  Conversion  x->y          string->blob, cert->sexp          
  Mutator     verb!         set-value!, init!                 
  Constant    *name*        *default-port*, *max-retries*     
  Parameter   current-name  current-realm, current-principal  


12.3 Documentation Strings
--------------------------

All exported procedures should have docstrings:


    (define (read-file path)
      "Read entire file contents as string.
       Returns #f if file doesn't exist."
      ...)


------------------------------------------------------------------------
13. TESTING CONVENTIONS
------------------------------------------------------------------------


13.1 Test File Location
-----------------------

Tests live alongside source:


    module.scm       ; Source
    module-test.scm  ; Tests


13.2 Test Structure
-------------------


    (import module)
    (import test)  ; SRFI-64 or similar
    (test-begin "module")
    (test-group "feature-name"
      (test-equal "description" expected (actual))
      (test-assert "predicate" (condition?)))
    (test-end "module")


13.3 Running Tests
------------------


    csi -s module-test.scm


------------------------------------------------------------------------
14. REFERENCES
------------------------------------------------------------------------

  * Chicken Scheme User's Manual: Types
  * Chicken Scheme User's Manual: Debugging
  * SRFI-12: Exception Handling
  * Ada Reference Manual: Type System
  * Dylan Reference Manual: Inspector
  * RFC-054 Terminal Interface Conventions

------------------------------------------------------------------------
