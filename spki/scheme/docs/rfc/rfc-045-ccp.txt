RFC-045: Cookie-Capability Protocol (CCP)

**Status:** Implemented
**Date:** January 2026
**Author:** Library of Cyberspace Contributors
**Inspiration:** PHOTURIS (Karn/Simpson, RFC 2522)
**Implementation:** cyberspace-repl

---

Abstract

CCP establishes secure channels between Cyberspace nodes using stateless cookies for DoS resistance, ephemeral key exchange for forward secrecy, and capability attestation for authorization. No X.509. No CA hierarchy. No algorithm negotiation.

---

Motivation

TLS is complex:
- Certificate chains require PKI
- Algorithm negotiation invites downgrade attacks
- State allocated before client proven real
- Identity exposed before encryption

PHOTURIS (1995) had better ideas:
- Cookies before crypto
- Identity under encryption
- Simple state machine

CCP resurrects these ideas with modern primitives.

---

Protocol Overview

```
Initiator                          Responder
    |                                   |
    |-------- KNOCK (version) -------->|  Stateless
    |<-------- COOKIE -----------------|  Stateless
    |                                   |
    |-------- EXCHANGE (eph key) ----->|  State committed
    |<------- EXCHANGE (eph key) ------|
    |                                   |
    |========= encrypted below ========|
    |                                   |
    |-------- ATTEST (identity) ------>|
    |<------- ATTEST (identity) -------|
    |                                   |
    |-------- OFFER (capabilities) --->|
    |<------- OFFER (capabilities) ----|
    |                                   |
    |-------- CONFIRM (transcript) --->|
    |<------- CONFIRM (transcript) ----|
    |                                   |
    |========= CHANNEL OPEN ===========|
    |                                   |
    |<----------- DATA -------------->|
```

10 messages to establish. Unlimited encrypted DATA after.

---

Message Format

All messages use TLV encoding:

```
+------+--------+------------------+
| Type | Length | Payload          |
| 1B   | 4B BE  | variable         |
+------+--------+------------------+
```

Message Types

| Type | Name | Direction |
|------|------|-----------|
| 0x01 | KNOCK | I → R |
| 0x02 | COOKIE | R → I |
| 0x03 | EXCHANGE | bidirectional |
| 0x04 | ATTEST | bidirectional |
| 0x05 | OFFER | bidirectional |
| 0x06 | CONFIRM | bidirectional |
| 0x10 | DATA | bidirectional |
| 0xFF | CLOSE | bidirectional |

---

Phase 1: KNOCK

Initiator announces intent and protocol version.

```
KNOCK payload:
  "CCP/" VERSION_MAJOR "." VERSION_MINOR

Example: "CCP/1.0"
```

Responder checks version compatibility:
- Major mismatch: reject (incompatible suites)
- Minor mismatch: accept (backward compatible)

**Responder allocates no state.**

---

Phase 2: COOKIE

Responder returns stateless cookie.

```scheme
(define (make-cookie remote-addr remote-port)
  (let* ((data (string-append
                (blob->string *cookie-secret*)
                remote-addr
                (number->string remote-port)
                (number->string *cookie-epoch*)))
         (hash (blake2b-hash (string->blob data))))
    (substring hash 0 16)))
```

Cookie properties:
- **Stateless**: Responder doesn't store it
- **Unforgeable**: Requires server secret
- **Expiring**: Epoch rotation invalidates old cookies
- **Address-bound**: Different address = different cookie

**Responder still allocates no state.**

---

Phase 3: EXCHANGE

Both parties exchange ephemeral public keys.

Initiator sends:
```
EXCHANGE payload:
  cookie-r "|" cookie-i "|" ephemeral-public-hex
```

- `cookie-r`: Echo of responder's cookie (proves receipt)
- `cookie-i`: Initiator's random cookie (for key derivation)
- `ephemeral-public`: X25519 public key

Responder verifies cookie echo, then responds with same format.

**State now committed. Keys derived.**

Key Derivation

```scheme
(define (derive-session-keys shared-secret cookie-i cookie-r)
  (let* ((ikm (blob-append shared-secret
                           (string->blob cookie-i)
                           (string->blob cookie-r)))
         (prk (blake2b-hash ikm))
         (k-ir (blake2b-hash (blob-append prk "initiator->responder")))
         (k-ri (blake2b-hash (blob-append prk "responder->initiator"))))
    (values (take k-ir 32) (take k-ri 32))))
```

Directional keys prevent reflection attacks.

---

Phase 4: ATTEST

**All subsequent messages encrypted.**

Both parties prove identity using SPKI principals.

```
ATTEST payload (encrypted):
  principal-hash "|" signature
```

- `principal-hash`: SPKI principal (hex-encoded public key hash)
- `signature`: Ed25519 signature over transcript

**Identity is cryptographic, not nominal.** A principal is identified solely by its public key hash, never by a human-readable name. This is a prime directive.

Transcript for signing:
```
cookie-i || cookie-r || ephemeral-public
```

Anonymous Attestation (Optional)

For privacy, use Chaum-style blind signatures:

```scheme
(define (blind-attest capability-hash)
  ;; Prove authorization without revealing identity
  (blind-sign capability-hash (blind-factor)))
```

---

Phase 5: OFFER

Exchange authorized capabilities as SPKI tags.

```
OFFER payload (encrypted):
  (tag (* set capability ...))

Example: "(tag (* set read write replicate))"
```

Capabilities follow RFC-021 (Capability Delegation):
- Only offer what you hold
- Attenuation only, no amplification
- Explicit, not ambient
- **Expressed as SPKI tag s-expressions**

Future: Full SPKI auth-certs with issuer signatures.

---

Phase 6: CONFIRM

Bind entire transcript.

```
CONFIRM payload (encrypted):
  BLAKE2b(cookie-i || cookie-r || their-principal)
```

Both parties must produce matching hashes. Any tampering detected.

---

DATA Phase

Channel open. Encrypted messaging.

```
DATA payload:
  ChaCha20-Poly1305(key, nonce, plaintext)
```

Nonce construction:
```
nonce = sequence-number (8 bytes) || 0x00000000 (4 bytes)
```

Sequence numbers:
- Start at 0
- Increment per message
- Prevent replay
- Separate counters per direction

---

Algorithm Suites

**No runtime negotiation.** Version determines suite.

CCP/1.x (Current)

| Function | Algorithm |
|----------|-----------|
| Key Exchange | X25519 |
| Signatures | Ed25519 |
| AEAD | ChaCha20-Poly1305 |
| Hash | BLAKE2b |
| KDF | HKDF-BLAKE2b |

CCP/2.x (Reserved: Post-Quantum)

| Function | Algorithm |
|----------|-----------|
| Key Exchange | Kyber-1024 |
| Signatures | Dilithium3 |
| AEAD | ChaCha20-Poly1305 |
| Hash | BLAKE2b |

CCP/3.x (Reserved: Hybrid)

| Function | Algorithm |
|----------|-----------|
| Key Exchange | X25519 + Kyber |
| Signatures | Ed25519 + Dilithium |

---

Security Properties

DoS Resistance

| Attack | Defense |
|--------|---------|
| SYN flood | Cookie proves return path |
| Amplification | No response until cookie echo |
| State exhaustion | No state until Phase 3 |

Forward Secrecy

Ephemeral X25519 keys:
- Generated per session
- Destroyed after key derivation
- Compromise of long-term key doesn't expose past sessions

Identity Protection (SPKI Native)

Principal identity:
- **Is the public key hash** (not a name, not a certificate)
- Only revealed after encryption established
- Only revealed to authenticated peer
- Never in plaintext on wire
- Self-certifying: principal = hash(public_key)

Replay Protection

- Sequence numbers per direction
- Nonce never reused (fatal if violated)
- AEAD authentication fails on replay

---

Comparison

| Property | TLS 1.3 | IKEv2 | CCP |
|----------|---------|-------|-----|
| Messages to establish | 2-3 | 4+ | 10 |
| DoS resistance | Limited | Cookies | Cookies |
| Algorithm negotiation | Yes | Yes | No |
| Certificate required | Yes | Yes | No |
| Identity protection | Partial | Yes | Yes |
| Capability binding | No | No | Yes |

CCP trades fewer round-trips for simplicity and capability integration.

---

Implementation

```scheme
;; Initiator
(define ch (node-connect "remote.host" 4433))
(channel-send ch '(request object-hash))
(channel-recv ch)

;; Responder
(node-listen 4433 "my-node")
(define ch (node-accept))
(let ((msg (channel-recv ch)))
  (channel-send ch (process msg)))
```

---

References

1. Karn, P. & Simpson, W. (1999). PHOTURIS. RFC 2522.
2. Karn, P. & Simpson, W. (1999). PHOTURIS Extended Schemes. RFC 2523.
3. Bernstein, D.J. (2006). Curve25519.
4. Bernstein, D.J. (2008). ChaCha20.
5. RFC-021: Capability Delegation
6. RFC-040: Security Architecture

---

Changelog

- **2026-01-07**: Initial specification

---

**Implementation Status:** Complete (placeholder crypto)
**Test Status:** Passing (two-node handshake + messaging)
**Next:** Real libsodium AEAD bindings
