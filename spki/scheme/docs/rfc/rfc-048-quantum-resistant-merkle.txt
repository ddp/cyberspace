RFC-048: Quantum-Resistant Merkle Trees


------------------------------------------------------------------------------

------------------------------------------------------------------------------
ABSTRACT
------------------------------------------------------------------------------

SHA-512 won't survive. Grover's algorithm halves the effective security - 256
bits becomes 128. For the wilderness of mirrors to endure the quantum winter,
we need quantum-resistant Merkle trees. This RFC specifies the transition from
flat SHA-512 hashes to tree-structured SHAKE256 hashes.


------------------------------------------------------------------------------
THE PROBLEM
------------------------------------------------------------------------------

Current cyberspace object identity:


    sha512(content) â†’ 64 bytes â†’ object address

Against a quantum computer with Grover's algorithm: - Classical security: 256
bits - Quantum security: 128 bits (square root)

128 bits may be acceptable for some threat models, but cyberspace is built to
last. The Library of Alexandria burned once. We won't let quantum computers
burn it again.


------------------------------------------------------------------------------
THE SOLUTION: MERKLE TREES
------------------------------------------------------------------------------

Instead of hashing content as a flat blob, structure it as a tree:


                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚   Merkle Root   â”‚  â† Object identity
                        â”‚  shake256(...)  â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚              â”‚              â”‚
             â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
             â”‚ Node 0  â”‚    â”‚ Node 1  â”‚    â”‚ Node 2  â”‚
             â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
                  â”‚              â”‚              â”‚
            â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
            â”‚           â”‚  â”‚           â”‚  â”‚           â”‚
        â”Œâ”€â”€â”€â–¼â”€â”€â”€â” â”Œâ”€â”€â”€â–¼â”€â”€â”€â” â”Œâ”€â”€â”€â–¼â”€â”€â”€â” â”Œâ”€â”€â”€â–¼â”€â”€â”€â” â”Œâ”€â”€â”€â–¼â”€â”€â”€â” ...
        â”‚Chunk 0â”‚ â”‚Chunk 1â”‚ â”‚Chunk 2â”‚ â”‚Chunk 3â”‚ â”‚Chunk 4â”‚
        â”‚ 4 KB  â”‚ â”‚ 4 KB  â”‚ â”‚ 4 KB  â”‚ â”‚ 4 KB  â”‚ â”‚ 4 KB  â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”˜

Benefits:

1. Incremental updates - Change one chunk, rehash one branch 2. Selective
disclosure - Prove a chunk exists without revealing siblings 3. Streaming
verification - Verify chunks as they arrive 4. Parallelizable - Hash chunks
concurrently 5. Quantum-resistant - SHAKE256 at every node


------------------------------------------------------------------------------
HASH FUNCTION: SHAKE256
------------------------------------------------------------------------------

SHAKE256 is an extendable-output function (XOF) from the SHA-3 (Keccak)
family.

Why SHAKE256:


  Property            Value               
  Security level      256-bit classical, 1
  Output length       Variable (we use 256
  Construction        Sponge (different fr
  Standard            NIST FIPS 202       
  Used by             SPHINCS+ (post-quant
  In libsodium        No, but in OpenSSL, 

Alternative: BLAKE3


  Property            Value               
  Security level      256-bit classical, 1
  Output length       Variable            
  Construction        Merkle tree internal
  Speed               Very fast, SIMD opti
  Standard            Not NIST, but widely

BLAKE3 is faster and already tree-structured, but SHAKE256 has NIST blessing.
We support both.


------------------------------------------------------------------------------
OBJECT FORMAT
------------------------------------------------------------------------------


Current (Legacy)
----------------


    (object
      (hash "sha512:3a7bd3e2c4f8...")
      (size 1048576)
      (content ...))


Quantum-Resistant
-----------------


    (object
      (merkle-root "shake256:7f4a2b9c...")
      (hash-algorithm "shake256")          ; or "blake3"
      (tree-params
        (chunk-size 4096)                  ; 4 KB chunks
        (fanout 16)                        ; Children per node
        (depth 4))                         ; Tree depth
      (size 1048576)
      (content ...))


Transition Period (Dual Hash)
-----------------------------


    (object
      (hash "sha512:3a7bd3e2c4f8...")           ; Legacy - for old clients
      (merkle-root "shake256:7f4a2b9c...")      ; Quantum-resistant
      (hash-algorithm "shake256")
      (tree-params
        (chunk-size 4096)
        (fanout 16)
        (depth 4))
      (size 1048576)
      (content ...))

Old clients use hash. New clients use merkle-root. Both verify the same
content.


------------------------------------------------------------------------------
TREE CONSTRUCTION
------------------------------------------------------------------------------


Algorithm
---------


    (define (merkle-hash content algorithm chunk-size fanout)
      "Build Merkle tree, return root hash"
      ;; 1. Split content into chunks
      (let* ((chunks (chunk-content content chunk-size))
             ;; 2. Hash each chunk (leaves)
             (leaves (map (lambda (chunk)
                            (hash algorithm chunk))
                          chunks))
             ;; 3. Build tree bottom-up
             (root (build-tree leaves fanout algorithm)))
        root))
    (define (build-tree nodes fanout algorithm)
      "Combine nodes into parent nodes until one root remains"
      (if (<= (length nodes) 1)
          (car nodes)
          (let ((parents (map (lambda (group)
                                (hash algorithm (apply append group)))
                              (partition nodes fanout))))
            (build-tree parents fanout algorithm))))


Node Hashing
------------

Each internal node hashes the concatenation of its children:


    nodehash = shake256(child0 || child1 || ... || childn)

For leaves:


    leafhash = shake256(chunkdata)


Canonical Parameters
--------------------


  Parameter           Default             Notes               
  chunk-size          4096                4 KB, filesystem-fri
  fanout              16                  Balance between dept
  algorithm           shake256            NIST approved       
  output-length       32                  256 bits            


------------------------------------------------------------------------------
PROOFS
------------------------------------------------------------------------------


Inclusion Proof
---------------

Prove a chunk is part of an object without revealing other chunks:


    (inclusion-proof
      (merkle-root "shake256:7f4a2b9c...")
      (chunk-index 42)
      (chunk-hash "shake256:abc123...")
      (path
        ((sibling "shake256:def456..." position left)
         (sibling "shake256:789abc..." position right)
         (sibling "shake256:012def..." position left))))

Verifier reconstructs path to root:


    chunk_hash â†’ combine with sibling â†’ ... â†’ must equal merkle-root


Exclusion Proof
---------------

Prove a chunk does NOT exist (for sparse objects):


    (exclusion-proof
      (merkle-root "shake256:7f4a2b9c...")
      (chunk-index 999)
      (boundary-left 998 "shake256:left...")
      (boundary-right 1000 "shake256:right...")
      (path ...))


------------------------------------------------------------------------------
STREAMING VERIFICATION
------------------------------------------------------------------------------

Large objects can be verified chunk-by-chunk as they stream:


    (define (verify-stream merkle-root chunk-size)
      "Return a verifier that checks chunks as they arrive"
      (let ((received-chunks '())
            (verified-nodes (make-hash-table)))
        (lambda (chunk-index chunk-data proof)
          ;; Verify this chunk against the proof
          (let ((chunk-hash (shake256 chunk-data)))
            (if (verify-inclusion-proof merkle-root chunk-index chunk-hash proof)
                (begin
                  (cache-verified-node! verified-nodes chunk-index chunk-hash)
                  #t)
                #f)))))

You don't need the whole object to start verifying. Each chunk carries its own
proof.


------------------------------------------------------------------------------
THE FOREST
------------------------------------------------------------------------------

The soup becomes a forest of Merkle trees:


    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                    THE FOREST (formerly soup)                    â”‚
    â”‚                                                                  â”‚
    â”‚     ğŸŒ² obj    ğŸŒ² obj       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      ğŸŒ² obj       â”‚
    â”‚          ğŸŒ² obj           â”‚â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â”‚           ğŸŒ² obj  â”‚
    â”‚    ğŸŒ² obj          ğŸŒ² obj â”‚â–‘â–‘â–‘  REALM  â–‘â–‘â–‘â–‘â–‘â”‚    ğŸŒ² obj         â”‚
    â”‚         ğŸŒ² obj            â”‚â–‘â–‘â–‘ (island) â–‘â–‘â–‘â–‘â”‚         ğŸŒ² obj    â”‚
    â”‚   ğŸŒ² obj       ğŸŒ² obj     â”‚â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â”‚  ğŸŒ² obj           â”‚
    â”‚        ğŸŒ² obj             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       ğŸŒ² obj      â”‚
    â”‚                                                                  â”‚
    â”‚   Each object a tree. Each tree quantum-hardened.               â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Objects are trees. The wilderness of mirrors becomes a forest. Agents navigate
between trees, climbing branches, verifying paths. The capability chain is
still their thread - but now the mirrors are structured.


------------------------------------------------------------------------------
MIGRATION
------------------------------------------------------------------------------


Phase 1: Dual Hash (Now â†’ Q-Day - 5 years)
--------------------------------------------

All new objects get both hashes. Old objects rehashed on access.


    (define (store-object content)
      (let ((legacy-hash (sha512 content))
            (merkle-root (merkle-hash content 'shake256 4096 16)))
        (vault-store
          `(object
            (hash ,(string-append "sha512:" legacy-hash))
            (merkle-root ,(string-append "shake256:" merkle-root))
            ...))))


Phase 2: Merkle Primary (Q-Day - 5 years â†’ Q-Day)
---------------------------------------------------

Merkle root becomes the canonical address. SHA-512 kept for compatibility.


Phase 3: Legacy Sunset (Q-Day â†’ Q-Day + 2 years)
--------------------------------------------------

SHA-512 hashes deprecated. Only Merkle roots used for addressing.


Phase 4: Pure Quantum-Resistant (Q-Day + 2 years â†’)
-----------------------------------------------------

SHA-512 hashes removed from new objects. Legacy objects retain both for
historical verification.


------------------------------------------------------------------------------
PERFORMANCE
------------------------------------------------------------------------------


  Operation           SHA-512 (flat)      SHAKE256 (Merkle)   Notes               
  Hash 1 MB           2 ms                3 ms                Slightly slower     
  Hash 1 GB           2000 ms             2500 ms             Tree overhead       
  Update 4 KB in 1 GB 2000 ms             15 ms               Merkle wins         
  Prove inclusion     N/A                 0.1 ms              New capability      
  Streaming verify    N/A                 Per-chunk           New capability      

The overhead is small. The benefits are large.


------------------------------------------------------------------------------
SECURITY CONSIDERATIONS
------------------------------------------------------------------------------


Grover's Algorithm
------------------

Grover's algorithm provides quadratic speedup for searching: - SHA-512: 2^256
â†’ 2^128 quantum operations - SHAKE256-256: 2^256 â†’ 2^128 quantum
operations

128-bit quantum security is considered sufficient for the foreseeable future.


Second Preimage Resistance
--------------------------

Finding another input that hashes to the same tree requires: - Classical:
2^256 operations - Quantum: 2^128 operations (Grover)


Tree Structure Attacks
----------------------

The Merkle tree structure must prevent: - Length extension: SHAKE256 immune
(sponge construction) - Subtree collision: Domain separation in node hashing -
Malleability: Canonical serialization required


Implementation
--------------


    ;; Domain separation for nodes vs leaves
    (define (hash-leaf algorithm chunk)
      (hash algorithm (bytevector-append #u8(0) chunk)))
    (define (hash-node algorithm children)
      (hash algorithm (bytevector-append #u8(1) (apply bytevector-append children))))

The 0x00 prefix for leaves and 0x01 for nodes prevents a leaf from being
interpreted as a node.


------------------------------------------------------------------------------
INVARIANTS
------------------------------------------------------------------------------


    M1. Object identity is Merkle root
        id(o) = merkle-root(shake256, chunks(o))
    M2. Any chunk is provable
        chunk(o,i) â†’ âˆƒproof: verify(root(o), i, chunk, proof)
    M3. Tree structure is canonical
        tree(content, params) is deterministic
    M4. Dual hashes are consistent
        sha512(content) â†” merkle-root(content) verify same content
    M5. Migration preserves identity
        old-objects retain verifiable legacy hashes


------------------------------------------------------------------------------
REFERENCES
------------------------------------------------------------------------------

1. NIST FIPS 202 - SHA-3 Standard (SHAKE256) 2. BLAKE3 specification -
https://github.com/BLAKE3-team/BLAKE3 3. Merkle, R., "A Digital Signature
Based on a Conventional Encryption Function", 1987 4. Grover, L., "A Fast
Quantum Mechanical Algorithm for Database Search", 1996 5. RFC-040 -
Cyberspace Security Architecture


------------------------------------------------------------------------------
CHANGELOG
------------------------------------------------------------------------------

  * 2026-01-08
  * Initial draft

------------------------------------------------------------------------------
