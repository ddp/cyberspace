<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RFC-036: Quorum Protocol with Homomorphic Voting</title>
  <link rel="stylesheet" href="rfc.css">
</head>
<body>
<h1>RFC-036: Quorum Protocol with Homomorphic Voting</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This RFC specifies the quorum protocol for the Library of Cyberspace: how principals reach collective decisions through homomorphic encryption-based voting, enabling private ballot tallying without revealing individual votes. Quorum integrates with threshold governance (RFC-007) and Byzantine consensus (RFC-011).</p>
</section>
<section>
<h2>Motivation</h2>
<p>Collective decisions require:</p>
<p>- Privacy - Voters shouldn't know how others voted - Verifiability - Results must be provably correct - Coercion resistance - Can't prove how you voted to others - Availability - Voting continues despite failures</p>
<p>Traditional approaches fail:</p>
<p>- Open ballot - No privacy, enables coercion - Trusted tallier - Single point of compromise - Secure multi-party computation - Complex, high communication overhead</p>
<p>Homomorphic encryption provides:</p>
<p>- Vote on encrypted ballots - Sum without decryption - Decrypt only the final tally - Mathematical proof of correctness</p>
</section>
<section>
<h2>Cryptographic Foundation</h2>
<h3>Homomorphic Encryption Schemes</h3>
<table>
<tr><th>Scheme </th><th>Operations </th><th>Performance </th><th>Use Case </th></tr>
<tr><td>Paillier </td><td>Addition </td><td>Fast </td><td>Vote tallying </td></tr>
<tr><td>BFV/BGV </td><td>Add + Multiply </td><td>Medium </td><td>Complex predicates </td></tr>
<tr><td>TFHE </td><td>Arbitrary </td><td>Slow </td><td>General computation </td></tr>
</table>
<p>For quorum voting, Paillier suffices - we only need addition.</p>
<h3>Paillier Properties</h3>
<pre class="language-scheme">
;; Additive homomorphism
(= (decrypt (he-add (encrypt a) (encrypt b)))
   (+ a b))

;; Scalar multiplication via repeated addition
(= (decrypt (he-scalar-mult (encrypt a) k))
   (* a k))

;; Semantic security - ciphertexts indistinguishable
(not (distinguishable? (encrypt 0) (encrypt 1)))
</pre>
<h3>Key Generation</h3>
<pre class="language-scheme">
(define-record-type &lt;quorum-keys&gt;
  (make-quorum-keys public private threshold shares)
  quorum-keys?
  (public qk-public)           ; Public encryption key
  (private qk-private)         ; Private decryption key (or #f if distributed)
  (threshold qk-threshold)     ; M-of-N threshold
  (shares qk-shares))          ; Distributed key shares

(define (generate-quorum-keys bit-length threshold trustees)
  "Generate threshold Paillier keys"
  (let* ((keys (paillier-keygen bit-length))
         (shares (shamir-split (paillier-private keys)
                               threshold
                               (length trustees))))
    (make-quorum-keys
      (paillier-public keys)
      #f  ; No single party holds private key
      threshold
      (map cons trustees shares))))
</pre>
</section>
<section>
<h2>Ballot Structure</h2>
<h3>Ballot Definition</h3>
<pre class="language-scheme">
(define-record-type &lt;ballot&gt;
  (make-ballot id question options threshold deadline)
  ballot?
  (id ballot-id)                 ; Content hash
  (question ballot-question)     ; Human-readable question
  (options ballot-options)       ; List of choices
  (threshold ballot-threshold)   ; Votes needed to pass
  (deadline ballot-deadline))    ; Voting closes

;; Example ballot
(make-ballot
  id: "sha256:ballot..."
  question: "Accept RFC-042 into standard?"
  options: '(accept reject abstain)
  threshold: '(majority members)  ; &gt;50% of members
  deadline: 1767786000)
</pre>
<h3>Encrypted Vote</h3>
<pre class="language-scheme">
(define-record-type &lt;encrypted-vote&gt;
  (make-encrypted-vote ballot-id voter ciphertext proof timestamp signature)
  encrypted-vote?
  (ballot-id vote-ballot-id)     ; Which ballot
  (voter vote-voter)             ; Voter's public key (or anonymous token)
  (ciphertext vote-ciphertext)   ; HE-encrypted choice
  (proof vote-proof)             ; Zero-knowledge proof of validity
  (timestamp vote-timestamp)
  (signature vote-signature))
</pre>
<h3>Vote Encoding</h3>
<pre class="language-scheme">
;; One-hot encoding for multiple choices
;; accept=1, reject=0, abstain=0 â†’ (1, 0, 0)

(define (encode-vote choice options)
  "Encode choice as one-hot vector"
  (map (lambda (opt)
         (if (eq? opt choice) 1 0))
       options))

(define (encrypt-vote choice options public-key)
  "Encrypt one-hot encoded vote"
  (map (lambda (v)
         (paillier-encrypt public-key v))
       (encode-vote choice options)))

;; Vote for "accept"
(encrypt-vote 'accept '(accept reject abstain) pub-key)
;; =&gt; (Enc(1), Enc(0), Enc(0))
</pre>
</section>
<section>
<h2>Voting Protocol</h2>
<h3>Phase 1: Ballot Creation</h3>
<pre class="language-scheme">
(define (create-ballot question options threshold deadline trustees)
  "Create new ballot with threshold decryption"
  (let* ((keys (generate-quorum-keys 2048
                                     (ceiling (/ (length trustees) 2))
                                     trustees))
         (ballot (make-ballot
                   question: question
                   options: options
                   threshold: threshold
                   deadline: deadline)))
    ;; Distribute key shares to trustees
    (for-each (lambda (trustee share)
                (secure-send trustee
                  `(key-share
                    (ballot-id ,(ballot-id ballot))
                    (share ,share))))
              trustees
              (qk-shares keys))
    ;; Publish ballot
    (soup-put ballot type: 'ballot)
    (audit-append action: 'ballot-created
                  ballot: (ballot-id ballot))
    ballot))
</pre>
<h3>Phase 2: Vote Casting</h3>
<pre class="language-scheme">
(define (cast-vote ballot choice voter-key)
  "Cast encrypted vote with validity proof"
  (let* ((pub-key (ballot-public-key ballot))
         (encrypted (encrypt-vote choice (ballot-options ballot) pub-key))
         (proof (generate-validity-proof encrypted choice pub-key))
         (vote (make-encrypted-vote
                 ballot-id: (ballot-id ballot)
                 voter: (key-&gt;principal voter-key)
                 ciphertext: encrypted
                 proof: proof
                 timestamp: (current-time))))
    ;; Sign the vote
    (set-encrypted-vote-signature! vote
      (sign-vote voter-key vote))
    ;; Submit
    (submit-vote vote)
    vote))

(define (submit-vote vote)
  "Submit vote to ballot coordinator"
  ;; Verify eligibility
  (unless (eligible-voter? (vote-voter vote) (vote-ballot-id vote))
    (error 'not-eligible))
  ;; Verify validity proof
  (unless (verify-validity-proof vote)
    (error 'invalid-vote-proof))
  ;; Verify not already voted
  (when (already-voted? (vote-voter vote) (vote-ballot-id vote))
    (error 'already-voted))
  ;; Record vote
  (soup-put vote type: 'encrypted-vote)
  (audit-append action: 'vote-cast
                ballot: (vote-ballot-id vote)
                voter: (vote-voter vote)))
</pre>
<h3>Phase 3: Homomorphic Tallying</h3>
<pre class="language-scheme">
(define (tally-votes ballot)
  "Homomorphically sum all votes"
  (let* ((votes (soup-query type: 'encrypted-vote
                            ballot-id: (ballot-id ballot)))
         (num-options (length (ballot-options ballot)))
         (zero-tally (make-list num-options (paillier-encrypt-zero))))
    ;; Sum encrypted votes
    (fold (lambda (vote tally)
            (map paillier-add
                 (vote-ciphertext vote)
                 tally))
          zero-tally
          votes)))

;; After tallying 100 votes:
;; (Enc(47), Enc(41), Enc(12))
;; Still encrypted - no one knows the result yet
</pre>
<h3>Phase 4: Threshold Decryption</h3>
<pre class="language-scheme">
(define (decrypt-tally ballot encrypted-tally)
  "Threshold decrypt the tally"
  (let* ((trustees (ballot-trustees ballot))
         (threshold (ballot-key-threshold ballot))
         (shares '()))
    ;; Collect decryption shares
    (for-each (lambda (trustee)
                (let ((share (request-decryption-share trustee
                               (ballot-id ballot)
                               encrypted-tally)))
                  (when share
                    (set! shares (cons share shares)))))
              trustees)
    ;; Need threshold shares
    (unless (&gt;= (length shares) threshold)
      (error 'insufficient-decryption-shares))
    ;; Combine shares to decrypt
    (let ((plaintext-tally
           (map (lambda (ct)
                  (threshold-decrypt ct shares))
                encrypted-tally)))
      ;; Publish result
      (publish-result ballot plaintext-tally)
      plaintext-tally)))

(define (request-decryption-share trustee ballot-id encrypted-tally)
  "Request trustee's decryption share"
  (let ((response (tunnel trustee
                    `(decryption-share-request
                      (ballot-id ,ballot-id)
                      (tally ,encrypted-tally)))))
    (and (valid-share? response)
         response)))
</pre>
<h3>Phase 5: Result Publication</h3>
<pre class="language-scheme">
(define (publish-result ballot tally)
  "Publish verified result"
  (let* ((options (ballot-options ballot))
         (result (map cons options tally))
         (winner (determine-winner result (ballot-threshold ballot))))
    (soup-put
      `(ballot-result
        (ballot-id ,(ballot-id ballot))
        (tally ,result)
        (winner ,winner)
        (timestamp ,(current-time))
        (total-votes ,(apply + tally)))
      type: 'ballot-result)
    (audit-append action: 'ballot-result
                  ballot: (ballot-id ballot)
                  result: result
                  winner: winner)))
</pre>
</section>
<section>
<h2>Zero-Knowledge Proofs</h2>
<h3>Vote Validity Proof</h3>
<p>Prove vote is valid (exactly one 1, rest 0s) without revealing which:</p>
<pre class="language-scheme">
(define (generate-validity-proof encrypted-vote choice public-key)
  "ZK proof that vote encodes valid choice"
  ;; Disjunctive proof: prove one of N possibilities
  ;; Without revealing which
  (let ((n (length encrypted-vote)))
    (make-or-proof
      (map (lambda (i)
             (if (= i (choice-index choice))
                 ;; Real proof for actual choice
                 (make-encryption-proof (list-ref encrypted-vote i) 1 public-key)
                 ;; Simulated proof for other choices
                 (simulate-encryption-proof (list-ref encrypted-vote i) 1 public-key)))
           (iota n)))))

(define (verify-validity-proof vote)
  "Verify vote validity without learning choice"
  (let ((proof (vote-proof vote))
        (ciphertext (vote-ciphertext vote))
        (pub-key (ballot-public-key (vote-ballot-id vote))))
    ;; Verify OR proof
    (and (verify-or-proof proof ciphertext pub-key)
         ;; Verify sum of encrypted values equals Enc(1)
         (verify-sum-equals-one ciphertext pub-key))))
</pre>
<h3>Decryption Share Proof</h3>
<p>Prove decryption share is correct:</p>
<pre class="language-scheme">
(define (generate-share-proof share ciphertext trustee-key)
  "ZK proof that decryption share is correct"
  (make-dlog-proof
    (share-value share)
    trustee-key
    ciphertext))

(define (verify-share-proof share ciphertext trustee-pubkey)
  "Verify decryption share correctness"
  (verify-dlog-proof
    (share-proof share)
    (share-value share)
    trustee-pubkey
    ciphertext))
</pre>
</section>
<section>
<h2>Voter Privacy</h2>
<h3>Anonymous Voting Tokens</h3>
<pre class="language-scheme">
(define (issue-voting-token voter-key ballot-id issuer-key)
  "Issue blind voting token"
  ;; Voter blinds their key
  (let* ((blinding-factor (random-scalar))
         (blinded-key (blind-key voter-key blinding-factor)))
    ;; Issuer signs blinded key
    (let ((blind-signature (sign issuer-key blinded-key)))
      ;; Voter unblinds signature
      (let ((token (unblind-signature blind-signature blinding-factor)))
        ;; Token proves eligibility without linking to voter
        (make-voting-token
          ballot-id: ballot-id
          token: token
          ;; Cannot be linked to voter-key
          )))))

(define (vote-anonymously ballot choice token)
  "Cast vote using anonymous token"
  (let ((vote (cast-vote ballot choice token)))
    ;; Vote linked to token, not voter identity
    vote))
</pre>
<h3>Receipt-Freeness</h3>
<p>Voters cannot prove how they voted (prevents vote buying/coercion):</p>
<pre class="language-scheme">
;; Re-encryption mixnet for receipt-freeness
(define (submit-through-mixnet vote mixnet-nodes)
  "Submit vote through re-encryption mixnet"
  (fold (lambda (node encrypted-vote)
          ;; Each node re-encrypts
          (let ((re-encrypted (paillier-rerandomize encrypted-vote)))
            ;; Shuffle with other votes
            (mixnet-shuffle node re-encrypted)))
        vote
        mixnet-nodes))
</pre>
</section>
<section>
<h2>Quorum Types</h2>
<h3>Simple Majority</h3>
<pre class="language-scheme">
(define (simple-majority tally total-eligible)
  "More than half of voters"
  (let ((total-votes (apply + tally))
        (winning-votes (apply max tally)))
    (&gt; winning-votes (/ total-votes 2))))
</pre>
<h3>Supermajority</h3>
<pre class="language-scheme">
(define (supermajority tally fraction)
  "Require fraction (e.g., 2/3) agreement"
  (let ((total-votes (apply + tally))
        (winning-votes (apply max tally)))
    (&gt;= winning-votes (* fraction total-votes))))
</pre>
<h3>Threshold of Eligible</h3>
<pre class="language-scheme">
(define (threshold-of-eligible tally total-eligible threshold)
  "Require threshold of all eligible voters"
  (let ((winning-votes (apply max tally)))
    (&gt;= winning-votes (* threshold total-eligible))))
</pre>
<h3>Weighted Voting</h3>
<pre class="language-scheme">
(define (weighted-vote voter-key weight choice ballot)
  "Cast vote with weight"
  ;; Encode weight in vote
  (let ((encoded (map (lambda (v) (* v weight))
                      (encode-vote choice (ballot-options ballot)))))
    (encrypt-vote-vector encoded (ballot-public-key ballot))))
</pre>
</section>
<section>
<h2>Integration with Governance</h2>
<h3>RFC-007 Threshold Governance</h3>
<pre class="language-scheme">
;; Quorum voting for threshold operations
(define (threshold-operation-vote operation trustees)
  "Vote on threshold operation"
  (let ((ballot (create-ballot
                  question: (format "Approve ~a?" operation)
                  options: '(approve reject)
                  threshold: '(supermajority 2/3)
                  deadline: (+ (current-time) 86400)
                  trustees: trustees)))
    ;; Wait for voting
    (await-ballot-result ballot)))
</pre>
<h3>RFC-011 Byzantine Consensus</h3>
<pre class="language-scheme">
;; Use quorum voting within Byzantine protocol
(define (byzantine-propose-vote proposal validators)
  "Propose via encrypted voting"
  (let ((ballot (create-ballot
                  question: proposal
                  options: '(commit abort)
                  threshold: '(byzantine-quorum (length validators))
                  trustees: validators)))
    ballot))

(define (byzantine-quorum n)
  "2f+1 for n=3f+1 validators"
  (+ (* 2 (floor (/ (- n 1) 3))) 1))
</pre>
<h3>Key Ceremony Voting</h3>
<pre class="language-scheme">
;; Vote to approve key ceremony
(define (key-ceremony-approval ceremony guardians)
  "Guardians vote to approve ceremony"
  (let ((ballot (create-ballot
                  question: (format "Approve key ceremony ~a?" (ceremony-id ceremony))
                  options: '(approve reject)
                  threshold: '(unanimous)
                  deadline: (+ (current-time) 3600)
                  trustees: guardians)))
    (let ((result (await-ballot-result ballot)))
      (if (eq? (result-winner result) 'approve)
          (proceed-ceremony ceremony)
          (abort-ceremony ceremony)))))
</pre>
</section>
<section>
<h2>Security Considerations</h2>
<h3>Cryptographic Assumptions</h3>
<table>
<tr><th>Assumption </th><th>Primitive </th><th>Consequence if Broken </th></tr>
<tr><td>Decisional Composite Residuosity </td><td>Paillier </td><td>Vote privacy lost </td></tr>
<tr><td>Discrete Log </td><td>ZK proofs </td><td>Validity unverifiable </td></tr>
<tr><td>Random Oracle </td><td>Hash functions </td><td>Proof forgery </td></tr>
</table>
<h3>Attack Mitigations</h3>
<table>
<tr><th>Attack </th><th>Mitigation </th></tr>
<tr><td>Vote buying </td><td>Receipt-freeness via re-encryption </td></tr>
<tr><td>Coercion </td><td>Deniable voting tokens </td></tr>
<tr><td>Ballot stuffing </td><td>Eligibility proofs, audit trail </td></tr>
<tr><td>Tally manipulation </td><td>Threshold decryption, ZK proofs </td></tr>
<tr><td>Denial of service </td><td>Rate limiting, deadlines </td></tr>
</table>
<h3>Audit Trail</h3>
<pre class="language-scheme">
;; All voting actions audited
(audit-append action: 'ballot-created ...)
(audit-append action: 'vote-cast ...)      ; Voter ID, not choice
(audit-append action: 'tally-computed ...)
(audit-append action: 'share-provided ...)
(audit-append action: 'result-published ...)
</pre>
</section>
<section>
<h2>Performance Considerations</h2>
<h3>Paillier Costs</h3>
<table>
<tr><th>Operation </th><th>Time (2048-bit) </th></tr>
<tr><td>Key generation </td><td>~100ms </td></tr>
<tr><td>Encrypt </td><td>~5ms </td></tr>
<tr><td>Homomorphic add </td><td>~0.1ms </td></tr>
<tr><td>Decrypt </td><td>~5ms </td></tr>
<tr><td>Threshold decrypt </td><td>~10ms per share </td></tr>
</table>
<h3>Scalability</h3>
<pre class="language-scheme">
;; For N voters, M options:
;; - Encryption: O(N  M) operations
;; - Tallying: O(N  M) additions (fast)
;; - Decryption: O(M * threshold) operations

;; 10,000 voters, 3 options, 5 trustees:
;; ~50,000 encryptions (parallel)
;; ~30,000 additions (&lt;1 second)
;; ~15 decryptions (~150ms)
</pre>
</section>
<section>
<h2>Implementation Notes</h2>
<h3>Dependencies</h3>
<p>- paillier - Paillier cryptosystem - shamir - Secret sharing for threshold keys - zkp - Zero-knowledge proof primitives - srfi-27 - Random number generation</p>
<h3>Libraries</h3>
<p>Recommended implementations: - OpenFHE (C++) - Full HE library - python-paillier - Reference implementation - threshold-paillier - Distributed key generation</p>
</section>
<section>
<h2>References</h2>
<p>1. Paillier, P. (1999). Public-Key Cryptosystems Based on Composite Degree Residuosity Classes 2. Benaloh, J. (1994). Dense Probabilistic Encryption 3. Cramer, R., Gennaro, R., Schoenmakers, B. (1997). A Secure and Optimally Efficient Multi-Authority Election Scheme 4. RFC-007: Threshold Signature Governance 5. RFC-011: Byzantine Consensus 6. RFC-022: Key Ceremony Protocol</p>
</section>
<section>
<h2>Changelog</h2>
<p>- 2026-01-07 - Initial draft</p>
</section>
</body>
</html>
