%!PS-Adobe-3.0
%%Title: rfc-013-tla-specification
%%Creator: Library of Cyberspace RFC Pipeline
%%Pages: (atend)
%%EndComments

/Courier findfont 10 scalefont setfont
/margin 72 def
/pagewidth 612 def
/pageheight 792 def
/leading 12 def
/topmargin pageheight margin sub def
/bottommargin margin def
/linewidth pagewidth margin 2 mul sub def
/ypos topmargin def
/pagenum 1 def

/newline {
  /ypos ypos leading sub def
  ypos bottommargin lt {
    showpage
    /pagenum pagenum 1 add def
    /ypos topmargin def
  } if
  margin ypos moveto
} def

margin topmargin moveto
(RFC-013: TLA+ Formal Specification) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
() show newline
(------------------------------------------------------------------------) show newline
(ABSTRACT) show newline
(------------------------------------------------------------------------) show newline
() show newline
(This RFC specifies the use of TLA+ \(Temporal Logic of Actions\) for) show newline
(formal specification and model checking of Cyberspace protocols,) show newline
(ensuring correctness before implementation.) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(MOTIVATION) show newline
(------------------------------------------------------------------------) show newline
() show newline
(Running code is necessary but not sufficient:) show newline
() show newline
(  * Tests check examples: Not all possible executions) show newline
(  * Reviews check logic: Not all interleavings) show newline
(  * Bugs hide in corners: Race conditions, edge cases) show newline
() show newline
(TLA+ provides:) show newline
() show newline
(1. Precise specification: Mathematical description of behavior 2. Model) show newline
(checking: Exhaustive state space exploration 3. Proof capability: Formal) show newline
(verification of properties 4. Design tool: Find bugs before writing code) show newline
() show newline
(From Lamport:) show newline
() show newline
() show newline
(    "If you're thinking without writing, you only think you're thinking.") show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(SPECIFICATION) show newline
(------------------------------------------------------------------------) show newline
() show newline
() show newline
(TLA+ Overview) show newline
(-------------) show newline
() show newline
(TLA+ describes systems as state machines:) show newline
() show newline
() show newline
(    VARIABLES state, messages, decisions) show newline
(    Init ==) show newline
(      /\\ state = [n \\in Nodes |-> "idle"]) show newline
(      /\\ messages = {}) show newline
(      /\\ decisions = {}) show newline
(    Next ==) show newline
(      \\/ Propose\(...\)) show newline
(      \\/ Prepare\(...\)) show newline
(      \\/ Commit\(...\)) show newline
(      \\/ Decide\(...\)) show newline
(    Spec == Init /\\ [][Next]_<<state, messages, decisions>>) show newline
() show newline
() show newline
(Safety Properties) show newline
(-----------------) show newline
() show newline
(Invariants that must always hold:) show newline
() show newline
() show newline
(    TypeOK ==) show newline
(      /\\ state \\in [Nodes -> {"idle", "prepared", "committed"}]) show newline
(      /\\ messages \\subseteq Message) show newline
(      /\\ decisions \\subseteq Value) show newline
(    Agreement ==) show newline
(      \\A n1, n2 \\in Nodes:) show newline
(        \(decisions[n1] # {} /\\ decisions[n2] # {}\) =>) show newline
(          decisions[n1] = decisions[n2]) show newline
() show newline
() show newline
(Liveness Properties) show newline
(-------------------) show newline
() show newline
(Temporal properties about progress:) show newline
() show newline
() show newline
(    Termination ==) show newline
(      <>\(\\A n \\in Nodes: decisions[n] # {}\)) show newline
(    EventualConsistency ==) show newline
(      []<>\(\\A n1, n2 \\in Nodes: state[n1] = state[n2]\)) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(CYBERSPACE PROTOCOL SPECIFICATIONS) show newline
(------------------------------------------------------------------------) show newline
() show newline
() show newline
(Threshold Signatures \(RFC-007\)) show newline
(------------------------------) show newline
() show newline
() show newline
(    --------------------------- MODULE ThresholdSig ---------------------------) show newline
(    EXTENDS Integers, FiniteSets) show newline
(    CONSTANTS Signers, Threshold, Script) show newline
(    VARIABLES signatures, verified) show newline
(    Init ==) show newline
(      /\\ signatures = {}) show newline
(      /\\ verified = FALSE) show newline
(    Sign\(s\) ==) show newline
(      /\\ s \\in Signers) show newline
(      /\\ s \\notin {sig.signer : sig \\in signatures}) show newline
(      /\\ signatures' = signatures \\union) show newline
(           {[signer |-> s, script |-> Script, valid |-> TRUE]}) show newline
(      /\\ verified' = verified) show newline
(    Verify ==) show newline
(      /\\ Cardinality\({sig \\in signatures : sig.valid}\) >= Threshold) show newline
(      /\\ verified' = TRUE) show newline
(      /\\ UNCHANGED signatures) show newline
(    Next ==) show newline
(      \\/ \\E s \\in Signers: Sign\(s\)) show newline
(      \\/ Verify) show newline
(    \\ Safety: Never verify with insufficient signatures) show newline
(    Safety ==) show newline
(      verified => Cardinality\({sig \\in signatures : sig.valid}\) >= Threshold) show newline
(    \\ Liveness: If enough sign, eventually verify) show newline
(    Liveness ==) show newline
(      \(Cardinality\(Signers\) >= Threshold\) => <>\(verified\)) show newline
(    =============================================================================) show newline
() show newline
() show newline
(Audit Trail \(RFC-003\)) show newline
(---------------------) show newline
() show newline
() show newline
(    --------------------------- MODULE AuditTrail ---------------------------) show newline
(    EXTENDS Integers, Sequences) show newline
(    CONSTANTS Actors, Actions) show newline
(    VARIABLES log, sequence) show newline
(    Init ==) show newline
(      /\\ log = <<>>) show newline
(      /\\ sequence = 0) show newline
(    Append\(actor, action\) ==) show newline
(      /\\ actor \\in Actors) show newline
(      /\\ action \\in Actions) show newline
(      /\\ sequence' = sequence + 1) show newline
(      /\\ log' = Append\(log, [) show newline
(           seq |-> sequence',) show newline
(           actor |-> actor,) show newline
(           action |-> action,) show newline
(           parent |-> IF sequence = 0 THEN "genesis" ELSE log[sequence].hash) show newline
(         ]\)) show newline
(    \\ Invariant: Chain integrity) show newline
(    ChainIntegrity ==) show newline
(      \\A i \\in 1..Len\(log\)-1:) show newline
(        log[i+1].parent = log[i].hash) show newline
(    \\ Invariant: Monotonic sequence) show newline
(    MonotonicSequence ==) show newline
(      \\A i \\in 1..Len\(log\)-1:) show newline
(        log[i+1].seq = log[i].seq + 1) show newline
(    =============================================================================) show newline
() show newline
() show newline
(Byzantine Consensus \(RFC-011\)) show newline
(-----------------------------) show newline
() show newline
() show newline
(    --------------------------- MODULE PBFT ---------------------------) show newline
(    EXTENDS Integers, FiniteSets) show newline
(    CONSTANTS Nodes, f, Values) show newline
(    ASSUME Cardinality\(Nodes\) >= 3f + 1) show newline
(    VARIABLES) show newline
(      view,) show newline
(      prepares,) show newline
(      commits,) show newline
(      decisions) show newline
(    Init ==) show newline
(      /\\ view = 0) show newline
(      /\\ prepares = [n \\in Nodes |-> {}]) show newline
(      /\\ commits = [n \\in Nodes |-> {}]) show newline
(      /\\ decisions = [n \\in Nodes |-> {}]) show newline
(    PrePrepare\(primary, v\) ==) show newline
(      /\\ primary = Leader\(view\)) show newline
(      /\\ v \\in Values) show newline
(      /\\ \\A n \\in Nodes:) show newline
(           prepares' = [prepares EXCEPT ![n] = @ \\union {[view |-> view, value |-> v]}]) show newline
(      /\\ UNCHANGED <<view, commits, decisions>>) show newline
(    Prepare\(n, v\) ==) show newline
(      /\\ [view |-> view, value |-> v] \\in prepares[n]) show newline
(      /\\ Cardinality\({m \\in Nodes : [view |-> view, value |-> v] \\in prepares[m]}\) >= 2f + 1) show newline
(      /\\ commits' = [commits EXCEPT ![n] = @ \\union {[view |-> view, value |-> v]}]) show newline
(      /\\ UNCHANGED <<view, prepares, decisions>>) show newline
(    Commit\(n, v\) ==) show newline
(      /\\ [view |-> view, value |-> v] \\in commits[n]) show newline
(      /\\ Cardinality\({m \\in Nodes : [view |-> view, value |-> v] \\in commits[m]}\) >= 2f + 1) show newline
(      /\\ decisions' = [decisions EXCEPT ![n] = {v}]) show newline
(      /\\ UNCHANGED <<view, prepares, commits>>) show newline
(    \\ Safety: Agreement) show newline
(    Agreement ==) show newline
(      \\A n1, n2 \\in Nodes:) show newline
(        \(decisions[n1] # {} /\\ decisions[n2] # {}\) =>) show newline
(          decisions[n1] = decisions[n2]) show newline
(    =============================================================================) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(MODEL CHECKING PROCESS) show newline
(------------------------------------------------------------------------) show newline
() show newline
() show newline
(1. Write Specification) show newline
(----------------------) show newline
() show newline
(Define state machine and properties.) show newline
() show newline
() show newline
(2. Configure Model) show newline
(------------------) show newline
() show newline
() show newline
(    CONSTANTS) show newline
(      Nodes = {n1, n2, n3, n4}) show newline
(      f = 1) show newline
(      Values = {v1, v2}) show newline
() show newline
() show newline
(3. Run TLC Model Checker) show newline
(------------------------) show newline
() show newline
() show newline
(    $ tlc PBFT.tla) show newline
(    TLC2 Version 2.18) show newline
(    ...) show newline
(    Model checking completed. No errors found.) show newline
(      States explored: 847293) show newline
(      Distinct states: 12847) show newline
() show newline
() show newline
(4. Analyze Counterexamples) show newline
(--------------------------) show newline
() show newline
(If property violated, TLC shows trace:) show newline
() show newline
() show newline
(    Error: Invariant Agreement is violated.) show newline
(    Trace:) show newline
(      State 1: <Initial>) show newline
(      State 2: PrePrepare\(n1, v1\)) show newline
(      State 3: Prepare\(n2, v1\)) show newline
(      ...) show newline
(      State 12: decisions = [n1 |-> {v1}, n2 |-> {v2}]  << VIOLATION) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(INTEGRATION WITH IMPLEMENTATION) show newline
(------------------------------------------------------------------------) show newline
() show newline
() show newline
(Specification → Implementation) show newline
(--------------------------------) show newline
() show newline
() show newline
(    TLA+ Spec          Scheme Implementation) show newline
(    -----------        ---------------------) show newline
(    VARIABLES state    \(define-record-type <state> ...\)) show newline
(    Init ==            \(define \(init\) ...\)) show newline
(    Action\(x\) ==       \(define \(action x\) ...\)) show newline
(    Invariant          \(assert \(invariant? state\)\)) show newline
() show newline
() show newline
(Runtime Assertions) show newline
(------------------) show newline
() show newline
() show newline
(    \(define \(append-audit! entry\)) show newline
(      ;; TLA+ invariant: MonotonicSequence) show newline
(      \(assert \(> \(entry-sequence entry\)) show newline
(                 \(entry-sequence \(last-entry\)\)\)\)) show newline
(      ;; TLA+ invariant: ChainIntegrity) show newline
(      \(assert \(equal? \(entry-parent entry\)) show newline
(                      \(entry-hash \(last-entry\)\)\)\)) show newline
(      ;; Proceed with append) show newline
(      ...\)) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(PLUSCAL \(ALGORITHMIC TLA+\)) show newline
(------------------------------------------------------------------------) show newline
() show newline
(Higher-level syntax that compiles to TLA+:) show newline
() show newline
() show newline
(    --algorithm ThresholdSign {) show newline
(      variables signatures = {}, verified = FALSE;) show newline
(      process \(signer \\in Signers\)) show newline
(      {) show newline
(        sign:) show newline
(          signatures := signatures \\union {self};) show newline
(      }) show newline
(      process \(verifier = "v"\)) show newline
(      {) show newline
(        verify:) show newline
(          await Cardinality\(signatures\) >= Threshold;) show newline
(          verified := TRUE;) show newline
(      }) show newline
(    }) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(BENEFITS) show newline
(------------------------------------------------------------------------) show newline
() show newline
() show newline
(  Aspect          Without TLA+                  With TLA+                  ) show newline
(  Design          Informal, ambiguous           Precise, mathematical      ) show newline
(  Bugs            Found in testing/production   Found before coding        ) show newline
(  Confidence      "Seems to work"               "Proven correct"           ) show newline
(  Documentation   Natural language              Executable specification   ) show newline
(  Maintenance     Risky changes                 Verify changes             ) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(LIMITATIONS) show newline
(------------------------------------------------------------------------) show newline
() show newline
(  * State explosion: Large state spaces take time) show newline
(  * Learning curve: TLA+ is different) show newline
(  * Abstraction gap: Spec ≠ implementation) show newline
(  * Finite models: Cannot check infinite systems directly) show newline
() show newline
(Mitigations: - Symmetry reduction - Abstraction - Proof for infinite) show newline
(cases) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(REFERENCES) show newline
(------------------------------------------------------------------------) show newline
() show newline
(1. Lamport, L. \(2002\). Specifying Systems: The TLA+ Language. 2.) show newline
(Lamport, L. \(2009\). The PlusCal Algorithm Language. 3. Newcombe, C., et) show newline
(al. \(2015\). How Amazon Web Services Uses Formal Methods. 4. TLA+ Tools:) show newline
(https://lamport.azurewebsites.net/tla/tools.html) show newline
() show newline
() show newline
(------------------------------------------------------------------------) show newline
(CHANGELOG) show newline
(------------------------------------------------------------------------) show newline
() show newline
(  * 2026-01-06) show newline
(  * Initial specification) show newline
() show newline
(------------------------------------------------------------------------) show newline

showpage
%%Trailer
%%Pages: pagenum
%%EOF
