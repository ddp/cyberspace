<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RFC-003: Cryptographic Audit Trail</title>
  <link rel="stylesheet" href="rfc.css">
</head>
<body>
<h1>RFC-003: Cryptographic Audit Trail</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This RFC specifies the cryptographic audit trail system for the Library of Cyberspace, providing tamper-evident, hash-chained logging with SPKI principal attribution and Ed25519 signatures.</p>
</section>
<section>
<h2>Motivation</h2>
<p>Distributed systems require accountability. Who did what, when, and under whose authority?</p>
<h3>Heritage: VMS Cluster-Wide Audit</h3>
<p>This audit trail descends from VMS SECURITY.AUDIT$JOURNAL and the cluster-wide security infrastructure of VMS 6.0 (1993). That system introduced:</p>
<ul>
<li>SECURITYPOLICY bit 7 propagation</li>
<li>Intrusion detection state replicated cluster-wide</li>
<li>Cluster-wide intrusion detection</li>
<li>Breakin attempts detected across all nodes as one</li>
<li>TLV-encoded object store</li>
<li>The [000000]SECURITY.SYS file in ODS5 stored SECURITYCLASS records</li>
</ul>
<p>The design principle then, as now: cluster nodes behave identically. N nodes, one security domain. Every significant action audited, every audit record signed.</p>
<p>Cyberspace audit trails apply the same principle at IPv6 scale.</p>
<h3>The Problem</h3>
<p>Traditional logging fails on all counts: - Tamperable: Text files can be edited - Anonymous: No cryptographic identity - Disconnected: No provable ordering - Unverifiable: No mathematical proof of integrity</p>
<p>Cyberspace audit trails provide: 1. Content-addressed entries - Tamper-evident by hash 2. Hash-chained structure - Append-only ordering 3. SPKI attribution - Cryptographic actor identity 4. Ed25519 seals - Mathematical proof of authenticity 5. Dual context - Human-readable motivation + machine-parseable environment</p>
</section>
<section>
<h2>Specification</h2>
<h3>Entry Structure</h3>
<pre class="language-scheme">
(audit-entry
  (id "sha512:b14471cd57ea557f...")
  (timestamp "Mon Jan 5 23:38:20 2026")
  (sequence 1)
  (parent-id "sha512:previous...")
  (actor
    (principal #${public-key-blob})
    (authorization-chain))
  (action
    (verb seal-publish)
    (object "1.0.0")
    (parameters "/path/to/remote"))
  (context
    (motivation "Published to filesystem")
    (language "en"))
  (environment
    (platform "darwin")
    (timestamp 1767685100))
  (seal
    (algorithm "ed25519-sha512")
    (content-hash "...")
    (signature "...")))
</pre>
<h3>Core Fields</h3>
<table>
<tr><th>Field </th><th>Type </th><th>Description </th></tr>
<tr><td>id </td><td>string </td><td>Content-addressed hash (SHA-512, first 32 hex chars) </td></tr>
<tr><td>timestamp </td><td>string </td><td>Human-readable time </td></tr>
<tr><td>sequence </td><td>integer </td><td>Monotonic counter within audit trail </td></tr>
<tr><td>parent-id </td><td>string/nil </td><td>ID of previous entry (hash chain) </td></tr>
<tr><td>actor </td><td>record </td><td>SPKI principal who performed action </td></tr>
<tr><td>action </td><td>record </td><td>What was done (verb, object, parameters) </td></tr>
<tr><td>context </td><td>record </td><td>Human-readable motivation </td></tr>
<tr><td>environment </td><td>alist </td><td>Machine environment snapshot </td></tr>
<tr><td>seal </td><td>record </td><td>Cryptographic signature </td></tr>
</table>
<h3>Actor Record</h3>
<pre class="language-scheme">
(define-record-type &lt;audit-actor&gt;
  (make-audit-actor principal authorization-chain)
  audit-actor?
  (principal actor-principal)              ; Public key blob
  (authorization-chain actor-authorization-chain))  ; SPKI cert chain
</pre>
<p>The actor is identified by: - Principal: Ed25519 public key (32 bytes) - Authorization chain: Optional SPKI certificate chain proving delegation</p>
<h3>Action Record</h3>
<pre class="language-scheme">
(define-record-type &lt;audit-action&gt;
  (make-audit-action verb object parameters)
  audit-action?
  (verb action-verb)        ; Symbol: seal-commit, seal-publish, etc.
  (object action-object)    ; Primary target
  (parameters action-parameters))  ; Additional arguments
</pre>
<p>Standard verbs: - seal-commit - Version control commit - seal-publish - Release publication - seal-subscribe - Subscription to remote - seal-synchronize - Bidirectional sync - seal-release - Version tagging</p>
<h3>Context Record</h3>
<pre class="language-scheme">
(define-record-type &lt;audit-context&gt;
  (make-audit-context motivation relates-to language)
  audit-context?
  (motivation context-motivation)    ; Human explanation
  (relates-to context-relates-to)    ; Related entries
  (language context-language))       ; ISO 639-1 code
</pre>
<p>Context provides: - Motivation: Why the action was taken (human-readable) - Relates-to: Cross-references to related audit entries - Language: For internationalization</p>
<h3>Seal Record</h3>
<pre class="language-scheme">
(define-record-type &lt;audit-seal&gt;
  (make-audit-seal algorithm content-hash signature)
  audit-seal?
  (algorithm seal-algorithm)        ; "ed25519-sha512"
  (content-hash seal-content-hash)  ; SHA-512 of unsealed entry
  (signature seal-signature))       ; Ed25519 signature
</pre>
</section>
<section>
<h2>Operations</h2>
<h3>audit-init</h3>
<p>Initialize audit trail for a vault.</p>
<pre class="language-scheme">
(audit-init signing-key: key audit-dir: ".vault/audit")
</pre>
<h3>audit-append</h3>
<p>Create and sign a new audit entry.</p>
<pre class="language-scheme">
(audit-append
  actor: public-key-blob
  action: '(seal-commit "hash123")
  motivation: "Added new feature"
  signing-key: private-key-blob)
</pre>
<p>Process: 1. Increment sequence counter 2. Get parent entry ID (hash chain link) 3. Build unsealed entry structure 4. Compute SHA-512 hash of canonical S-expression 5. Sign hash with Ed25519 6. Create seal record 7. Save entry to disk</p>
<h3>audit-verify</h3>
<p>Verify cryptographic seal on an entry.</p>
<pre class="language-scheme">
(audit-verify entry public-key: key)
</pre>
<p>Verification steps: 1. Reconstruct unsealed entry 2. Compute SHA-512 hash 3. Compare with stored content-hash 4. Verify Ed25519 signature</p>
<h3>audit-chain</h3>
<p>Verify entire audit chain.</p>
<pre class="language-scheme">
(audit-chain verify-key: public-key)
</pre>
<p>Verifies: - Each entry's signature is valid - Parent-id references form valid chain - Sequence numbers are monotonic</p>
<h3>audit-read</h3>
<p>Read specific audit entry.</p>
<pre class="language-scheme">
(audit-read sequence: 42)
(audit-read id: "sha512:...")
</pre>
</section>
<section>
<h2>Storage Format</h2>
<p>Entries stored as individual S-expression files:</p>
<pre>
.vault/audit/
  1.sexp
  2.sexp
  3.sexp
  ...
</pre>
<p>File naming by sequence number enables efficient: - Sequential reads - Range queries - Latest entry lookup</p>
</section>
<section>
<h2>Security Considerations</h2>
<h3>Threat Model</h3>
<p>Trusted: - Local filesystem (during operation) - Ed25519 implementation (libsodium) - Private keys</p>
<p>Untrusted: - Storage medium (after creation) - Network transport - Other actors</p>
<h3>Attack Mitigations</h3>
<table>
<tr><th>Attack </th><th>Mitigation </th></tr>
<tr><td>Entry modification </td><td>SHA-512 hash detects tampering </td></tr>
<tr><td>Entry deletion </td><td>Chain breaks are detectable </td></tr>
<tr><td>Entry insertion </td><td>Hash chain prevents backdating </td></tr>
<tr><td>Actor impersonation </td><td>Ed25519 signatures verify identity </td></tr>
<tr><td>Replay attacks </td><td>Sequence numbers detect duplicates </td></tr>
</table>
<h3>Non-Repudiation</h3>
<p>Once an entry is signed and published: - Actor cannot deny performing the action - Timestamp cannot be backdated - Content cannot be altered - Signature mathematically proves authorship</p>
</section>
<section>
<h2>Integration Points</h2>
<h3>Vault Operations</h3>
<p>All vault operations record audit entries:</p>
<pre class="language-scheme">
(seal-commit "message")     → (action (verb seal-commit) ...)
(seal-publish "1.0.0" ...)  → (action (verb seal-publish) ...)
(seal-subscribe remote ...) → (action (verb seal-subscribe) ...)
</pre>
<h3>SPKI Authorization</h3>
<p>Audit entries can include authorization chains:</p>
<pre class="language-scheme">
(actor
  (principal #${bob-public-key})
  (authorization-chain
    (signed-cert ...)   ; Alice delegated to Bob
    (signed-cert ...))) ; Root delegated to Alice
</pre>
<p>This proves not just who acted, but under whose authority.</p>
</section>
<section>
<h2>Export Formats</h2>
<h3>S-expression Export</h3>
<pre class="language-scheme">
(audit-export-sexp output: "audit-export.sexp")
</pre>
<p>Produces:</p>
<pre class="language-scheme">
(audit-trail
  (audit-entry ...)
  (audit-entry ...)
  ...)
</pre>
<h3>Human-readable Export</h3>
<pre class="language-scheme">
(audit-export-human output: "audit-export.txt")
</pre>
<p>Produces:</p>
<pre>
AUDIT TRAIL - Library of Cyberspace
===================================

Entry #1
  ID: sha512:b14471cd57ea557f...
  Time: Mon Jan 5 23:38:20 2026
  Action: seal-publish
  Why: Published release to filesystem

Entry #2
  ...
</pre>
</section>
<section>
<h2>Implementation Notes</h2>
<h3>Dependencies</h3>
<ul>
<li>crypto-ffi</li>
<li>Ed25519 signatures, SHA-512 hashing - srfi-1</li>
<li>List utilities - srfi-4 - u8vectors for binary data - srfi-13</li>
<li>String utilities</li>
</ul>
<h3>Performance Considerations</h3>
<ul>
<li>Content-addressed IDs enable O(1) lookup by hash</li>
<li>Sequential file naming enables efficient range queries</li>
<li>Lazy verification: verify on read, not on load</li>
</ul>
</section>
<section>
<h2>References</h2>
<p>1. Haber, S., &amp; Stornetta, W. S. (1991). How to time-stamp a digital document. 2. Merkle, R. C. (1987). A digital signature based on a conventional encryption function. 3. Bernstein, D. J. (2006). Curve25519: new Diffie-Hellman speed records. 4. SPKI/SDSI - RFC 2693, RFC 2692</p>
</section>
<section>
<h2>Changelog</h2>
<ul>
<li>2026-01-06</li>
<li>Initial specification</li>
</ul>
</section>
</body>
</html>
