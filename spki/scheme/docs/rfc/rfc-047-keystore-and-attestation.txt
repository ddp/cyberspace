RFC-047: Realm Keystore and Attestation


------------------------------------------------------------------------------

------------------------------------------------------------------------------
ABSTRACT
------------------------------------------------------------------------------

A realm without identity is not sovereign. This RFC defines two protected
stores within the vault:

1. Keystore - where cryptographic identity lives (Ed25519 signing keys) 2.
Attestation Store - where proofs about the realm live (hardware, software,
identity claims)

Together they form the inner vault - the protected core of a realm. Keys prove
who you are. Attestations prove what you are.


------------------------------------------------------------------------------
MOTIVATION
------------------------------------------------------------------------------

RFC-040 established that capabilities flow from Ed25519 signatures. Every
certificate, every sealed release, every audit entry requires a signature. But
where does the signing key live?

Currently: ephemeral, generated per session. This is fine for testing but
broken for production. A realm needs:

- Persistent identity - the same principal across sessions - Protected storage
- keys encrypted at rest - Recovery path - don't lose your realm to a
forgotten passphrase - Rotation support - keys age, compromise happens

The keystore solves this.


------------------------------------------------------------------------------
REALM CONTINUITY
------------------------------------------------------------------------------

A realm is not a snapshot. It accumulates.

Identity continuity - Your principal persists across sessions, machines,
years. Key rotation creates a signed chain: each new key vouched for by the
old. The chain IS your history.

Context accumulation - Every capability granted, every object stored, every
federation established - these form the realm's memory. The audit chain
records what happened. The attestation store proves what you were at each
moment.

History matters - A realm that has existed for ten years, rotated keys three
times, accumulated thousands of attestations, federated with hundreds of peers
- this realm has weight. Trust accrues. Reputation emerges from the chain.


    ┌─────────────────────────────────────────────────────────────────┐
    │                        REALM TIMELINE                            │
    ├─────────────────────────────────────────────────────────────────┤
    │                                                                  │
    │  Genesis ──► Key₁ ──► Key₂ ──► Key₃ ──► ... ──► Current        │
    │     │          │        │        │                   │          │
    │     ▼          ▼        ▼        ▼                   ▼          │
    │  [att₀]    [att₁₋₁₀] [att₁₁₋₅₀] [att₅₁₋₁₀₀]    [att_n]        │
    │                                                                  │
    │  Context grows. History deepens. Trust accumulates.             │
    └─────────────────────────────────────────────────────────────────┘

The inner vault preserves this continuity: - Keystore - the chain of identity
- Attestations - the record of what you were - Audit - the log of what you did

A realm without history is newborn. A realm with history has standing.


The Sealed Closure
------------------

A realm is a sealed closure - it closes over its environment and that closure
is cryptographically bound.


    ;; The realm as closure
    (lambda (request)
      ;; Closed over:
      ;;   - genesis: the first key, the origin moment
      ;;   - keychain: every rotation, signed by predecessor
      ;;   - attestations: every proof of what we were
      ;;   - audit: every action taken
      ;;   - capabilities: every right we hold
      ;;   - objects: every thing we store
      ;;
      ;; The closure is sealed:
      ;;   - Hash-chained: tamper-evident
      ;;   - Signed: non-repudiable
      ;;   - Content-addressed: self-verifying
      ;;
      (verify-and-respond request))

You cannot forge a realm. You cannot inject false history. You cannot claim
attestations you don't have. The closure is sealed at every point - verify any
moment, the chain holds or it doesn't.

Import a realm? You import the entire closure - genesis to present.

Fork a realm? You create a new closure that references the old. The fork point
is signed.

Merge realms? The histories must be compatible. Conflicts are visible.

The sealed closure is the unit of trust in cyberspace.


Living in the Soup
------------------

The sealed closure doesn't exist in a vacuum - it lives in the soup.

The soup is the medium. Objects float in it - content-addressed, immutable,
queryable. The realm swims through the soup, accumulating objects, granting
capabilities, leaving audit trails. Everything the realm touches becomes part
of its context.


    ┌─────────────────────────────────────────────────────────────────┐
    │                          THE SOUP                                │
    │                                                                  │
    │     ○ obj    ○ obj       ┌─────────────────┐      ○ obj         │
    │          ○ obj           │░░░░░░░░░░░░░░░░░│           ○ obj    │
    │    ○ obj          ○ obj  │░░░  REALM  ░░░░░│    ○ obj           │
    │         ○ obj            │░░░ (island) ░░░░│         ○ obj      │
    │   ○ obj       ○ obj      │░░░░░░░░░░░░░░░░░│  ○ obj             │
    │        ○ obj             └─────────────────┘       ○ obj        │
    │   ○ obj    ○ obj     ○ obj           ○ obj    ○ obj             │
    │                                                                  │
    │   Objects float. The realm is sovereign territory.              │
    └─────────────────────────────────────────────────────────────────┘

The realm is an island in the soup - an enclave of sovereignty, an instance
you can address. Objects float past, currents of content flow through
cyberspace, but the island is bounded. Its shores are defined by capabilities:
what it can see, what it can grant, what attests to it.

Every realm has coordinates: its principal. ed25519:7f3a2b4c... isn't just an
identifier - it's a place you can teleport to. Present the right capability,
and you're there. The soup connects all islands; the principal is your
destination.

Or send an agent.

You needn't go yourself. Delegate a capability to an agent - a subprocess, a
daemon, a trusted emissary - and it travels on your behalf. The agent carries
your authority (attenuated, scoped, time-limited) and acts in the soup. It
visits realms, fetches objects, negotiates federation. When it returns, its
audit trail merges with yours.


    (delegate-agent
      (parent "ed25519:your-realm...")
      (agent "ed25519:agent-key...")
      (capabilities
        (read "sha512:*")              ; Can read any object
        (federate "ed25519:peer..."))  ; Can negotiate with this peer
      (valid (not-after 1736500000))   ; Expires in 24h
      (sandbox                          ; Constraints
        (no-propagate)                  ; Cannot delegate further
        (audit-required)))              ; Must return audit chain

The agent is a sealed closure too - spawned from yours, carrying delegated
authority, accumulating its own history. When the mission ends, the histories
merge or the agent is revoked.

Lineage:

Go yourself - like telnet or VMS SET HOST. You're there, synchronous, your
session on that node. Direct presence in another realm.

Send an agent - like General Magic's Magic Cap and Telescript. Autonomous
travelers carrying your intent, visiting places, doing work, returning with
results. But recast in the spirit of Newton - agents swim in the soup, query
objects, accumulate context. The soup is their medium, capabilities their
passport.

The soup is a wilderness of mirrors. Objects reference objects. Hashes point
to hashes. Capabilities chain through delegation. Attestations vouch for
attestations. An agent navigating the soup sees reflections within reflections
- content-addressed identity means every object is its own mirror. The agent
must hold the thread of its capability chain or be lost in infinite regress.

This is not a safe place. It's cyberspace.


    ┌────────────────┐                    ┌────────────────┐
    │   YOUR REALM   │                    │   PEER REALM   │
    │                │                    │                │
    │  ┌──────────┐  │    SET HOST /      │  ┌──────────┐  │
    │  │   you    │━━━━━━━━━━━━━━━━━━━━━━━━▶│   you    │  │
    │  └──────────┘  │    telnet           │  └──────────┘  │
    │                │                    │                │
    │  ┌──────────┐  │    delegate        │  ┌──────────┐  │
    │  │  agent   │━━━━━━━━━━━━━━━━━━━━━━━━▶│  agent   │  │
    │  └──────────┘  │    (Magic Cap)      │  └──────────┘  │
    │                │                    │                │
    └────────────────┘                    └────────────────┘
                             ↑
                        THE SOUP
                     (Newton's medium)

Objects have no access control - they're just content, identified by hash. The
realm closure holds the capabilities that give meaning: "I can read this," "I
granted that," "This attests to me."

The soup is shared. Islands may be near or far. Federation is building bridges
between islands - agreeing to share objects, honor capabilities, witness each
other's audit chains.


Addressing Objects
------------------

Objects in cyberspace have coordinates:


    ;; Local (this realm)
    "releases/1.0.3"                    ; By path
    "sha512:abc123..."                  ; By hash
    ;; Remote (another realm) - @ syntax
    "@ed25519:7f3a2b.../releases/1.0.3"     ; Named object at realm
    "@ed25519:7f3a2b.../sha512:abc123..."   ; Hash-addressed at realm
    ;; With role context - @principal+role:/path
    "@ed25519:7f3a2b...+curator:/collections/rare-books"
    "@ed25519:7f3a2b...+guardian:/vault/keys"
    "@ed25519:7f3a2b...+witness:/audit/signatures"
    ;; With explicit capabilities - @principal+{caps}:/path
    "@ed25519:7f3a2b...+{read}:/objects/sha512:abc..."
    "@ed25519:7f3a2b...+{read,write}:/collections/working"
    "@ed25519:7f3a2b...+{read,delegate(read)}:/shared/docs"
    ;; Role with capability refinement
    "@ed25519:7f3a2b...+curator{read}:/collections/rare-books"  ; curator, read only
    ;; Inspect remote sealed object
    (soup-inspect "@ed25519:7f3a2b.../releases/1.0.3")
    ;; Fetch requires capability
    (soup-fetch "@ed25519:7f3a2b.../sha512:abc123..."
      capability: my-read-cert)
    ;; Fetch with role context
    (soup-fetch "@ed25519:7f3a2b...+curator:/collections/rare-books"
      capability: my-curator-cert)

The @principal:/path syntax reads: "at this realm, this object." The principal
is your teleport destination. The path or hash is what you're looking for.

The @principal+role:/path syntax adds role context: "at this realm, acting as
this role, this object."

The @principal+{caps}:/path syntax specifies explicit capabilities: "at this
realm, with these specific capabilities, this object." Roles are shorthand for
capability bundles; the +{caps} form is the truth underneath.

+role{caps} combines both: use this role, but only these capabilities from it.
Principle of least authority - request only what you need.

Without a capability granting access, you can see the object exists (if the
realm publishes its bloom filter) but cannot fetch its contents. The
wilderness of mirrors shows reflections - but you need the right key to step
through.


------------------------------------------------------------------------------
ARCHITECTURE
------------------------------------------------------------------------------


The Inner Vault
---------------


    .vault/
    ├── keystore/                    # Identity store
    │   ├── realm.key               # Encrypted private key
    │   ├── realm.pub               # Public key (this is your principal)
    │   ├── keystore.meta           # Metadata, parameters
    │   └── recovery/               # Optional threshold shares
    │       ├── share.1.key
    │       └── share.2.key
    ├── attestations/                # Proof store
    │   ├── hardware/               # Hardware attestations
    │   │   ├── anchor-quote.att       # Anchor measurement
    │   │   └── secure-enclave.att  # Apple SE attestation
    │   ├── software/               # Software attestations
    │   │   ├── boot-hash.att       # Measured boot
    │   │   └── runtime-hash.att    # Runtime measurements
    │   ├── identity/               # Third-party vouches
    │   │   └── ca-cert.att         # External CA attestation
    │   └── attestations.meta       # Attestation catalog
    ├── releases/
    ├── objects/
    ├── capabilities/
    ├── audit/
    └── node-hardware


Key Files
---------

realm.pub - Your public identity, shareable:


    (realm-public-key
      (version 1)
      (created 1736400000)
      (algorithm "ed25519")
      (public-key #${7f3a2b4c...}))

realm.key - Your private key, encrypted:


    (realm-private-key
      (version 1)
      (algorithm "ed25519")
      (protection "passphrase")      ; or "hardware", "threshold"
      (kdf "argon2id")
      (kdf-params
        (ops-limit 3)                ; cryptopwhashOPSLIMIT_MODERATE
        (mem-limit 268435456)        ; 256 MB
        (salt #${random-32-bytes}))
      (cipher "xchacha20-poly1305")
      (nonce #${random-24-bytes})
      (ciphertext #${encrypted-private-key}))

keystore.meta - Configuration:


    (keystore-meta
      (version 1)
      (created 1736400000)
      (last-accessed 1736450000)
      (protection "passphrase")
      (backup-reminder 7776000)      ; 90 days
      (rotation-reminder 31536000))  ; 1 year


------------------------------------------------------------------------------
CRYPTOGRAPHIC OPERATIONS
------------------------------------------------------------------------------


Key Derivation
--------------

Passphrase → encryption key via Argon2id:


    (define (derive-key passphrase salt)
      "Derive encryption key from passphrase using Argon2id"
      (let ((key (make-blob 32)))
        (sodium-pwhash!
          key
          passphrase
          salt
          3                          ; ops-limit (moderate)
          268435456                  ; mem-limit (256 MB)
          'argon2id)
        key))

Why Argon2id: - Memory-hard: resists GPU/ASIC attacks - Time-hard:
configurable iterations - Side-channel resistant: hybrid of Argon2i and
Argon2d - Winner of Password Hashing Competition - Already in libsodium


Encryption
----------

Private key encrypted via XChaCha20-Poly1305:


    (define (encrypt-private-key private-key encryption-key)
      "Encrypt private key for storage"
      (let ((nonce (random-bytes 24)))
        (values
          nonce
          (sodium-secretbox private-key nonce encryption-key))))
    (define (decrypt-private-key ciphertext nonce encryption-key)
      "Decrypt private key from storage"
      (sodium-secretbox-open ciphertext nonce encryption-key))

Why XChaCha20-Poly1305: - 256-bit key, 192-bit nonce - Extended nonce allows
random generation (no counter needed) - Authenticated: tampering detected -
Fast in software - Already in libsodium (crypto_secretbox)


------------------------------------------------------------------------------
BOOTSTRAP FLOW
------------------------------------------------------------------------------


New Realm
---------


    $ ./cyberspace-repl
    ╔═══════════════════════════════════════════════════════════╗
    ║                    REALM BOOTSTRAP                         ║
    ╚═══════════════════════════════════════════════════════════╝
    No realm identity found in .vault/keystore/
    Create new realm? [y/n] y
    Choose protection method:
      1. Passphrase (recommended)
      2. Hardware token (requires YubiKey)
      3. Threshold (k-of-n shares)
    Selection: 1
    Enter passphrase: 
    Confirm passphrase: 
    Generating Ed25519 keypair...
    Encrypting with Argon2id (this takes a moment)...
    ╔═══════════════════════════════════════════════════════════╗
    ║  REALM CREATED                                             ║
    ║                                                            ║
    ║  Principal: ed25519:7f3a2b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e  ║
    ║  Created:   2026-01-08 14:30:00 UTC                        ║
    ║                                                            ║
    ║  IMPORTANT: Your passphrase cannot be recovered.           ║
    ║  Consider creating recovery shares with (keystore-backup)  ║
    ╚═══════════════════════════════════════════════════════════╝
    cyberspace>


Existing Realm
--------------


    $ ./cyberspace-repl
    Realm: ed25519:7f3a2b4c...
    Passphrase: 
    Unlocking keystore...
    cyberspace> ; Ready, identity loaded


Failed Unlock
-------------


    Passphrase: 
    ERROR: Decryption failed (wrong passphrase?)
    Attempts remaining: 2
    Passphrase: 
    ERROR: Decryption failed
    Attempts remaining: 1
    WARNING: One attempt remaining. Consider:
      - Recovery shares if configured
      - The passphrase is case-sensitive
      - Check caps lock


------------------------------------------------------------------------------
RECOVERY
------------------------------------------------------------------------------


Threshold Shares
----------------

For high-value realms, split the key into k-of-n shares (RFC-007):


    (keystore-backup
      threshold: 2                   ; k - shares needed
      shares: 3)                     ; n - shares created
    ;; Output:
    ;; Share 1 of 3 (requires 2 to recover):
    ;; CYBER-SHARE-1-7f3a2b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2
    ;;
    ;; Share 2 of 3 (requires 2 to recover):
    ;; CYBER-SHARE-2-8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8
    ;;
    ;; Share 3 of 3 (requires 2 to recover):
    ;; CYBER-SHARE-3-9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9
    ;;
    ;; STORE THESE SEPARATELY. Any 2 can recover your realm.

Recovery:


    (keystore-recover
      "CYBER-SHARE-1-7f3a2b4c..."
      "CYBER-SHARE-3-9b0c1d2e...")
    ;; Realm recovered. Set new passphrase:
    ;; New passphrase: 
    ;; Confirm: 
    ;; Keystore restored.


Paper Backup
------------

For the paranoid (wisely so):


    (keystore-paper-backup)
    ;; Generates QR code + text backup for offline storage
    ;; Encrypted with passphrase, prints to terminal/file


------------------------------------------------------------------------------
KEY ROTATION
------------------------------------------------------------------------------

Keys should rotate periodically. Old key signs new key, creating continuity:


    (keystore-rotate)
    ;; Current principal: ed25519:7f3a2b4c...
    ;;
    ;; This will:
    ;;   1. Generate new Ed25519 keypair
    ;;   2. Sign rotation certificate with old key
    ;;   3. Store rotation chain in keystore
    ;;   4. New principal becomes active
    ;;
    ;; Proceed? [y/n] y
    ;;
    ;; Enter current passphrase: 
    ;; Enter new passphrase (or same): 
    ;;
    ;; Generating new keypair...
    ;; Signing rotation certificate...
    ;;
    ;; ROTATION COMPLETE
    ;; Old principal: ed25519:7f3a2b4c...
    ;; New principal: ed25519:2c3d4e5f...
    ;; Rotation cert: sha512:rotation-cert-hash...
    ;;
    ;; Old capabilities referencing ed25519:7f3a2b4c will need reissuance.

Rotation certificate:


    (rotation-cert
      (old-principal "ed25519:7f3a2b4c...")
      (new-principal "ed25519:2c3d4e5f...")
      (timestamp 1736500000)
      (reason "scheduled-rotation")
      (signature "ed25519:old-key-signature..."))


------------------------------------------------------------------------------
ATTESTATION STORE
------------------------------------------------------------------------------

Attestations are signed claims about the realm. They answer: "What can you
prove about yourself?"


Attestation Types
-----------------

Hardware Attestations - proofs from silicon:


    (hardware-attestation
      (type "anchor-quote")
      (timestamp 1736400000)
      (platform "Darwin-arm64")
      (measurements
        (rune-boot #${boot-measurement...})
        (rune-policy #${secureboot-policy...}))
      (signature #${anchor-signature...})
      (certificate #${endorsement-key-cert...}))

Software Attestations - proofs from code:


    (software-attestation
      (type "runtime-measurement")
      (timestamp 1736400000)
      (binary-hash "sha512:cyberspace-repl...")
      (library-hashes
        ("libsodium.dylib" "sha512:...")
        ("libchicken.dylib" "sha512:..."))
      (signature #${realm-signature...}))

Identity Attestations - third-party vouches:


    (identity-attestation
      (type "ca-vouch")
      (timestamp 1736400000)
      (subject "ed25519:7f3a2b4c...")         ; This realm
      (issuer "ed25519:ca-public-key...")     ; Vouching authority
      (claims
        (organization "Acme Corp")
        (role "coordinator"))
      (valid (not-after 1767936000))
      (signature #${ca-signature...}))

Capability Attestations - proof of holding:


    (capability-attestation
      (type "capability-proof")
      (timestamp 1736400000)
      (capability "sha512:cert-hash...")
      (holder "ed25519:7f3a2b4c...")
      (challenge #${nonce...})                ; Prevents replay
      (response #${signed-challenge...}))


Attestation Catalog
-------------------

The attestation store maintains a catalog for fast lookup:


    (attestations-meta
      (version 1)
      (count 5)
      (types
        (hardware 2)
        (software 1)
        (identity 1)
        (capability 1))
      (latest-refresh 1736400000)
      (entries
        ((id "att-001") (type hardware) (file "hardware/anchor-quote.att") (expires #f))
        ((id "att-002") (type hardware) (file "hardware/secure-enclave.att") (expires #f))
        ((id "att-003") (type software) (file "software/runtime-hash.att") (expires #f))
        ((id "att-004") (type identity) (file "identity/ca-cert.att") (expires 1767936000))
        ((id "att-005") (type capability) (file "capability/coord-role.att") (expires 1736500000))))


Attestation Operations
----------------------


    ;; Refresh hardware attestations (re-measure)
    (attestation-refresh-hardware)
    ;; => Querying Anchor... done.
    ;; => Querying Secure Enclave... done.
    ;; => 2 hardware attestations updated.
    ;; Measure current software state
    (attestation-measure-software)
    ;; => Hashing cyberspace-repl... done.
    ;; => Hashing loaded libraries... done.
    ;; => Software attestation stored.
    ;; Request identity attestation from CA
    (attestation-request-identity "ed25519:ca-key...")
    ;; => Sending attestation request to CA...
    ;; => (requires CA to sign and return)
    ;; Prove capability holding (for remote verification)
    (attestation-prove-capability "sha512:cert-hash..." challenge)
    ;; => (capability-attestation ...)
    ;; List all attestations
    (attestation-list)
    ;; => ((att-001 hardware anchor-quote valid)
    ;;     (att-002 hardware secure-enclave valid)
    ;;     (att-003 software runtime-hash valid)
    ;;     (att-004 identity ca-cert expires:2026-12-31)
    ;;     (att-005 capability coord-role expires:2026-01-10))
    ;; Verify an attestation
    (attestation-verify "att-001")
    ;; => (attestation att-001 (status valid) (type hardware) (verified #t))
    ;; Export for remote verification
    (attestation-export "att-001")
    ;; => (hardware-attestation (type "anchor-quote") ...)


Attestation Chain
-----------------

Attestations can chain - a hardware attestation vouches for software, software
vouches for capabilities:


    ┌───────────────────────────┐
    │    The Anchor (Silicon)   │  "This boot sequence is measured"
    └─────────────┬─────────────┘
                  │ vouches for
                  ▼
    ┌───────────────────────────┐
    │    Software Runes         │  "These binaries are running"
    └─────────────┬─────────────┘
                  │ vouches for
                  ▼
    ┌───────────────────────────┐
    │    Realm Identity         │  "This is my signing key"
    └─────────────┬─────────────┘
                  │ vouches for
                  ▼
    ┌───────────────────────────┐
    │    Capabilities Held      │  "I can do these things"
    └───────────────────────────┘

Remote verifier can walk the chain: "Show me your hardware attestation,
software measurement, and the capability you claim."


Use Cases
---------

Coordinator Election (RFC-037): Candidate presents attestations proving
hardware capability and identity. Voters verify before granting coordinator
role.

Federation Trust (RFC-039): Realms exchange attestations when federating.
"Before I sync objects with you, prove your software is legitimate."

High-Security Operations: Some capabilities might require fresh attestation:
"This capability requires Anchor attestation less than 1 hour old."


------------------------------------------------------------------------------
HARDWARE TOKEN SUPPORT
------------------------------------------------------------------------------

Future: YubiKey, secure enclaves, hardware anchors.


    (keystore-meta
      (version 1)
      (protection "hardware")
      (hardware-type "yubikey-5")
      (hardware-serial "12345678")
      (public-key #${...}))          ; Private key never leaves device

The private key never touches disk - it lives in the hardware token.
Operations requiring signature prompt for touch.


------------------------------------------------------------------------------
SECURITY CONSIDERATIONS
------------------------------------------------------------------------------


What We Protect Against
-----------------------


  Threat              Mitigation          
  Disk theft          Encrypted at rest (X
  Weak passphrase     Argon2id memory-hard
  Brute force         Rate limiting, attem
  Memory dump         Zero memory after us
  Forgotten passphraseThreshold recovery s
  Key compromise      Rotation support    


What We Don't Protect Against
-----------------------------


  Threat              Why                 
  Compromised endpointIf attacker has root
  Keylogger capturing Endpoint security pr
  Rubber hose cryptanaMath doesn't help   
  Quantum computers   Ed25519 vulnerable (


Memory Handling
---------------


    (define (with-sensitive-data data thunk)
      "Execute thunk with sensitive data, zero on exit"
      (dynamic-wind
        (lambda () #f)
        thunk
        (lambda () (sodium-memzero! data))))

Private keys are zeroed immediately after use. Passphrases are zeroed after
key derivation.


------------------------------------------------------------------------------
REPL COMMANDS
------------------------------------------------------------------------------


    ;; Check keystore status
    (keystore-status)
    ;; => (keystore (status unlocked) (principal "ed25519:7f3a...") (protection passphrase))
    ;; Lock keystore (zero keys from memory)
    (keystore-lock)
    ;; => Keystore locked. Re-authentication required for signing.
    ;; Unlock keystore
    (keystore-unlock)
    ;; => Passphrase: 
    ;; => Keystore unlocked.
    ;; Change passphrase
    (keystore-change-passphrase)
    ;; => Current passphrase: 
    ;; => New passphrase: 
    ;; => Confirm: 
    ;; => Passphrase changed.
    ;; Create recovery shares
    (keystore-backup threshold: 2 shares: 3)
    ;; Recover from shares
    (keystore-recover share1 share2)
    ;; Rotate key
    (keystore-rotate)
    ;; Export public key (safe to share)
    (keystore-export-public)
    ;; => (realm-public-key (algorithm "ed25519") (public-key #${7f3a...}))


------------------------------------------------------------------------------
VAULT PROTECTION
------------------------------------------------------------------------------

The keystore protects itself. The operating system is not trusted.

realm.key - Never stored plaintext. The ciphertext blob is meaningless without
the passphrase. Even if someone copies the file, they have nothing.

realm.pub - Public by nature. This IS your identity. Share it freely.

attestations/ - Signed claims. Tamper-evident by construction. Copy them,
share them - forgery is computationally infeasible.

The vault doesn't rely on filesystem permissions, SELinux, or any operating
system mechanism. Cyberspace assumes the OS is compromised. Protection comes
from:

1. Encryption - Private key encrypted at rest 2. Memory zeroing - Keys cleared
immediately after use 3. Signatures - Everything signed, tampering detected 4.
Content addressing - Hash IS identity

If someone has root on your machine, they can install a keylogger - that's a
physical security problem, not a cryptographic one. Cyberspace protects the
math. Protect the machine yourself.


------------------------------------------------------------------------------
INTEGRATION
------------------------------------------------------------------------------


With seal-release (RFC-033)
---------------------------


    (seal-release "1.0.4" name: "phoenix")
    ;; Uses keystore signing key automatically
    ;; Prompts for unlock if keystore locked


With capabilities (RFC-004)
---------------------------


    (spki-cert-create
      subject: "ed25519:bob..."
      tag: '(read "sha512:doc..."))
    ;; Signed with keystore key
    ;; Issuer automatically set to realm principal


With audit (RFC-040)
--------------------


    ;; Audit entries signed with keystore key
    ;; Principal identity consistent across sessions


------------------------------------------------------------------------------
INVARIANTS
------------------------------------------------------------------------------


Keystore
--------


    K1. Private key never stored plaintext
        stored(private-key) → encrypted(private-key)
    K2. Decryption requires authentication
        decrypt(keystore) → auth(passphrase) ∨ auth(hardware) ∨ auth(threshold)
    K3. Memory zeroed after use
        use(sensitive-data) → zero(sensitive-data)
    K4. Rotation preserves identity chain
        rotate(k₁,k₂) → signed(k₂, k₁)
    K5. Recovery requires threshold
        recover(keystore) → shares ≥ k


Attestation
-----------


    A1. Attestations are signed
        store(attestation) → signed(attestation, issuer)
    A2. Attestation chains are verifiable
        chain(a₁→a₂→...→aₙ) → ∀i: valid_sig(aᵢ)
    A3. Hardware attestations originate from anchors
        hardware-attestation(a) → anchor-signed(a)
    A4. Attestations are timestamped
        attestation(a) → timestamp(a) ∧ fresh(a, policy)
    A5. Expired attestations are invalid
        expired(a) → ¬valid(a)


------------------------------------------------------------------------------
QUANTUM RESISTANCE
------------------------------------------------------------------------------

SHA-512 won't survive. Grover's algorithm halves the security - 256 bits
becomes 128. For the wilderness of mirrors to endure, we need
quantum-resistant Merkle trees.

The Path Forward:


    Current:     sha512(content) → object identity
    Future:      merkle-root(shake256(chunks...)) → object identity

Why Merkle trees: - Incremental updates without rehashing everything -
Selective disclosure - prove a branch without revealing siblings - Tree
structure means log(n) proof sizes - Quantum-resistant hash at each node

Candidate hash functions:


  Function            Output              Notes               
  SHAKE256            Variable            SHA-3 family, NIST a
  BLAKE3              256-bit             Fast, tree-based int
  SHA-3-512           512-bit             Conservative choice,

Migration:

Objects can carry both hashes during transition:


    (object
      (content-hash "sha512:abc123...")           ; Legacy
      (merkle-root "shake256:def456...")          ; Quantum-resistant
      (tree-depth 4)
      (chunk-size 4096))

The soup becomes a forest of Merkle trees. Each object a tree, each tree
quantum-hardened. The wilderness of mirrors, built to outlast the quantum
winter.

Ed25519 replacement: SPHINCS+ or CRYSTALS-Dilithium for signatures. That's a
separate RFC.


------------------------------------------------------------------------------
REFERENCES
------------------------------------------------------------------------------

1. libsodium documentation - Password Hashing, Secret-key Encryption 2. Argon2
specification - https://github.com/P-H-C/phc-winner-argon2 3. Shamir's Secret
Sharing - Shamir, A., "How to Share a Secret", 1979 4. RFC-007 - Threshold
Governance 5. RFC-040 - Cyberspace Security Architecture


------------------------------------------------------------------------------
CHANGELOG
------------------------------------------------------------------------------

- 2026-01-08 - Initial draft

------------------------------------------------------------------------------
