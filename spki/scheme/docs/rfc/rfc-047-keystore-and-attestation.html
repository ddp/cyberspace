<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RFC-047: Realm Keystore and Attestation</title>
  <link rel="stylesheet" href="rfc.css">
</head>
<body>
<h1>RFC-047: Realm Keystore and Attestation</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>A realm without identity is not sovereign. This RFC defines two protected stores within the vault:</p>
<p>1. Keystore - where cryptographic identity lives (Ed25519 signing keys) 2. Attestation Store - where proofs about the realm live (hardware, software, identity claims)</p>
<p>Together they form the inner vault - the protected core of a realm. Keys prove who you are. Attestations prove what you are.</p>
</section>
<section>
<h2>Motivation</h2>
<p>RFC-040 established that capabilities flow from Ed25519 signatures. Every certificate, every sealed release, every audit entry requires a signature. But where does the signing key live?</p>
<p>Currently: ephemeral, generated per session. This is fine for testing but broken for production. A realm needs:</p>
<ul>
<li>Persistent identity - the same principal across sessions</li>
<li>Protected storage - keys encrypted at rest</li>
<li>Recovery path - don't lose your realm to a forgotten passphrase</li>
<li>Rotation support - keys age, compromise happens</li>
</ul>
<p>The keystore solves this.</p>
</section>
<section>
<h2>Realm Continuity</h2>
<p>A realm is not a snapshot. It accumulates.</p>
<p>Identity continuity - Your principal persists across sessions, machines, years. Key rotation creates a signed chain: each new key vouched for by the old. The chain IS your history.</p>
<p>Context accumulation - Every capability granted, every object stored, every federation established - these form the realm's memory. The audit chain records what happened. The attestation store proves what you were at each moment.</p>
<p>History matters - A realm that has existed for ten years, rotated keys three times, accumulated thousands of attestations, federated with hundreds of peers - this realm has weight. Trust accrues. Reputation emerges from the chain.</p>
<pre>
┌─────────────────────────────────────────────────────────────────┐
│                        REALM TIMELINE                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Genesis ──► Key₁ ──► Key₂ ──► Key₃ ──► ... ──► Current        │
│     │          │        │        │                   │          │
│     ▼          ▼        ▼        ▼                   ▼          │
│  [att₀]    [att₁₋₁₀] [att₁₁₋₅₀] [att₅₁₋₁₀₀]    [att_n]        │
│                                                                  │
│  Context grows. History deepens. Trust accumulates.             │
└─────────────────────────────────────────────────────────────────┘
</pre>
<p>The inner vault preserves this continuity: - Keystore - the chain of identity - Attestations - the record of what you were - Audit - the log of what you did</p>
<p>A realm without history is newborn. A realm with history has standing.</p>
<h3>The Sealed Closure</h3>
<p>A realm is a sealed closure - it closes over its environment and that closure is cryptographically bound.</p>
<pre class="language-scheme">
;; The realm as closure
(lambda (request)
  ;; Closed over:
  ;;   - genesis: the first key, the origin moment
  ;;   - keychain: every rotation, signed by predecessor
  ;;   - attestations: every proof of what we were
  ;;   - audit: every action taken
  ;;   - capabilities: every right we hold
  ;;   - objects: every thing we store
  ;;
  ;; The closure is sealed:
  ;;   - Hash-chained: tamper-evident
  ;;   - Signed: non-repudiable
  ;;   - Content-addressed: self-verifying
  ;;
  (verify-and-respond request))
</pre>
<p>You cannot forge a realm. You cannot inject false history. You cannot claim attestations you don't have. The closure is sealed at every point - verify any moment, the chain holds or it doesn't.</p>
<p>Import a realm? You import the entire closure - genesis to present.</p>
<p>Fork a realm? You create a new closure that references the old. The fork point is signed.</p>
<p>Merge realms? The histories must be compatible. Conflicts are visible.</p>
<p>The sealed closure is the unit of trust in cyberspace.</p>
<h3>Living in the Soup</h3>
<p>The sealed closure doesn't exist in a vacuum - it lives in the soup.</p>
<p>The soup is the medium. Objects float in it - content-addressed, immutable, queryable. The realm swims through the soup, accumulating objects, granting capabilities, leaving audit trails. Everything the realm touches becomes part of its context.</p>
<pre>
┌─────────────────────────────────────────────────────────────────┐
│                          THE SOUP                                │
│                                                                  │
│     ○ obj    ○ obj       ┌─────────────────┐      ○ obj         │
│          ○ obj           │░░░░░░░░░░░░░░░░░│           ○ obj    │
│    ○ obj          ○ obj  │░░░  REALM  ░░░░░│    ○ obj           │
│         ○ obj            │░░░ (island) ░░░░│         ○ obj      │
│   ○ obj       ○ obj      │░░░░░░░░░░░░░░░░░│  ○ obj             │
│        ○ obj             └─────────────────┘       ○ obj        │
│   ○ obj    ○ obj     ○ obj           ○ obj    ○ obj             │
│                                                                  │
│   Objects float. The realm is sovereign territory.              │
└─────────────────────────────────────────────────────────────────┘
</pre>
<p>The realm is an island in the soup - an enclave of sovereignty, an instance you can address. Objects float past, currents of content flow through cyberspace, but the island is bounded. Its shores are defined by capabilities: what it can see, what it can grant, what attests to it.</p>
<p>Every realm has coordinates: its principal. ed25519:7f3a2b4c... isn't just an identifier - it's a place you can teleport to. Present the right capability, and you're there. The soup connects all islands; the principal is your destination.</p>
<p>Or send an agent.</p>
<p>You needn't go yourself. Delegate a capability to an agent - a subprocess, a daemon, a trusted emissary - and it travels on your behalf. The agent carries your authority (attenuated, scoped, time-limited) and acts in the soup. It visits realms, fetches objects, negotiates federation. When it returns, its audit trail merges with yours.</p>
<pre class="language-scheme">
(delegate-agent
  (parent "ed25519:your-realm...")
  (agent "ed25519:agent-key...")
  (capabilities
    (read "sha512:*")              ; Can read any object
    (federate "ed25519:peer..."))  ; Can negotiate with this peer
  (valid (not-after 1736500000))   ; Expires in 24h
  (sandbox                          ; Constraints
    (no-propagate)                  ; Cannot delegate further
    (audit-required)))              ; Must return audit chain
</pre>
<p>The agent is a sealed closure too - spawned from yours, carrying delegated authority, accumulating its own history. When the mission ends, the histories merge or the agent is revoked.</p>
<p>Lineage:</p>
<p>Go yourself - like telnet or VMS SET HOST. You're there, synchronous, your session on that node. Direct presence in another realm.</p>
<p>Send an agent - like General Magic's Magic Cap and Telescript. Autonomous travelers carrying your intent, visiting places, doing work, returning with results. But recast in the spirit of Newton - agents swim in the soup, query objects, accumulate context. The soup is their medium, capabilities their passport.</p>
<p>The soup is a wilderness of mirrors. Objects reference objects. Hashes point to hashes. Capabilities chain through delegation. Attestations vouch for attestations. An agent navigating the soup sees reflections within reflections - content-addressed identity means every object is its own mirror. The agent must hold the thread of its capability chain or be lost in infinite regress.</p>
<p>This is not a safe place. It's cyberspace.</p>
<pre>
┌────────────────┐                    ┌────────────────┐
│   YOUR REALM   │                    │   PEER REALM   │
│                │                    │                │
│  ┌──────────┐  │    SET HOST /      │  ┌──────────┐  │
│  │   you    │━━━━━━━━━━━━━━━━━━━━━━━━▶│   you    │  │
│  └──────────┘  │    telnet           │  └──────────┘  │
│                │                    │                │
│  ┌──────────┐  │    delegate        │  ┌──────────┐  │
│  │  agent   │━━━━━━━━━━━━━━━━━━━━━━━━▶│  agent   │  │
│  └──────────┘  │    (Magic Cap)      │  └──────────┘  │
│                │                    │                │
└────────────────┘                    └────────────────┘
                         ↑
                    THE SOUP
                 (Newton's medium)
</pre>
<p>Objects have no access control - they're just content, identified by hash. The realm closure holds the capabilities that give meaning: "I can read this," "I granted that," "This attests to me."</p>
<p>The soup is shared. Islands may be near or far. Federation is building bridges between islands - agreeing to share objects, honor capabilities, witness each other's audit chains.</p>
<h3>Addressing Objects</h3>
<p>Objects in cyberspace have coordinates:</p>
<pre class="language-scheme">
;; Local (this realm)
"releases/1.0.3"                    ; By path
"sha512:abc123..."                  ; By hash

;; Remote (another realm) - @ syntax
"@ed25519:7f3a2b.../releases/1.0.3"     ; Named object at realm
"@ed25519:7f3a2b.../sha512:abc123..."   ; Hash-addressed at realm

;; With role context - @principal+role:/path
"@ed25519:7f3a2b...+curator:/collections/rare-books"
"@ed25519:7f3a2b...+guardian:/vault/keys"
"@ed25519:7f3a2b...+witness:/audit/signatures"

;; With explicit capabilities - @principal+{caps}:/path
"@ed25519:7f3a2b...+{read}:/objects/sha512:abc..."
"@ed25519:7f3a2b...+{read,write}:/collections/working"
"@ed25519:7f3a2b...+{read,delegate(read)}:/shared/docs"

;; Role with capability refinement
"@ed25519:7f3a2b...+curator{read}:/collections/rare-books"  ; curator, read only

;; Inspect remote sealed object
(soup-inspect "@ed25519:7f3a2b.../releases/1.0.3")

;; Fetch requires capability
(soup-fetch "@ed25519:7f3a2b.../sha512:abc123..."
  capability: my-read-cert)

;; Fetch with role context
(soup-fetch "@ed25519:7f3a2b...+curator:/collections/rare-books"
  capability: my-curator-cert)
</pre>
<p>The @principal:/path syntax reads: "at this realm, this object." The principal is your teleport destination. The path or hash is what you're looking for.</p>
<p>The @principal+role:/path syntax adds role context: "at this realm, acting as this role, this object."</p>
<p>The @principal+{caps}:/path syntax specifies explicit capabilities: "at this realm, with these specific capabilities, this object." Roles are shorthand for capability bundles; the +{caps} form is the truth underneath.</p>
<p>+role{caps} combines both: use this role, but only these capabilities from it. Principle of least authority - request only what you need.</p>
<p>Without a capability granting access, you can see the object exists (if the realm publishes its bloom filter) but cannot fetch its contents. The wilderness of mirrors shows reflections - but you need the right key to step through.</p>
</section>
<section>
<h2>Architecture</h2>
<h3>The Inner Vault</h3>
<pre>
.vault/
├── keystore/                    # Identity store
│   ├── realm.key               # Encrypted private key
│   ├── realm.pub               # Public key (this is your principal)
│   ├── keystore.meta           # Metadata, parameters
│   └── recovery/               # Optional threshold shares
│       ├── share.1.key
│       └── share.2.key
├── attestations/                # Proof store
│   ├── hardware/               # Hardware attestations
│   │   ├── anchor-quote.att       # Anchor measurement
│   │   └── secure-enclave.att  # Apple SE attestation
│   ├── software/               # Software attestations
│   │   ├── boot-hash.att       # Measured boot
│   │   └── runtime-hash.att    # Runtime measurements
│   ├── identity/               # Third-party vouches
│   │   └── ca-cert.att         # External CA attestation
│   └── attestations.meta       # Attestation catalog
├── releases/
├── objects/
├── capabilities/
├── audit/
└── node-hardware
</pre>
<h3>Key Files</h3>
<p>realm.pub - Your public identity, shareable:</p>
<pre class="language-scheme">
(realm-public-key
  (version 1)
  (created 1736400000)
  (algorithm "ed25519")
  (public-key #${7f3a2b4c...}))
</pre>
<p>realm.key - Your private key, encrypted:</p>
<pre class="language-scheme">
(realm-private-key
  (version 1)
  (algorithm "ed25519")
  (protection "passphrase")      ; or "hardware", "threshold"
  (kdf "argon2id")
  (kdf-params
    (ops-limit 3)                ; cryptopwhashOPSLIMIT_MODERATE
    (mem-limit 268435456)        ; 256 MB
    (salt #${random-32-bytes}))
  (cipher "xchacha20-poly1305")
  (nonce #${random-24-bytes})
  (ciphertext #${encrypted-private-key}))
</pre>
<p>keystore.meta - Configuration:</p>
<pre class="language-scheme">
(keystore-meta
  (version 1)
  (created 1736400000)
  (last-accessed 1736450000)
  (protection "passphrase")
  (backup-reminder 7776000)      ; 90 days
  (rotation-reminder 31536000))  ; 1 year
</pre>
</section>
<section>
<h2>Cryptographic Operations</h2>
<h3>Key Derivation</h3>
<p>Passphrase → encryption key via Argon2id:</p>
<pre class="language-scheme">
(define (derive-key passphrase salt)
  "Derive encryption key from passphrase using Argon2id"
  (let ((key (make-blob 32)))
    (sodium-pwhash!
      key
      passphrase
      salt
      3                          ; ops-limit (moderate)
      268435456                  ; mem-limit (256 MB)
      'argon2id)
    key))
</pre>
<p>Why Argon2id: - Memory-hard: resists GPU/ASIC attacks - Time-hard: configurable iterations - Side-channel resistant: hybrid of Argon2i and Argon2d - Winner of Password Hashing Competition - Already in libsodium</p>
<h3>Encryption</h3>
<p>Private key encrypted via XChaCha20-Poly1305:</p>
<pre class="language-scheme">
(define (encrypt-private-key private-key encryption-key)
  "Encrypt private key for storage"
  (let ((nonce (random-bytes 24)))
    (values
      nonce
      (sodium-secretbox private-key nonce encryption-key))))

(define (decrypt-private-key ciphertext nonce encryption-key)
  "Decrypt private key from storage"
  (sodium-secretbox-open ciphertext nonce encryption-key))
</pre>
<p>Why XChaCha20-Poly1305: - 256-bit key, 192-bit nonce - Extended nonce allows random generation (no counter needed) - Authenticated: tampering detected - Fast in software - Already in libsodium (crypto_secretbox)</p>
</section>
<section>
<h2>Bootstrap Flow</h2>
<h3>New Realm</h3>
<pre>
$ ./cyberspace-repl

╔═══════════════════════════════════════════════════════════╗
║                    REALM BOOTSTRAP                         ║
╚═══════════════════════════════════════════════════════════╝

No realm identity found in .vault/keystore/

Create new realm? [y/n] y

Choose protection method:
  1. Passphrase (recommended)
  2. Hardware token (requires YubiKey)
  3. Threshold (k-of-n shares)

Selection: 1

Enter passphrase: 
Confirm passphrase: 

Generating Ed25519 keypair...
Encrypting with Argon2id (this takes a moment)...

╔═══════════════════════════════════════════════════════════╗
║  REALM CREATED                                             ║
║                                                            ║
║  Principal: ed25519:7f3a2b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e  ║
║  Created:   2026-01-08 14:30:00 UTC                        ║
║                                                            ║
║  IMPORTANT: Your passphrase cannot be recovered.           ║
║  Consider creating recovery shares with (keystore-backup)  ║
╚═══════════════════════════════════════════════════════════╝

cyberspace&gt;
</pre>
<h3>Existing Realm</h3>
<pre>
$ ./cyberspace-repl

Realm: ed25519:7f3a2b4c...
Passphrase: 

Unlocking keystore...

cyberspace&gt; ; Ready, identity loaded
</pre>
<h3>Failed Unlock</h3>
<pre>
Passphrase: 

ERROR: Decryption failed (wrong passphrase?)
Attempts remaining: 2

Passphrase: 

ERROR: Decryption failed
Attempts remaining: 1

WARNING: One attempt remaining. Consider:
  - Recovery shares if configured
  - The passphrase is case-sensitive
  - Check caps lock
</pre>
</section>
<section>
<h2>Recovery</h2>
<h3>Threshold Shares</h3>
<p>For high-value realms, split the key into k-of-n shares (RFC-007):</p>
<pre class="language-scheme">
(keystore-backup
  threshold: 2                   ; k - shares needed
  shares: 3)                     ; n - shares created

;; Output:
;; Share 1 of 3 (requires 2 to recover):
;; CYBER-SHARE-1-7f3a2b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2
;;
;; Share 2 of 3 (requires 2 to recover):
;; CYBER-SHARE-2-8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8
;;
;; Share 3 of 3 (requires 2 to recover):
;; CYBER-SHARE-3-9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9
;;
;; STORE THESE SEPARATELY. Any 2 can recover your realm.
</pre>
<p>Recovery:</p>
<pre class="language-scheme">
(keystore-recover
  "CYBER-SHARE-1-7f3a2b4c..."
  "CYBER-SHARE-3-9b0c1d2e...")

;; Realm recovered. Set new passphrase:
;; New passphrase: 
;; Confirm: 
;; Keystore restored.
</pre>
<h3>Paper Backup</h3>
<p>For the paranoid (wisely so):</p>
<pre class="language-scheme">
(keystore-paper-backup)

;; Generates QR code + text backup for offline storage
;; Encrypted with passphrase, prints to terminal/file
</pre>
</section>
<section>
<h2>Key Rotation</h2>
<p>Keys should rotate periodically. Old key signs new key, creating continuity:</p>
<pre class="language-scheme">
(keystore-rotate)

;; Current principal: ed25519:7f3a2b4c...
;;
;; This will:
;;   1. Generate new Ed25519 keypair
;;   2. Sign rotation certificate with old key
;;   3. Store rotation chain in keystore
;;   4. New principal becomes active
;;
;; Proceed? [y/n] y
;;
;; Enter current passphrase: 
;; Enter new passphrase (or same): 
;;
;; Generating new keypair...
;; Signing rotation certificate...
;;
;; ROTATION COMPLETE
;; Old principal: ed25519:7f3a2b4c...
;; New principal: ed25519:2c3d4e5f...
;; Rotation cert: sha512:rotation-cert-hash...
;;
;; Old capabilities referencing ed25519:7f3a2b4c will need reissuance.
</pre>
<p>Rotation certificate:</p>
<pre class="language-scheme">
(rotation-cert
  (old-principal "ed25519:7f3a2b4c...")
  (new-principal "ed25519:2c3d4e5f...")
  (timestamp 1736500000)
  (reason "scheduled-rotation")
  (signature "ed25519:old-key-signature..."))
</pre>
</section>
<section>
<h2>Attestation Store</h2>
<p>Attestations are signed claims about the realm. They answer: "What can you prove about yourself?"</p>
<h3>Attestation Types</h3>
<p>Hardware Attestations - proofs from silicon:</p>
<pre class="language-scheme">
(hardware-attestation
  (type "anchor-quote")
  (timestamp 1736400000)
  (platform "Darwin-arm64")
  (measurements
    (rune-boot #${boot-measurement...})
    (rune-policy #${secureboot-policy...}))
  (signature #${anchor-signature...})
  (certificate #${endorsement-key-cert...}))
</pre>
<p>Software Attestations - proofs from code:</p>
<pre class="language-scheme">
(software-attestation
  (type "runtime-measurement")
  (timestamp 1736400000)
  (binary-hash "sha512:cyberspace-repl...")
  (library-hashes
    ("libsodium.dylib" "sha512:...")
    ("libchicken.dylib" "sha512:..."))
  (signature #${realm-signature...}))
</pre>
<p>Identity Attestations - third-party vouches:</p>
<pre class="language-scheme">
(identity-attestation
  (type "ca-vouch")
  (timestamp 1736400000)
  (subject "ed25519:7f3a2b4c...")         ; This realm
  (issuer "ed25519:ca-public-key...")     ; Vouching authority
  (claims
    (organization "Acme Corp")
    (role "coordinator"))
  (valid (not-after 1767936000))
  (signature #${ca-signature...}))
</pre>
<p>Capability Attestations - proof of holding:</p>
<pre class="language-scheme">
(capability-attestation
  (type "capability-proof")
  (timestamp 1736400000)
  (capability "sha512:cert-hash...")
  (holder "ed25519:7f3a2b4c...")
  (challenge #${nonce...})                ; Prevents replay
  (response #${signed-challenge...}))
</pre>
<h3>Attestation Catalog</h3>
<p>The attestation store maintains a catalog for fast lookup:</p>
<pre class="language-scheme">
(attestations-meta
  (version 1)
  (count 5)
  (types
    (hardware 2)
    (software 1)
    (identity 1)
    (capability 1))
  (latest-refresh 1736400000)
  (entries
    ((id "att-001") (type hardware) (file "hardware/anchor-quote.att") (expires #f))
    ((id "att-002") (type hardware) (file "hardware/secure-enclave.att") (expires #f))
    ((id "att-003") (type software) (file "software/runtime-hash.att") (expires #f))
    ((id "att-004") (type identity) (file "identity/ca-cert.att") (expires 1767936000))
    ((id "att-005") (type capability) (file "capability/coord-role.att") (expires 1736500000))))
</pre>
<h3>Attestation Operations</h3>
<pre class="language-scheme">
;; Refresh hardware attestations (re-measure)
(attestation-refresh-hardware)
;; =&gt; Querying Anchor... done.
;; =&gt; Querying Secure Enclave... done.
;; =&gt; 2 hardware attestations updated.

;; Measure current software state
(attestation-measure-software)
;; =&gt; Hashing cyberspace-repl... done.
;; =&gt; Hashing loaded libraries... done.
;; =&gt; Software attestation stored.

;; Request identity attestation from CA
(attestation-request-identity "ed25519:ca-key...")
;; =&gt; Sending attestation request to CA...
;; =&gt; (requires CA to sign and return)

;; Prove capability holding (for remote verification)
(attestation-prove-capability "sha512:cert-hash..." challenge)
;; =&gt; (capability-attestation ...)

;; List all attestations
(attestation-list)
;; =&gt; ((att-001 hardware anchor-quote valid)
;;     (att-002 hardware secure-enclave valid)
;;     (att-003 software runtime-hash valid)
;;     (att-004 identity ca-cert expires:2026-12-31)
;;     (att-005 capability coord-role expires:2026-01-10))

;; Verify an attestation
(attestation-verify "att-001")
;; =&gt; (attestation att-001 (status valid) (type hardware) (verified #t))

;; Export for remote verification
(attestation-export "att-001")
;; =&gt; (hardware-attestation (type "anchor-quote") ...)
</pre>
<h3>Attestation Chain</h3>
<p>Attestations can chain - a hardware attestation vouches for software, software vouches for capabilities:</p>
<pre>
┌───────────────────────────┐
│    The Anchor (Silicon)   │  "This boot sequence is measured"
└─────────────┬─────────────┘
              │ vouches for
              ▼
┌───────────────────────────┐
│    Software Runes         │  "These binaries are running"
└─────────────┬─────────────┘
              │ vouches for
              ▼
┌───────────────────────────┐
│    Realm Identity         │  "This is my signing key"
└─────────────┬─────────────┘
              │ vouches for
              ▼
┌───────────────────────────┐
│    Capabilities Held      │  "I can do these things"
└───────────────────────────┘
</pre>
<p>Remote verifier can walk the chain: "Show me your hardware attestation, software measurement, and the capability you claim."</p>
<h3>Use Cases</h3>
<p>Coordinator Election (RFC-037): Candidate presents attestations proving hardware capability and identity. Voters verify before granting coordinator role.</p>
<p>Federation Trust (RFC-039): Realms exchange attestations when federating. "Before I sync objects with you, prove your software is legitimate."</p>
<p>High-Security Operations: Some capabilities might require fresh attestation: "This capability requires Anchor attestation less than 1 hour old."</p>
</section>
<section>
<h2>Hardware Token Support</h2>
<p>Future: YubiKey, secure enclaves, hardware anchors.</p>
<pre class="language-scheme">
(keystore-meta
  (version 1)
  (protection "hardware")
  (hardware-type "yubikey-5")
  (hardware-serial "12345678")
  (public-key #${...}))          ; Private key never leaves device
</pre>
<p>The private key never touches disk - it lives in the hardware token. Operations requiring signature prompt for touch.</p>
</section>
<section>
<h2>Security Considerations</h2>
<h3>What We Protect Against</h3>
<table>
<tr><th>Threat </th><th>Mitigation </th></tr>
<tr><td>Disk theft </td><td>Encrypted at rest (XChaCha20-Poly1305) </td></tr>
<tr><td>Weak passphrase </td><td>Argon2id memory-hard KDF </td></tr>
<tr><td>Brute force </td><td>Rate limiting, attempt counter </td></tr>
<tr><td>Memory dump </td><td>Zero memory after use </td></tr>
<tr><td>Forgotten passphrase </td><td>Threshold recovery shares </td></tr>
<tr><td>Key compromise </td><td>Rotation support </td></tr>
</table>
<h3>What We Don't Protect Against</h3>
<table>
<tr><th>Threat </th><th>Why </th></tr>
<tr><td>Compromised endpoint </td><td>If attacker has root, game over </td></tr>
<tr><td>Keylogger capturing passphrase </td><td>Endpoint security problem </td></tr>
<tr><td>Rubber hose cryptanalysis </td><td>Math doesn't help </td></tr>
<tr><td>Quantum computers </td><td>Ed25519 vulnerable (migration planned) </td></tr>
</table>
<h3>Memory Handling</h3>
<pre class="language-scheme">
(define (with-sensitive-data data thunk)
  "Execute thunk with sensitive data, zero on exit"
  (dynamic-wind
    (lambda () #f)
    thunk
    (lambda () (sodium-memzero! data))))
</pre>
<p>Private keys are zeroed immediately after use. Passphrases are zeroed after key derivation.</p>
</section>
<section>
<h2>REPL Commands</h2>
<pre class="language-scheme">
;; Check keystore status
(keystore-status)
;; =&gt; (keystore (status unlocked) (principal "ed25519:7f3a...") (protection passphrase))

;; Lock keystore (zero keys from memory)
(keystore-lock)
;; =&gt; Keystore locked. Re-authentication required for signing.

;; Unlock keystore
(keystore-unlock)
;; =&gt; Passphrase: 
;; =&gt; Keystore unlocked.

;; Change passphrase
(keystore-change-passphrase)
;; =&gt; Current passphrase: 
;; =&gt; New passphrase: 
;; =&gt; Confirm: 
;; =&gt; Passphrase changed.

;; Create recovery shares
(keystore-backup threshold: 2 shares: 3)

;; Recover from shares
(keystore-recover share1 share2)

;; Rotate key
(keystore-rotate)

;; Export public key (safe to share)
(keystore-export-public)
;; =&gt; (realm-public-key (algorithm "ed25519") (public-key #${7f3a...}))
</pre>
</section>
<section>
<h2>Vault Protection</h2>
<p>The keystore protects itself. The operating system is not trusted.</p>
<p>realm.key - Never stored plaintext. The ciphertext blob is meaningless without the passphrase. Even if someone copies the file, they have nothing.</p>
<p>realm.pub - Public by nature. This IS your identity. Share it freely.</p>
<p>attestations/ - Signed claims. Tamper-evident by construction. Copy them, share them - forgery is computationally infeasible.</p>
<p>The vault doesn't rely on filesystem permissions, SELinux, or any operating system mechanism. Cyberspace assumes the OS is compromised. Protection comes from:</p>
<p>1. Encryption - Private key encrypted at rest 2. Memory zeroing - Keys cleared immediately after use 3. Signatures - Everything signed, tampering detected 4. Content addressing - Hash IS identity</p>
<p>If someone has root on your machine, they can install a keylogger - that's a physical security problem, not a cryptographic one. Cyberspace protects the math. Protect the machine yourself.</p>
</section>
<section>
<h2>Integration</h2>
<h3>With seal-release (RFC-033)</h3>
<pre class="language-scheme">
(seal-release "1.0.4" name: "phoenix")
;; Uses keystore signing key automatically
;; Prompts for unlock if keystore locked
</pre>
<h3>With capabilities (RFC-004)</h3>
<pre class="language-scheme">
(spki-cert-create
  subject: "ed25519:bob..."
  tag: '(read "sha512:doc..."))
;; Signed with keystore key
;; Issuer automatically set to realm principal
</pre>
<h3>With audit (RFC-040)</h3>
<pre class="language-scheme">
;; Audit entries signed with keystore key
;; Principal identity consistent across sessions
</pre>
</section>
<section>
<h2>Invariants</h2>
<h3>Keystore</h3>
<pre>
K1. Private key never stored plaintext
    stored(private-key) → encrypted(private-key)

K2. Decryption requires authentication
    decrypt(keystore) → auth(passphrase) ∨ auth(hardware) ∨ auth(threshold)

K3. Memory zeroed after use
    use(sensitive-data) → zero(sensitive-data)

K4. Rotation preserves identity chain
    rotate(k₁,k₂) → signed(k₂, k₁)

K5. Recovery requires threshold
    recover(keystore) → shares ≥ k
</pre>
<h3>Attestation</h3>
<pre>
A1. Attestations are signed
    store(attestation) → signed(attestation, issuer)

A2. Attestation chains are verifiable
    chain(a₁→a₂→...→aₙ) → ∀i: valid_sig(aᵢ)

A3. Hardware attestations originate from anchors
    hardware-attestation(a) → anchor-signed(a)

A4. Attestations are timestamped
    attestation(a) → timestamp(a) ∧ fresh(a, policy)

A5. Expired attestations are invalid
    expired(a) → ¬valid(a)
</pre>
</section>
<section>
<h2>Quantum Resistance</h2>
<p>SHA-512 won't survive. Grover's algorithm halves the security - 256 bits becomes 128. For the wilderness of mirrors to endure, we need quantum-resistant Merkle trees.</p>
<p>The Path Forward:</p>
<pre>
Current:     sha512(content) → object identity
Future:      merkle-root(shake256(chunks...)) → object identity
</pre>
<p>Why Merkle trees: - Incremental updates without rehashing everything - Selective disclosure - prove a branch without revealing siblings - Tree structure means log(n) proof sizes - Quantum-resistant hash at each node</p>
<p>Candidate hash functions:</p>
<table>
<tr><th>Function </th><th>Output </th><th>Notes </th></tr>
<tr><td>SHAKE256 </td><td>Variable </td><td>SHA-3 family, NIST approved, used by SPHINCS+ </td></tr>
<tr><td>BLAKE3 </td><td>256-bit </td><td>Fast, tree-based internally, modern </td></tr>
<tr><td>SHA-3-512 </td><td>512-bit </td><td>Conservative choice, different construction than SHA-2 </td></tr>
</table>
<p>Migration:</p>
<p>Objects can carry both hashes during transition:</p>
<pre class="language-scheme">
(object
  (content-hash "sha512:abc123...")           ; Legacy
  (merkle-root "shake256:def456...")          ; Quantum-resistant
  (tree-depth 4)
  (chunk-size 4096))
</pre>
<p>The soup becomes a forest of Merkle trees. Each object a tree, each tree quantum-hardened. The wilderness of mirrors, built to outlast the quantum winter.</p>
<p>Ed25519 replacement: SPHINCS+ or CRYSTALS-Dilithium for signatures. That's a separate RFC.</p>
</section>
<section>
<h2>References</h2>
<p>1. libsodium documentation - Password Hashing, Secret-key Encryption 2. Argon2 specification - https://github.com/P-H-C/phc-winner-argon2 3. Shamir's Secret Sharing - Shamir, A., "How to Share a Secret", 1979 4. RFC-007 - Threshold Governance 5. RFC-040 - Cyberspace Security Architecture</p>
</section>
<section>
<h2>Changelog</h2>
<ul>
<li>2026-01-08</li>
<li>Initial draft</li>
</ul>
</section>
</body>
</html>
