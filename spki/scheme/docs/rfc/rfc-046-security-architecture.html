<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>rfc-046-security-architecture</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="rfc.css" />
</head>
<body>
<h1 id="rfc-046-cyberspace-security-architecture">RFC-046: Cyberspace
Security Architecture</h1>
<p><strong>Status:</strong> Draft <strong>Date:</strong> January 2026
<strong>Author:</strong> Derrell Piper <a href="mailto:ddp@eludom.net"
class="email">ddp@eludom.net</a> <strong>Requires:</strong> RFC-004
(SPKI Authorization), RFC-007 (Threshold Governance), RFC-037 (Node
Roles)</p>
<hr />
<h2 id="abstract">Abstract</h2>
<p>This document defines how cyberspace protects itself. The model is
simple: <strong>capabilities all the way down</strong>. Objects are
content. Authorization flows through signed certificates. No labels, no
ACLs, no ambient authority. You hold a capability or you don’t.</p>
<p>We use the rigor of TCSEC B2 as a lens - particularly for covert
channel analysis - but cyberspace is its own thing. This is our security
architecture, in our language.</p>
<hr />
<h2 id="the-manifesto">The Manifesto</h2>
<blockquote>
<p><strong>Authorized capability set with auditing. No central
authority.</strong></p>
</blockquote>
<p>You can have a central authority if you want one. That’s up to you.
But you don’t <em>need</em> one. The architecture doesn’t require it.
Trust flows from keys you choose to trust, not from a hierarchy imposed
upon you.</p>
<p>These principles were proven in VAXcluster security (1984-1994),
proposed in SDSI at IETF 29 Seattle (1994), and implemented partially in
products that didn’t survive their parent companies. Cyberspace
completes what was started.</p>
<h3 id="design-lineage">Design Lineage</h3>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 29%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr>
<th>Era</th>
<th>System</th>
<th>Contribution</th>
</tr>
</thead>
<tbody>
<tr>
<td>1984</td>
<td>VAXcluster</td>
<td>“Behave as one” - N nodes, one security domain</td>
</tr>
<tr>
<td>1985</td>
<td>VMS C2</td>
<td>Audit trails, access control, TCSEC security primitives</td>
</tr>
<tr>
<td>1993</td>
<td>VMS 6.0</td>
<td>Cluster-wide intrusion detection, TLV object store</td>
</tr>
<tr>
<td>1994</td>
<td>SDSI</td>
<td>Self-certifying keys, local names (Rivest, IETF 29)</td>
</tr>
<tr>
<td>1999</td>
<td>SPKI</td>
<td>Authorization certificates, capability delegation</td>
</tr>
<tr>
<td>2026</td>
<td>Cyberspace</td>
<td>Synthesis: SPKI + audit + IPv6 mesh + no central authority</td>
</tr>
</tbody>
</table>
<p>DECnet Phase IV had 24-bit addressing—fatal for internet scale.
Cyberspace is designed for IPv6: 128-bit addresses, global mesh, same
security principles.</p>
<hr />
<h2 id="security-object-types">Security Object Types</h2>
<p>Every first-class object in cyberspace. Names as defined.</p>
<p><em>Table 0: Security Object Registry</em></p>
<table>
<thead>
<tr>
<th>Object</th>
<th>Defining RFC</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Identity</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>principal</code></td>
<td>RFC-004</td>
<td>Cryptographic identity (ed25519 key or hash)</td>
</tr>
<tr>
<td><code>key</code></td>
<td>RFC-022</td>
<td>Keypair with ceremony provenance</td>
</tr>
<tr>
<td><code>attestation</code></td>
<td>RFC-041</td>
<td>Signed claim about identity or state</td>
</tr>
<tr>
<td><strong>Authorization</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>certificate</code></td>
<td>RFC-004</td>
<td>SPKI capability grant</td>
</tr>
<tr>
<td><code>tag</code></td>
<td>RFC-004</td>
<td>Authorization scope (read, write, etc.)</td>
</tr>
<tr>
<td><code>signature</code></td>
<td>RFC-004</td>
<td>Ed25519 attestation</td>
</tr>
<tr>
<td><code>share</code></td>
<td>RFC-008</td>
<td>Shamir secret fragment</td>
</tr>
<tr>
<td><code>quorum</code></td>
<td>RFC-036</td>
<td>Voting threshold specification</td>
</tr>
<tr>
<td><strong>Storage</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>vault</code></td>
<td>RFC-006</td>
<td>Sovereign storage realm</td>
</tr>
<tr>
<td><code>object</code></td>
<td>RFC-020</td>
<td>Content-addressed immutable data</td>
</tr>
<tr>
<td><code>archive</code></td>
<td>RFC-018</td>
<td>Sealed, encrypted content package</td>
</tr>
<tr>
<td><code>schema</code></td>
<td>RFC-033</td>
<td>Structure definition</td>
</tr>
<tr>
<td><strong>Boundaries</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>realm</code></td>
<td>RFC-040</td>
<td>Trust and sovereignty boundary</td>
</tr>
<tr>
<td><code>wormhole</code></td>
<td>RFC-041</td>
<td>FUSE mount portal to filesystem</td>
</tr>
<tr>
<td><code>federation</code></td>
<td>RFC-010</td>
<td>Peer network of realms</td>
</tr>
<tr>
<td><code>node</code></td>
<td>RFC-037</td>
<td>Network participant with role</td>
</tr>
<tr>
<td><strong>Execution</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>agent</code></td>
<td>RFC-023</td>
<td>Sandboxed daemon</td>
</tr>
<tr>
<td><code>topic</code></td>
<td>RFC-035</td>
<td>Pub/sub channel</td>
</tr>
<tr>
<td><code>tunnel</code></td>
<td>RFC-035</td>
<td>Agent communication path</td>
</tr>
<tr>
<td><code>lock</code></td>
<td>RFC-035</td>
<td>Distributed mutex</td>
</tr>
<tr>
<td><strong>Observability</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>audit-entry</code></td>
<td>RFC-003</td>
<td>Immutable log record</td>
</tr>
<tr>
<td><code>lamport-clock</code></td>
<td>RFC-012</td>
<td>Causal ordering timestamp</td>
</tr>
<tr>
<td><code>query</code></td>
<td>RFC-025</td>
<td>Search expression</td>
</tr>
<tr>
<td><strong>Documentation</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>memo</code></td>
<td>RFC-043</td>
<td>Scoped documentation unit</td>
</tr>
<tr>
<td><code>soup</code></td>
<td>RFC-040</td>
<td>The auditable collection of all things</td>
</tr>
</tbody>
</table>
<h3 id="object-properties">Object Properties</h3>
<p>All security objects share:</p>
<pre><code>1. Content-addressed identity (SHA-512 hash)
2. Cryptographic signature (Ed25519)
3. Audit trail integration (RFC-003)
4. Capability-gated access (RFC-004)
5. State: chaotic | quiescent</code></pre>
<h3 id="object-state">Object State</h3>
<p>All things in cyberspace exist in two states:</p>
<table>
<thead>
<tr>
<th>State</th>
<th>Meaning</th>
<th>Properties</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>chaotic</strong></td>
<td>In flux, being modified</td>
<td>Mutable, uncommitted, local</td>
</tr>
<tr>
<td><strong>quiescent</strong></td>
<td>At rest, stable</td>
<td>Immutable, signed, replicable</td>
</tr>
</tbody>
</table>
<p>Transitions:</p>
<pre><code>chaotic ──commit──▶ quiescent
    ▲                   │
    │                   │
    └───── fork ────────┘</code></pre>
<p>Only quiescent objects: - Have stable content hashes - Can be signed
- Can be replicated - Can be delegated</p>
<p>Chaotic things: - Exist only in the realm’s store - Have provisional
identity - Cannot be shared - Must settle before federation - Cannot be
cached</p>
<h3 id="caching-implications">Caching Implications</h3>
<p>State controls caching:</p>
<table>
<thead>
<tr>
<th>State</th>
<th>Cacheable</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>quiescent</strong></td>
<td>Forever</td>
<td>Hash is identity; immutable</td>
</tr>
<tr>
<td><strong>chaotic</strong></td>
<td>Never</td>
<td>Content may change; no stable hash</td>
</tr>
</tbody>
</table>
<p>Quiescent things cache by content hash. Cache hit = identical
content, guaranteed. Chaotic things bypass cache entirely. Every access
reads current state.</p>
<h3 id="persistence">Persistence</h3>
<p>Persistence is the guarantee of migration to the vault.</p>
<table>
<thead>
<tr>
<th>Durability</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>persistent</strong></td>
<td>Guaranteed to migrate to vault</td>
</tr>
<tr>
<td><strong>ephemeral</strong></td>
<td>May vanish; no durability promise</td>
</tr>
</tbody>
</table>
<p>State and durability are orthogonal:</p>
<table>
<thead>
<tr>
<th></th>
<th>Ephemeral</th>
<th>Persistent</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Chaotic</strong></td>
<td>Scratch work</td>
<td>Draft being saved</td>
</tr>
<tr>
<td><strong>Quiescent</strong></td>
<td>Cached result</td>
<td>Archived thing</td>
</tr>
</tbody>
</table>
<p>Persistent things survive restart. Ephemeral things don’t.</p>
<p>Vault takes cataloging and effort. Not all things need persistence.
Ephemeral is not failure—it’s deliberate economy. Cache results, scratch
work, intermediate computations: let them vanish.</p>
<p>Marking a thing persistent schedules vault migration.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>(persist thing)    <span class="co">; guarantee vault migration</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>(ephemeral thing)  <span class="co">; no durability promise</span></span></code></pre></div>
<h3 id="object-relationships">Object Relationships</h3>
<pre><code>principal ──creates──▶ certificate ──grants──▶ tag
    │                      │
    │                      ▼
    │                   object ◀──stores── vault
    │                      │
    ▼                      ▼
  agent ──operates──▶ wormhole ──bridges──▶ realm
    │                                         │
    │                                         ▼
    └──────────────────────────────────▶ federation</code></pre>
<hr />
<h2 id="the-axioms">The Axioms</h2>
<pre><code>A1. No Ambient Authority
    You have nothing until someone gives you something.
    Every access requires presenting a capability.

A2. Capabilities Are Unforgeable
    Ed25519 signatures. No exceptions.
    Create by origin or delegation. No other path.

A3. Capabilities Only Attenuate
    Delegation can reduce rights, never amplify.
    What you give cannot exceed what you hold.

A4. Objects Are Immutable Content
    SHA-512 hash IS identity.
    No metadata. No labels. No ACLs.
    Objects don&#39;t know who can access them.</code></pre>
<hr />
<h2 id="the-realm">The Realm</h2>
<p>A realm is your place in cyberspace. It is sovereign.</p>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│                        YOUR REALM                            │
│                                                              │
│   Principal: ed25519:a1b2c3...  (this is you)               │
│                                                              │
│   ┌──────────────────────────────────────────────────────┐  │
│   │                      VAULT                            │  │
│   │  Objects:     content-addressed, signed               │  │
│   │  Capabilities: certificates you hold                  │  │
│   │  Audit:       what happened here                      │  │
│   └──────────────────────────────────────────────────────┘  │
│                                                              │
│   Trust boundary: your signing key                          │
│   You decide: what to store, who to trust, what to share    │
└─────────────────────────────────────────────────────────────┘</code></pre>
<p>Your realm is local-first. Federation is optional. When you federate,
realms overlap - objects flow according to capability chains. But your
realm remains yours.</p>
<hr />
<h2 id="capabilities">Capabilities</h2>
<h3 id="the-certificate">The Certificate</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>(spki-cert</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  (issuer <span class="st">&quot;ed25519:alice...&quot;</span>)        <span class="co">; Who grants</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  (subject <span class="st">&quot;ed25519:bob...&quot;</span>)         <span class="co">; Who receives</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  (tag (<span class="kw">read</span> <span class="st">&quot;sha512:doc...&quot;</span>))       <span class="co">; What: read this object</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  (valid (not-after <span class="dv">1736400000</span>))     <span class="co">; When: expires in 24h</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  (propagate <span class="dv">#f</span>)                     <span class="co">; Bob cannot delegate</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  (signature <span class="st">&quot;ed25519:...&quot;</span>))         <span class="co">; Alice&#39;s signature</span></span></code></pre></div>
<h3 id="access-check">Access Check</h3>
<pre><code>Can Bob read sha512:doc?

1. Does Bob hold a cert granting (read &quot;sha512:doc&quot;)?
2. Is the signature valid?
3. Is it expired?
4. Is it revoked?
5. Does the chain trace to someone who could grant it?

All yes? Access granted.
Any no?  Access denied.</code></pre>
<h3 id="delegation">Delegation</h3>
<p>Alice can give Bob read access:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>(spki-cert</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  (issuer <span class="st">&quot;ed25519:alice...&quot;</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  (subject <span class="st">&quot;ed25519:bob...&quot;</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  (tag (<span class="kw">read</span> <span class="st">&quot;sha512:doc...&quot;</span>))</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  (propagate <span class="dv">#t</span>))                    <span class="co">; Bob CAN delegate</span></span></code></pre></div>
<p>Bob can give Carol read access (because Alice allowed
propagation):</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>(spki-cert</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  (issuer <span class="st">&quot;ed25519:bob...&quot;</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  (subject <span class="st">&quot;ed25519:carol...&quot;</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  (tag (<span class="kw">read</span> <span class="st">&quot;sha512:doc...&quot;</span>))</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  (propagate <span class="dv">#f</span>))                    <span class="co">; Carol cannot delegate further</span></span></code></pre></div>
<p>Carol cannot give anyone else access. The chain stops.</p>
<hr />
<h2 id="classification-without-labels">Classification Without
Labels</h2>
<p>Traditional MAC puts labels on objects: UNCLASSIFIED, SECRET, TOP
SECRET.</p>
<p>In cyberspace, classification is a capability you hold:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">;; Security officer grants SECRET clearance</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>(spki-cert</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  (issuer <span class="st">&quot;ed25519:security-officer...&quot;</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  (subject <span class="st">&quot;ed25519:analyst...&quot;</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  (tag (clearance secret))</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  (valid (not-after <span class="dv">1767225600</span>)))    <span class="co">; Annual renewal</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="co">;; Program manager grants compartment access</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>(spki-cert</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>  (issuer <span class="st">&quot;ed25519:program-manager...&quot;</span>)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>  (subject <span class="st">&quot;ed25519:engineer...&quot;</span>)</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>  (tag (compartment <span class="st">&quot;project-atlas&quot;</span>)))</span></code></pre></div>
<p>Access to a classified object requires: 1. Capability to read the
object itself 2. Appropriate clearance capability 3. All required
compartment capabilities</p>
<p>The object has no labels. The policy lives in the certificates.</p>
<hr />
<h2 id="information-flow">Information Flow</h2>
<p>The mathematics of multilevel security, expressed in
capabilities.</p>
<h3 id="the-properties">The Properties</h3>
<p>Traditional formulations speak of “read up” and “write down” with
respect to classification labels. We preserve the mathematics but speak
differently:</p>
<table>
<colgroup>
<col style="width: 30%" />
<col style="width: 27%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr>
<th>Traditional</th>
<th>Cyberspace</th>
<th>Formal Statement</th>
</tr>
</thead>
<tbody>
<tr>
<td>“No read up”</td>
<td>Read requires capability</td>
<td>∀ read(P,O): P ∈ holders(cap_read(O))</td>
</tr>
<tr>
<td>“No write down”</td>
<td>Write requires capability</td>
<td>∀ write(P,O): P ∈ holders(cap_write(O))</td>
</tr>
<tr>
<td>“No read down”</td>
<td>Integrity via provenance</td>
<td>∀ accept(P,O): verify(signature(O))</td>
</tr>
<tr>
<td>“No write up”</td>
<td>Attenuation only</td>
<td>∀ delegate(P₁,P₂,C): C ⊆ capabilities(P₁)</td>
</tr>
</tbody>
</table>
<p>The capability graph IS the lattice. Delegation flows down. Authority
cannot flow up.</p>
<h3 id="confidentiality">Confidentiality</h3>
<p>Information flows only through capabilities:</p>
<pre><code>∀ read(P,O): P ∈ holders(cap_read(O))
∀ write(P,O): P ∈ holders(cap_write(O))
∀ delegate(P₁,P₂,C): C ⊆ capabilities(P₁)</code></pre>
<p>A principal without read capability cannot observe content. A
principal without write capability cannot exfiltrate via storage.
Delegation cannot grant what you don’t hold.</p>
<h3 id="integrity">Integrity</h3>
<p>Modification flows only through capabilities:</p>
<pre><code>∀ modify(P,O): P ∈ holders(cap_write(O))
∀ delegate(P₁,P₂,C&#39;): integrity(C&#39;) ≤ integrity(C)
∀ capability C: provenance(C) ⊆ audit_trail</code></pre>
<p>Objects cannot be corrupted without write capability. Delegated
capabilities cannot exceed held capabilities. All grants are
traceable.</p>
<h3 id="confinement">Confinement</h3>
<p>The capability discipline eliminates ambient authority:</p>
<pre><code>∀ access(P,O): ∃ C ∈ capabilities(P): authorizes(C,O)
∀ C: unforgeable(C)
∀ acquire(P,C): ∃ P&#39;: delegate(P&#39;,P,C) ∨ create(P,O)</code></pre>
<p>No access without explicit capability. Capabilities cannot be
manufactured. The only paths: receive via delegation, or create the
object.</p>
<h3 id="wormhole-enforcement">Wormhole Enforcement</h3>
<p>Wormholes (RFC-041) are channel boundaries. Information flow is
enforced at every crossing:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>(wormhole-flow-guard wormhole operation object)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">;; Checks:</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">;; 1. wormhole has capabilities (no ambient authority)</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">;; 2. operation permitted by held capabilities</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">;; 3. audit entry created</span></span></code></pre></div>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Required Capability</th>
<th>Violation Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>read, stat, readdir</td>
<td><code>read</code></td>
<td>confidentiality</td>
</tr>
<tr>
<td>write, create, chmod</td>
<td><code>write</code></td>
<td>integrity</td>
</tr>
<tr>
<td>delete, unlink</td>
<td><code>delete</code></td>
<td>integrity</td>
</tr>
<tr>
<td>delegate</td>
<td><code>delegate</code></td>
<td>amplification</td>
</tr>
</tbody>
</table>
<p>Denied operations raise typed errors: -
<code>no-ambient-authority</code> — wormhole has no capabilities -
<code>read-denied</code> — missing read capability -
<code>write-denied</code> — missing write capability -
<code>capability-amplification</code> — delegation exceeds held</p>
<h3 id="the-lattice">The Lattice</h3>
<p>Capabilities form a partial order. The lattice:</p>
<pre><code>        full
          │
    ┌─────┼─────┐
    │     │     │
  admin synch read-write
    │     │     │
    └─────┼─────┘
          │
      read-only
          │
        none</code></pre>
<p>Delegation can only move DOWN the lattice. This is attenuation. You
cannot delegate <code>admin</code> if you hold <code>read-only</code>.
You cannot grant <code>write</code> if you hold <code>read</code>.</p>
<p>The math is sound. We just speak it in capabilities.</p>
<hr />
<h2 id="secure-erasure">Secure Erasure</h2>
<p>When sensitive data must be destroyed, it must be destroyed
completely.</p>
<h3 id="erasure-requirements">Erasure Requirements</h3>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 20%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr>
<th>What</th>
<th>How</th>
<th>Verification</th>
</tr>
</thead>
<tbody>
<tr>
<td>Object content</td>
<td>Overwrite with random, then zeros</td>
<td>Read-back verify</td>
</tr>
<tr>
<td>Memory buffers</td>
<td>Secure memset, compiler barrier</td>
<td>Not optimized away</td>
</tr>
<tr>
<td>Key material</td>
<td>Zeroize immediately after use</td>
<td>Audit trail entry</td>
</tr>
<tr>
<td>Audit entries</td>
<td>Preserve hash chain, redact content</td>
<td>Chain integrity</td>
</tr>
<tr>
<td>Capability certs</td>
<td>Revoke, then destroy</td>
<td>Revocation published</td>
</tr>
</tbody>
</table>
<h3 id="erasure-guarantees">Erasure Guarantees</h3>
<pre><code>E1. Zeroization is atomic
    erase(o) → ¬recoverable(o)

E2. Memory clearing defeats inspection
    clear(buffer) → ∀ address ∈ buffer: read(address) = 0

E3. Key destruction is immediate
    destroy(key) → ¬usable(key) ∧ audit(destroyed, key)

E4. Revocation propagates
    revoke(cert) → ∀ delegate(cert, c&#39;): revoke(c&#39;)</code></pre>
<h3 id="implementation">Implementation</h3>
<div class="sourceCode" id="cb18"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">;; Secure memory clearing (defeats compiler optimization)</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="fu">secure-clear! </span>buffer)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;Overwrite buffer with zeros, verify&quot;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> ((len (blob-size buffer)))</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; Write zeros</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">do</span> ((i <span class="dv">0</span> (<span class="op">+</span> i <span class="dv">1</span>)))</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>        ((<span class="op">&gt;=</span> i len))</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>      (blob-set! buffer i <span class="dv">0</span>))</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; Memory barrier (implementation-specific)</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; Verify</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">do</span> ((i <span class="dv">0</span> (<span class="op">+</span> i <span class="dv">1</span>)))</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>        ((<span class="op">&gt;=</span> i len) <span class="dv">#t</span>)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>      (unless (<span class="kw">zero?</span> (blob-ref buffer i))</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">error</span> &#39;secure-clear-failed)))))</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a><span class="co">;; Key zeroization</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="fu">key-destroy! </span>key)</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;Zeroize key material, audit&quot;</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> ((material (key-material key)))</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    (secure-clear! material)</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    (audit-append actor: (current-principal)</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>                  action: &#39;key-destroyed</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>                  target: (key-id key))</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>    &#39;destroyed))</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a><span class="co">;; Object secure deletion</span></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="fu">object-erase! </span>hash)</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;Securely erase object content&quot;</span></span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> ((path (vault-object-path hash)))</span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; Overwrite with random</span></span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">call-with-output-file</span> path</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">lambda</span> (port)</span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a>        (write-blob port (random-bytes (file-size path)))))</span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; Overwrite with zeros</span></span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">call-with-output-file</span> path</span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">lambda</span> (port)</span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>        (write-blob port (make-blob (file-size path) <span class="dv">0</span>))))</span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; Delete</span></span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">delete-file</span> path)</span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; Audit</span></span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a>    (audit-append actor: (current-principal)</span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a>                  action: &#39;object-erased</span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a>                  target: hash)</span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true" tabindex="-1"></a>    &#39;erased))</span></code></pre></div>
<h3 id="what-cannot-be-erased">What Cannot Be Erased</h3>
<p>Some things must persist:</p>
<table>
<thead>
<tr>
<th>Thing</th>
<th>Why</th>
</tr>
</thead>
<tbody>
<tr>
<td>Audit chain structure</td>
<td>Hash links must verify</td>
</tr>
<tr>
<td>Revocation records</td>
<td>Must prove capability invalid</td>
</tr>
<tr>
<td>Content hashes</td>
<td>May exist in other chains</td>
</tr>
</tbody>
</table>
<p>Redaction, not deletion: the fact that something existed remains, but
the content is gone.</p>
<h3 id="ssdflash-considerations">SSD/Flash Considerations</h3>
<p>Modern storage complicates secure erasure:</p>
<ul>
<li>Wear leveling moves data without notification</li>
<li>Trim/discard doesn’t guarantee overwrite</li>
<li>Encryption is the only reliable approach</li>
</ul>
<p><strong>Our answer:</strong> Encrypt at rest (RFC-030). Erasing the
key erases the data.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">;; With encryption at rest, key destruction = data destruction</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(<span class="fu">secure-erase-encrypted </span>hash)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;For encrypted objects: destroy decryption key&quot;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> ((dek (object-data-encryption-key hash)))</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    (key-destroy! dek)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">;; The ciphertext remains but is now meaningless</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    &#39;erased-via-key-destruction))</span></code></pre></div>
<hr />
<h2 id="the-trusted-core">The Trusted Core</h2>
<p>What must work correctly for security to hold:</p>
<table>
<thead>
<tr>
<th>Component</th>
<th>What It Does</th>
<th>What We Trust</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ed25519</td>
<td>Signatures</td>
<td>libsodium, math</td>
</tr>
<tr>
<td>SHA-512</td>
<td>Object identity</td>
<td>libsodium, math</td>
</tr>
<tr>
<td>Capability verifier</td>
<td>Chain validation</td>
<td>Our code</td>
</tr>
<tr>
<td>Vault storage</td>
<td>Object integrity</td>
<td>Local filesystem</td>
</tr>
<tr>
<td>Audit chain</td>
<td>What happened</td>
<td>Hash chain, signatures</td>
</tr>
<tr>
<td>Soup</td>
<td>Object enumeration</td>
<td>Vault, audit</td>
</tr>
</tbody>
</table>
<p>The core is small. Objects are dumb content. Policy lives in
certificates. Verification is stateless computation.</p>
<h3 id="authoritative-counts">Authoritative Counts</h3>
<p>Object counts MUST come from the TCB. The soup is the authoritative
source for object enumeration - it walks the vault and audit trail.
Counts displayed outside the TCB (prompts, status displays, dashboards)
are advisory only and could be stale or spoofed.</p>
<p>If you need to know how many objects exist, ask the soup. Don’t cache
counts outside the TCB.</p>
<hr />
<h2 id="covert-channels">Covert Channels</h2>
<p>This is where we get serious.</p>
<p>A covert channel is information flow that violates policy - a way to
leak data that bypasses the capability model. They exist in every
system. We analyze ours.</p>
<h3 id="storage-channels">Storage Channels</h3>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 28%" />
<col style="width: 24%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr>
<th>Channel</th>
<th>How It Works</th>
<th>Bandwidth</th>
<th>Mitigation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Object existence</td>
<td>Create/don’t create object as 1/0</td>
<td>~1 bit/op</td>
<td>Bloom filter noise</td>
</tr>
<tr>
<td>Object size</td>
<td>Encode in padding</td>
<td>~10 bits/obj</td>
<td>Size quantization</td>
</tr>
<tr>
<td>Object count</td>
<td>Number of objects in namespace</td>
<td>~4 bits/ns</td>
<td>Rate limiting</td>
</tr>
</tbody>
</table>
<h3 id="timing-channels">Timing Channels</h3>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 28%" />
<col style="width: 24%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr>
<th>Channel</th>
<th>How It Works</th>
<th>Bandwidth</th>
<th>Mitigation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Verification time</td>
<td>Slow/fast response as 1/0</td>
<td>~1 bit/100ms</td>
<td>Constant-time ops</td>
</tr>
<tr>
<td>Network latency</td>
<td>Delay patterns</td>
<td>~10 bits/sec</td>
<td>Batching, Tor</td>
</tr>
<tr>
<td>Audit write time</td>
<td>When entries appear</td>
<td>~1 bit/sec</td>
<td>Async, batched</td>
</tr>
</tbody>
</table>
<h3 id="federation-channels">Federation Channels</h3>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 28%" />
<col style="width: 24%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr>
<th>Channel</th>
<th>How It Works</th>
<th>Bandwidth</th>
<th>Mitigation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sync timing</td>
<td>When objects replicate</td>
<td>~1 bit/sync</td>
<td>Random delays</td>
</tr>
<tr>
<td>Peer selection</td>
<td>Which realms to contact</td>
<td>~4 bits/conn</td>
<td>Randomized peers</td>
</tr>
<tr>
<td>Gossip patterns</td>
<td>Propagation paths</td>
<td>~2 bits/round</td>
<td>Epidemic flooding</td>
</tr>
</tbody>
</table>
<h3 id="analysis">Analysis</h3>
<p><strong>Scenario:</strong> Alice has SECRET access. Bob has
UNCLASSIFIED. Alice wants to leak to Bob.</p>
<p><strong>Via storage:</strong> Alice creates/deletes objects Bob can
see. Each operation signals one bit. Rate: maybe 1 bit/second with
careful timing.</p>
<p><strong>Via timing:</strong> Alice influences verification time of
requests Bob makes. Bob measures. Rate: maybe 0.1 bit/second, noisy.</p>
<p><strong>Via federation:</strong> Alice causes sync events Bob can
observe. Rate: depends on federation config, maybe 0.01 bit/second.</p>
<p><strong>Assessment:</strong> Total covert bandwidth: ~1-2 bits/second
under ideal conditions. Not enough for bulk data. Enough for short
signals. Acceptable residual risk for our threat model.</p>
<h3 id="mitigation-principles">Mitigation Principles</h3>
<pre><code>1. Add noise where practical (bloom filters, random delays)
2. Quantize where observable (object sizes, batch windows)
3. Rate limit where controllable (operations per time)
4. Accept what remains (document it, move on)</code></pre>
<hr />
<h2 id="audit">Audit</h2>
<p>Everything important gets logged.</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>(audit-entry</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  (sequence <span class="dv">12345</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  (timestamp <span class="dv">1736300000</span>)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  (lamport <span class="dv">67890</span>)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  (type capability-exercise)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  (actor <span class="st">&quot;ed25519:subject...&quot;</span>)</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>  (action (<span class="kw">read</span> <span class="st">&quot;sha512:object...&quot;</span>))</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>  (capability <span class="st">&quot;sha512:cert...&quot;</span>)</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>  (previous <span class="st">&quot;sha512:prev-entry...&quot;</span>)</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>  (signature <span class="st">&quot;ed25519:auditor...&quot;</span>))</span></code></pre></div>
<p><strong>Properties:</strong> - Hash-chained: tamper-evident - Signed:
non-repudiable - Monotonic: gaps detected - Distributed: witnesses
replicate</p>
<p><strong>What gets logged:</strong> - Capability creation - Capability
exercise (access) - Capability revocation - Access denials - Object
creation - Realm events (role changes, federation)</p>
<hr />
<h2 id="trusted-path">Trusted Path</h2>
<p>When it matters, talk directly to the core.</p>
<pre><code>┌──────────────────────────────────────┐
│           HUMAN OPERATOR              │
└─────────────────┬────────────────────┘
                  │ Local terminal, no network
┌─────────────────▼────────────────────┐
│          CYBERSPACE REPL              │
│    ╔═════════════════════════════╗   │
│    ║  TRUSTED PATH ACTIVE        ║   │
│    ╚═════════════════════════════╝   │
└─────────────────┬────────────────────┘
                  │
┌─────────────────▼────────────────────┐
│           TRUSTED CORE                │
└──────────────────────────────────────┘</code></pre>
<p>Operations requiring trusted path: - <code>(ed25519-keypair)</code> -
key generation - <code>(node-role 'coordinator)</code> - role assignment
- <code>(seal-release "1.0.0")</code> - signing releases - Key ceremony
(RFC-022)</p>
<hr />
<h2 id="threats">Threats</h2>
<h3 id="what-we-handle">What We Handle</h3>
<table>
<thead>
<tr>
<th>Threat</th>
<th>Defense</th>
</tr>
</thead>
<tbody>
<tr>
<td>Unauthorized access</td>
<td>No capability = no access</td>
</tr>
<tr>
<td>Capability forgery</td>
<td>Ed25519 signatures</td>
</tr>
<tr>
<td>Replay attacks</td>
<td>Timestamps, nonces, Lamport clocks</td>
</tr>
<tr>
<td>Stale capabilities</td>
<td>Expiration, revocation</td>
</tr>
<tr>
<td>Delegation abuse</td>
<td>Attenuation, propagation flags</td>
</tr>
<tr>
<td>Content tampering</td>
<td>SHA-512 content addressing</td>
</tr>
<tr>
<td>Origin spoofing</td>
<td>Object signatures</td>
</tr>
<tr>
<td>Audit tampering</td>
<td>Hash chain, distribution</td>
</tr>
</tbody>
</table>
<h3 id="what-we-dont-handle">What We Don’t Handle</h3>
<table>
<colgroup>
<col style="width: 61%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr>
<th>Threat</th>
<th>Why</th>
</tr>
</thead>
<tbody>
<tr>
<td>Compromised signing key</td>
<td>Fundamental limit. Mitigate: threshold, rotation.</td>
</tr>
<tr>
<td>Endpoint compromise</td>
<td>Your realm, your problem.</td>
</tr>
<tr>
<td>Physical access</td>
<td>Out of scope for software.</td>
</tr>
<tr>
<td>Covert channels &gt; 1 bit/sec</td>
<td>Residual risk, documented above.</td>
</tr>
<tr>
<td>Availability attacks</td>
<td>Focus on integrity/confidentiality.</td>
</tr>
<tr>
<td>Quantum computing</td>
<td>Ed25519 vulnerable. Migration path planned.</td>
</tr>
<tr>
<td>Coercion</td>
<td>Math doesn’t help if you’re forced to sign.</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="the-invariants">The Invariants</h2>
<p>These must always hold:</p>
<pre><code>I1. No access without valid capability
    access(s,o,r) → ∃c: valid_chain(s,o,r,c)

I2. Delegation cannot amplify
    delegated(c₂,c₁) → rights(c₂) ⊆ rights(c₁)

I3. Object identity is content hash
    id(o) = sha512(content(o))

I4. Audit is ordered
    sequence(e₁) &lt; sequence(e₂) → time(e₁) ≤ time(e₂)

I5. Revocation is permanent
    revoked(c,t) → ∀t&#39; &gt; t: ¬valid(c,t&#39;)

I6. No ambient authority
    ¬∃c: grants(c,*,*)</code></pre>
<hr />
<h2 id="references">References</h2>
<ol type="1">
<li>Ellison, C. et al., SPKI Certificate Theory, RFC 2693, 1999</li>
<li>Dennis, J. &amp; Van Horn, E., Programming Semantics for
Multiprogrammed Computations, 1966</li>
<li>Miller, M., Robust Composition, 2006</li>
<li>Lampson, B., A Note on the Confinement Problem, 1973</li>
<li>DoD 5200.28-STD (Orange Book), 1985 - for the covert channel
lens</li>
<li>Bell, D.E. &amp; LaPadula, L.J., Secure Computer Systems:
Mathematical Foundations, 1973 - confidentiality model</li>
<li>Biba, K.J., Integrity Considerations for Secure Computer Systems,
1977 - integrity model</li>
</ol>
<hr />
<h2 id="changelog">Changelog</h2>
<ul>
<li>2026-01-08 - Initial draft</li>
</ul>
</body>
</html>
