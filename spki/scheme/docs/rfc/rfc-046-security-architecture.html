<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RFC-046: Cyberspace Security Architecture</title>
  <link rel="stylesheet" href="rfc.css">
</head>
<body>
<h1>RFC-046: Cyberspace Security Architecture</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This document defines how cyberspace protects itself. The model is simple: capabilities all the way down. Objects are content. Authorization flows through signed certificates. No labels, no ACLs, no ambient authority. You hold a capability or you don't.</p>
<p>We use the rigor of TCSEC B2 as a lens - particularly for covert channel analysis - but cyberspace is its own thing. This is our security architecture, in our language.</p>
</section>
<section>
<h2>The Manifesto</h2>
<blockquote>
<p>Authorized capability set with auditing. No central authority.</p>
</blockquote>
<p>You can have a central authority if you want one. That's up to you. But you don't need one. The architecture doesn't require it. Trust flows from keys you choose to trust, not from a hierarchy imposed upon you.</p>
<p>These principles were proven in VAXcluster security (1984-1994), proposed in SDSI at IETF 29 Seattle (1994), and implemented partially in products that didn't survive their parent companies. Cyberspace completes what was started.</p>
<h3>Design Lineage</h3>
<table>
<tr><th>Era </th><th>System </th><th>Contribution </th></tr>
<tr><td>1984 </td><td>VAXcluster </td><td>"Behave as one" - N nodes, one security domain </td></tr>
<tr><td>1985 </td><td>VMS C2 </td><td>Audit trails, access control, TCSEC security primitives </td></tr>
<tr><td>1993 </td><td>VMS 6.0 </td><td>Cluster-wide intrusion detection, TLV object store </td></tr>
<tr><td>1994 </td><td>SDSI </td><td>Self-certifying keys, local names (Rivest, IETF 29) </td></tr>
<tr><td>1999 </td><td>SPKI </td><td>Authorization certificates, capability delegation </td></tr>
<tr><td>2026 </td><td>Cyberspace </td><td>Synthesis: SPKI + audit + IPv6 mesh + no central authority </td></tr>
</table>
<p>DECnet Phase IV had 24-bit addressing—fatal for internet scale. Cyberspace is designed for IPv6: 128-bit addresses, global mesh, same security principles.</p>
</section>
<section>
<h2>Security Object Types</h2>
<p>Every first-class object in cyberspace. Names as defined.</p>
<p>Table 0: Security Object Registry</p>
<table>
<tr><th>Object </th><th>Defining RFC </th><th>Description </th></tr>
<tr><td>Identity </td></tr>
<tr><td>principal </td><td>RFC-004 </td><td>Cryptographic identity (ed25519 key or hash) </td></tr>
<tr><td>key </td><td>RFC-022 </td><td>Keypair with ceremony provenance </td></tr>
<tr><td>attestation </td><td>RFC-041 </td><td>Signed claim about identity or state </td></tr>
<tr><td>Authorization </td></tr>
<tr><td>certificate </td><td>RFC-004 </td><td>SPKI capability grant </td></tr>
<tr><td>tag </td><td>RFC-004 </td><td>Authorization scope (read, write, etc.) </td></tr>
<tr><td>signature </td><td>RFC-004 </td><td>Ed25519 attestation </td></tr>
<tr><td>share </td><td>RFC-008 </td><td>Shamir secret fragment </td></tr>
<tr><td>quorum </td><td>RFC-036 </td><td>Voting threshold specification </td></tr>
<tr><td>Storage </td></tr>
<tr><td>vault </td><td>RFC-006 </td><td>Sovereign storage realm </td></tr>
<tr><td>object </td><td>RFC-020 </td><td>Content-addressed immutable data </td></tr>
<tr><td>archive </td><td>RFC-018 </td><td>Sealed, encrypted content package </td></tr>
<tr><td>schema </td><td>RFC-033 </td><td>Structure definition </td></tr>
<tr><td>Boundaries </td></tr>
<tr><td>realm </td><td>RFC-040 </td><td>Trust and sovereignty boundary </td></tr>
<tr><td>wormhole </td><td>RFC-041 </td><td>FUSE mount portal to filesystem </td></tr>
<tr><td>federation </td><td>RFC-010 </td><td>Peer network of realms </td></tr>
<tr><td>node </td><td>RFC-037 </td><td>Network participant with role </td></tr>
<tr><td>Execution </td></tr>
<tr><td>agent </td><td>RFC-023 </td><td>Sandboxed daemon </td></tr>
<tr><td>topic </td><td>RFC-035 </td><td>Pub/sub channel </td></tr>
<tr><td>tunnel </td><td>RFC-035 </td><td>Agent communication path </td></tr>
<tr><td>lock </td><td>RFC-035 </td><td>Distributed mutex </td></tr>
<tr><td>Observability </td></tr>
<tr><td>audit-entry </td><td>RFC-003 </td><td>Immutable log record </td></tr>
<tr><td>lamport-clock </td><td>RFC-012 </td><td>Causal ordering timestamp </td></tr>
<tr><td>query </td><td>RFC-025 </td><td>Search expression </td></tr>
<tr><td>Documentation </td></tr>
<tr><td>memo </td><td>RFC-043 </td><td>Scoped documentation unit </td></tr>
<tr><td>soup </td><td>RFC-040 </td><td>The auditable collection of all things </td></tr>
</table>
<h3>Object Properties</h3>
<p>All security objects share:</p>
<pre>
1. Content-addressed identity (SHA-512 hash)
2. Cryptographic signature (Ed25519)
3. Audit trail integration (RFC-003)
4. Capability-gated access (RFC-004)
5. State: chaotic | quiescent
</pre>
<h3>Object State</h3>
<p>All things in cyberspace exist in two states:</p>
<table>
<tr><th>State </th><th>Meaning </th><th>Properties </th></tr>
<tr><td>chaotic </td><td>In flux, being modified </td><td>Mutable, uncommitted, local </td></tr>
<tr><td>quiescent </td><td>At rest, stable </td><td>Immutable, signed, replicable </td></tr>
</table>
<p>Transitions:</p>
<pre>
chaotic ──commit──▶ quiescent
    ▲                   │
    │                   │
    └───── fork ────────┘
</pre>
<p>Only quiescent objects: - Have stable content hashes - Can be signed - Can be replicated - Can be delegated</p>
<p>Chaotic things: - Exist only in the realm's store - Have provisional identity - Cannot be shared - Must settle before federation - Cannot be cached</p>
<h3>Caching Implications</h3>
<p>State controls caching:</p>
<table>
<tr><th>State </th><th>Cacheable </th><th>Reason </th></tr>
<tr><td>quiescent </td><td>Forever </td><td>Hash is identity; immutable </td></tr>
<tr><td>chaotic </td><td>Never </td><td>Content may change; no stable hash </td></tr>
</table>
<p>Quiescent things cache by content hash. Cache hit = identical content, guaranteed. Chaotic things bypass cache entirely. Every access reads current state.</p>
<h3>Persistence</h3>
<p>Persistence is the guarantee of migration to the vault.</p>
<table>
<tr><th>Durability </th><th>Meaning </th></tr>
<tr><td>persistent </td><td>Guaranteed to migrate to vault </td></tr>
<tr><td>ephemeral </td><td>May vanish; no durability promise </td></tr>
</table>
<p>State and durability are orthogonal:</p>
<table>
<tr><th>Ephemeral </th><th>Persistent </th></tr>
<tr><td>Chaotic </td><td>Scratch work </td><td>Draft being saved </td></tr>
<tr><td>Quiescent </td><td>Cached result </td><td>Archived thing </td></tr>
</table>
<p>Persistent things survive restart. Ephemeral things don't.</p>
<p>Vault takes cataloging and effort. Not all things need persistence. Ephemeral is not failure—it's deliberate economy. Cache results, scratch work, intermediate computations: let them vanish.</p>
<p>Marking a thing persistent schedules vault migration.</p>
<pre class="language-scheme">
(persist thing)    ; guarantee vault migration
(ephemeral thing)  ; no durability promise
</pre>
<h3>Object Relationships</h3>
<pre>
principal ──creates──▶ certificate ──grants──▶ tag
    │                      │
    │                      ▼
    │                   object ◀──stores── vault
    │                      │
    ▼                      ▼
  agent ──operates──▶ wormhole ──bridges──▶ realm
    │                                         │
    │                                         ▼
    └──────────────────────────────────▶ federation
</pre>
</section>
<section>
<h2>The Axioms</h2>
<pre>
A1. No Ambient Authority
    You have nothing until someone gives you something.
    Every access requires presenting a capability.

A2. Capabilities Are Unforgeable
    Ed25519 signatures. No exceptions.
    Create by origin or delegation. No other path.

A3. Capabilities Only Attenuate
    Delegation can reduce rights, never amplify.
    What you give cannot exceed what you hold.

A4. Objects Are Immutable Content
    SHA-512 hash IS identity.
    No metadata. No labels. No ACLs.
    Objects don't know who can access them.
</pre>
</section>
<section>
<h2>The Realm</h2>
<p>A realm is your place in cyberspace. It is sovereign.</p>
<pre>
┌─────────────────────────────────────────────────────────────┐
│                        YOUR REALM                            │
│                                                              │
│   Principal: ed25519:a1b2c3...  (this is you)               │
│                                                              │
│   ┌──────────────────────────────────────────────────────┐  │
│   │                      VAULT                            │  │
│   │  Objects:     content-addressed, signed               │  │
│   │  Capabilities: certificates you hold                  │  │
│   │  Audit:       what happened here                      │  │
│   └──────────────────────────────────────────────────────┘  │
│                                                              │
│   Trust boundary: your signing key                          │
│   You decide: what to store, who to trust, what to share    │
└─────────────────────────────────────────────────────────────┘
</pre>
<p>Your realm is local-first. Federation is optional. When you federate, realms overlap - objects flow according to capability chains. But your realm remains yours.</p>
</section>
<section>
<h2>Capabilities</h2>
<h3>The Certificate</h3>
<pre class="language-scheme">
(spki-cert
  (issuer "ed25519:alice...")        ; Who grants
  (subject "ed25519:bob...")         ; Who receives
  (tag (read "sha512:doc..."))       ; What: read this object
  (valid (not-after 1736400000))     ; When: expires in 24h
  (propagate #f)                     ; Bob cannot delegate
  (signature "ed25519:..."))         ; Alice's signature
</pre>
<h3>Access Check</h3>
<pre>
Can Bob read sha512:doc?

1. Does Bob hold a cert granting (read "sha512:doc")?
2. Is the signature valid?
3. Is it expired?
4. Is it revoked?
5. Does the chain trace to someone who could grant it?

All yes? Access granted.
Any no?  Access denied.
</pre>
<h3>Delegation</h3>
<p>Alice can give Bob read access:</p>
<pre class="language-scheme">
(spki-cert
  (issuer "ed25519:alice...")
  (subject "ed25519:bob...")
  (tag (read "sha512:doc..."))
  (propagate #t))                    ; Bob CAN delegate
</pre>
<p>Bob can give Carol read access (because Alice allowed propagation):</p>
<pre class="language-scheme">
(spki-cert
  (issuer "ed25519:bob...")
  (subject "ed25519:carol...")
  (tag (read "sha512:doc..."))
  (propagate #f))                    ; Carol cannot delegate further
</pre>
<p>Carol cannot give anyone else access. The chain stops.</p>
</section>
<section>
<h2>Classification Without Labels</h2>
<p>Traditional MAC puts labels on objects: UNCLASSIFIED, SECRET, TOP SECRET.</p>
<p>In cyberspace, classification is a capability you hold:</p>
<pre class="language-scheme">
;; Security officer grants SECRET clearance
(spki-cert
  (issuer "ed25519:security-officer...")
  (subject "ed25519:analyst...")
  (tag (clearance secret))
  (valid (not-after 1767225600)))    ; Annual renewal

;; Program manager grants compartment access
(spki-cert
  (issuer "ed25519:program-manager...")
  (subject "ed25519:engineer...")
  (tag (compartment "project-atlas")))
</pre>
<p>Access to a classified object requires: 1. Capability to read the object itself 2. Appropriate clearance capability 3. All required compartment capabilities</p>
<p>The object has no labels. The policy lives in the certificates.</p>
</section>
<section>
<h2>Information Flow</h2>
<p>The mathematics of multilevel security, expressed in capabilities.</p>
<h3>The Properties</h3>
<p>Traditional formulations speak of "read up" and "write down" with respect to classification labels. We preserve the mathematics but speak differently:</p>
<table>
<tr><th>Traditional </th><th>Cyberspace </th><th>Formal Statement </th></tr>
<tr><td>"No read up" </td><td>Read requires capability </td><td>∀ read(P,O): P ∈ holders(cap_read(O)) </td></tr>
<tr><td>"No write down" </td><td>Write requires capability </td><td>∀ write(P,O): P ∈ holders(cap_write(O)) </td></tr>
<tr><td>"No read down" </td><td>Integrity via provenance </td><td>∀ accept(P,O): verify(signature(O)) </td></tr>
<tr><td>"No write up" </td><td>Attenuation only </td><td>∀ delegate(P₁,P₂,C): C ⊆ capabilities(P₁) </td></tr>
</table>
<p>The capability graph IS the lattice. Delegation flows down. Authority cannot flow up.</p>
<h3>Confidentiality</h3>
<p>Information flows only through capabilities:</p>
<pre>
∀ read(P,O): P ∈ holders(capread(O))
∀ write(P,O): P ∈ holders(capwrite(O))
∀ delegate(P₁,P₂,C): C ⊆ capabilities(P₁)
</pre>
<p>A principal without read capability cannot observe content. A principal without write capability cannot exfiltrate via storage. Delegation cannot grant what you don't hold.</p>
<h3>Integrity</h3>
<p>Modification flows only through capabilities:</p>
<pre>
∀ modify(P,O): P ∈ holders(capwrite(O))
∀ delegate(P₁,P₂,C'): integrity(C') ≤ integrity(C)
∀ capability C: provenance(C) ⊆ audittrail
</pre>
<p>Objects cannot be corrupted without write capability. Delegated capabilities cannot exceed held capabilities. All grants are traceable.</p>
<h3>Confinement</h3>
<p>The capability discipline eliminates ambient authority:</p>
<pre>
∀ access(P,O): ∃ C ∈ capabilities(P): authorizes(C,O)
∀ C: unforgeable(C)
∀ acquire(P,C): ∃ P': delegate(P',P,C) ∨ create(P,O)
</pre>
<p>No access without explicit capability. Capabilities cannot be manufactured. The only paths: receive via delegation, or create the object.</p>
<h3>Wormhole Enforcement</h3>
<p>Wormholes (RFC-041) are channel boundaries. Information flow is enforced at every crossing:</p>
<pre class="language-scheme">
(wormhole-flow-guard wormhole operation object)
  ;; Checks:
  ;; 1. wormhole has capabilities (no ambient authority)
  ;; 2. operation permitted by held capabilities
  ;; 3. audit entry created
</pre>
<table>
<tr><th>Operation </th><th>Required Capability </th><th>Violation Type </th></tr>
<tr><td>read, stat, readdir </td><td>read </td><td>confidentiality </td></tr>
<tr><td>write, create, chmod </td><td>write </td><td>integrity </td></tr>
<tr><td>delete, unlink </td><td>delete </td><td>integrity </td></tr>
<tr><td>delegate </td><td>delegate </td><td>amplification </td></tr>
</table>
<p>Denied operations raise typed errors: - no-ambient-authority — wormhole has no capabilities - read-denied — missing read capability - write-denied — missing write capability - capability-amplification — delegation exceeds held</p>
<h3>The Lattice</h3>
<p>Capabilities form a partial order. The lattice:</p>
<pre>
        full
          │
    ┌─────┼─────┐
    │     │     │
  admin synch read-write
    │     │     │
    └─────┼─────┘
          │
      read-only
          │
        none
</pre>
<p>Delegation can only move DOWN the lattice. This is attenuation. You cannot delegate admin if you hold read-only. You cannot grant write if you hold read.</p>
<p>The math is sound. We just speak it in capabilities.</p>
</section>
<section>
<h2>Secure Erasure</h2>
<p>When sensitive data must be destroyed, it must be destroyed completely.</p>
<h3>Erasure Requirements</h3>
<table>
<tr><th>What </th><th>How </th><th>Verification </th></tr>
<tr><td>Object content </td><td>Overwrite with random, then zeros </td><td>Read-back verify </td></tr>
<tr><td>Memory buffers </td><td>Secure memset, compiler barrier </td><td>Not optimized away </td></tr>
<tr><td>Key material </td><td>Zeroize immediately after use </td><td>Audit trail entry </td></tr>
<tr><td>Audit entries </td><td>Preserve hash chain, redact content </td><td>Chain integrity </td></tr>
<tr><td>Capability certs </td><td>Revoke, then destroy </td><td>Revocation published </td></tr>
</table>
<h3>Erasure Guarantees</h3>
<pre>
E1. Zeroization is atomic
    erase(o) → ¬recoverable(o)

E2. Memory clearing defeats inspection
    clear(buffer) → ∀ address ∈ buffer: read(address) = 0

E3. Key destruction is immediate
    destroy(key) → ¬usable(key) ∧ audit(destroyed, key)

E4. Revocation propagates
    revoke(cert) → ∀ delegate(cert, c'): revoke(c')
</pre>
<h3>Implementation</h3>
<pre class="language-scheme">
;; Secure memory clearing (defeats compiler optimization)
(define (secure-clear! buffer)
  "Overwrite buffer with zeros, verify"
  (let ((len (blob-size buffer)))
    ;; Write zeros
    (do ((i 0 (+ i 1)))
        ((&gt;= i len))
      (blob-set! buffer i 0))
    ;; Memory barrier (implementation-specific)
    ;; Verify
    (do ((i 0 (+ i 1)))
        ((&gt;= i len) #t)
      (unless (zero? (blob-ref buffer i))
        (error 'secure-clear-failed)))))

;; Key zeroization
(define (key-destroy! key)
  "Zeroize key material, audit"
  (let ((material (key-material key)))
    (secure-clear! material)
    (audit-append actor: (current-principal)
                  action: 'key-destroyed
                  target: (key-id key))
    'destroyed))

;; Object secure deletion
(define (object-erase! hash)
  "Securely erase object content"
  (let ((path (vault-object-path hash)))
    ;; Overwrite with random
    (call-with-output-file path
      (lambda (port)
        (write-blob port (random-bytes (file-size path)))))
    ;; Overwrite with zeros
    (call-with-output-file path
      (lambda (port)
        (write-blob port (make-blob (file-size path) 0))))
    ;; Delete
    (delete-file path)
    ;; Audit
    (audit-append actor: (current-principal)
                  action: 'object-erased
                  target: hash)
    'erased))
</pre>
<h3>What Cannot Be Erased</h3>
<p>Some things must persist:</p>
<table>
<tr><th>Thing </th><th>Why </th></tr>
<tr><td>Audit chain structure </td><td>Hash links must verify </td></tr>
<tr><td>Revocation records </td><td>Must prove capability invalid </td></tr>
<tr><td>Content hashes </td><td>May exist in other chains </td></tr>
</table>
<p>Redaction, not deletion: the fact that something existed remains, but the content is gone.</p>
<h3>SSD/Flash Considerations</h3>
<p>Modern storage complicates secure erasure:</p>
<p>- Wear leveling moves data without notification - Trim/discard doesn't guarantee overwrite - Encryption is the only reliable approach</p>
<p>Our answer: Encrypt at rest (RFC-030). Erasing the key erases the data.</p>
<pre class="language-scheme">
;; With encryption at rest, key destruction = data destruction
(define (secure-erase-encrypted hash)
  "For encrypted objects: destroy decryption key"
  (let ((dek (object-data-encryption-key hash)))
    (key-destroy! dek)
    ;; The ciphertext remains but is now meaningless
    'erased-via-key-destruction))
</pre>
</section>
<section>
<h2>The Trusted Core</h2>
<p>What must work correctly for security to hold:</p>
<table>
<tr><th>Component </th><th>What It Does </th><th>What We Trust </th></tr>
<tr><td>Ed25519 </td><td>Signatures </td><td>libsodium, math </td></tr>
<tr><td>SHA-512 </td><td>Object identity </td><td>libsodium, math </td></tr>
<tr><td>Capability verifier </td><td>Chain validation </td><td>Our code </td></tr>
<tr><td>Vault storage </td><td>Object integrity </td><td>Local filesystem </td></tr>
<tr><td>Audit chain </td><td>What happened </td><td>Hash chain, signatures </td></tr>
<tr><td>Soup </td><td>Object enumeration </td><td>Vault, audit </td></tr>
</table>
<p>The core is small. Objects are dumb content. Policy lives in certificates. Verification is stateless computation.</p>
<h3>Authoritative Counts</h3>
<p>Object counts MUST come from the TCB. The soup is the authoritative source for object enumeration - it walks the vault and audit trail. Counts displayed outside the TCB (prompts, status displays, dashboards) are advisory only and could be stale or spoofed.</p>
<p>If you need to know how many objects exist, ask the soup. Don't cache counts outside the TCB.</p>
</section>
<section>
<h2>Covert Channels</h2>
<p>This is where we get serious.</p>
<p>A covert channel is information flow that violates policy - a way to leak data that bypasses the capability model. They exist in every system. We analyze ours.</p>
<h3>Storage Channels</h3>
<table>
<tr><th>Channel </th><th>How It Works </th><th>Bandwidth </th><th>Mitigation </th></tr>
<tr><td>Object existence </td><td>Create/don't create object as 1/0 </td><td>~1 bit/op </td><td>Bloom filter noise </td></tr>
<tr><td>Object size </td><td>Encode in padding </td><td>~10 bits/obj </td><td>Size quantization </td></tr>
<tr><td>Object count </td><td>Number of objects in namespace </td><td>~4 bits/ns </td><td>Rate limiting </td></tr>
</table>
<h3>Timing Channels</h3>
<table>
<tr><th>Channel </th><th>How It Works </th><th>Bandwidth </th><th>Mitigation </th></tr>
<tr><td>Verification time </td><td>Slow/fast response as 1/0 </td><td>~1 bit/100ms </td><td>Constant-time ops </td></tr>
<tr><td>Network latency </td><td>Delay patterns </td><td>~10 bits/sec </td><td>Batching, Tor </td></tr>
<tr><td>Audit write time </td><td>When entries appear </td><td>~1 bit/sec </td><td>Async, batched </td></tr>
</table>
<h3>Federation Channels</h3>
<table>
<tr><th>Channel </th><th>How It Works </th><th>Bandwidth </th><th>Mitigation </th></tr>
<tr><td>Sync timing </td><td>When objects replicate </td><td>~1 bit/sync </td><td>Random delays </td></tr>
<tr><td>Peer selection </td><td>Which realms to contact </td><td>~4 bits/conn </td><td>Randomized peers </td></tr>
<tr><td>Gossip patterns </td><td>Propagation paths </td><td>~2 bits/round </td><td>Epidemic flooding </td></tr>
</table>
<h3>Analysis</h3>
<p>Scenario: Alice has SECRET access. Bob has UNCLASSIFIED. Alice wants to leak to Bob.</p>
<p>Via storage: Alice creates/deletes objects Bob can see. Each operation signals one bit. Rate: maybe 1 bit/second with careful timing.</p>
<p>Via timing: Alice influences verification time of requests Bob makes. Bob measures. Rate: maybe 0.1 bit/second, noisy.</p>
<p>Via federation: Alice causes sync events Bob can observe. Rate: depends on federation config, maybe 0.01 bit/second.</p>
<p>Assessment: Total covert bandwidth: ~1-2 bits/second under ideal conditions. Not enough for bulk data. Enough for short signals. Acceptable residual risk for our threat model.</p>
<h3>Mitigation Principles</h3>
<pre>
1. Add noise where practical (bloom filters, random delays)
2. Quantize where observable (object sizes, batch windows)
3. Rate limit where controllable (operations per time)
4. Accept what remains (document it, move on)
</pre>
</section>
<section>
<h2>Audit</h2>
<p>Everything important gets logged.</p>
<pre class="language-scheme">
(audit-entry
  (sequence 12345)
  (timestamp 1736300000)
  (lamport 67890)
  (type capability-exercise)
  (actor "ed25519:subject...")
  (action (read "sha512:object..."))
  (capability "sha512:cert...")
  (previous "sha512:prev-entry...")
  (signature "ed25519:auditor..."))
</pre>
<p>Properties: - Hash-chained: tamper-evident - Signed: non-repudiable - Monotonic: gaps detected - Distributed: witnesses replicate</p>
<p>What gets logged: - Capability creation - Capability exercise (access) - Capability revocation - Access denials - Object creation - Realm events (role changes, federation)</p>
</section>
<section>
<h2>Trusted Path</h2>
<p>When it matters, talk directly to the core.</p>
<pre>
┌──────────────────────────────────────┐
│           HUMAN OPERATOR              │
└─────────────────┬────────────────────┘
                  │ Local terminal, no network
┌─────────────────▼────────────────────┐
│          CYBERSPACE REPL              │
│    ╔═════════════════════════════╗   │
│    ║  TRUSTED PATH ACTIVE        ║   │
│    ╚═════════════════════════════╝   │
└─────────────────┬────────────────────┘
                  │
┌─────────────────▼────────────────────┐
│           TRUSTED CORE                │
└──────────────────────────────────────┘
</pre>
<p>Operations requiring trusted path: - (ed25519-keypair) - key generation - (node-role 'coordinator) - role assignment - (seal-release "1.0.0") - signing releases - Key ceremony (RFC-022)</p>
</section>
<section>
<h2>Threats</h2>
<h3>What We Handle</h3>
<table>
<tr><th>Threat </th><th>Defense </th></tr>
<tr><td>Unauthorized access </td><td>No capability = no access </td></tr>
<tr><td>Capability forgery </td><td>Ed25519 signatures </td></tr>
<tr><td>Replay attacks </td><td>Timestamps, nonces, Lamport clocks </td></tr>
<tr><td>Stale capabilities </td><td>Expiration, revocation </td></tr>
<tr><td>Delegation abuse </td><td>Attenuation, propagation flags </td></tr>
<tr><td>Content tampering </td><td>SHA-512 content addressing </td></tr>
<tr><td>Origin spoofing </td><td>Object signatures </td></tr>
<tr><td>Audit tampering </td><td>Hash chain, distribution </td></tr>
</table>
<h3>What We Don't Handle</h3>
<table>
<tr><th>Threat </th><th>Why </th></tr>
<tr><td>Compromised signing key </td><td>Fundamental limit. Mitigate: threshold, rotation. </td></tr>
<tr><td>Endpoint compromise </td><td>Your realm, your problem. </td></tr>
<tr><td>Physical access </td><td>Out of scope for software. </td></tr>
<tr><td>Covert channels &gt; 1 bit/sec </td><td>Residual risk, documented above. </td></tr>
<tr><td>Availability attacks </td><td>Focus on integrity/confidentiality. </td></tr>
<tr><td>Quantum computing </td><td>Ed25519 vulnerable. Migration path planned. </td></tr>
<tr><td>Coercion </td><td>Math doesn't help if you're forced to sign. </td></tr>
</table>
</section>
<section>
<h2>The Invariants</h2>
<p>These must always hold:</p>
<pre>
I1. No access without valid capability
    access(s,o,r) → ∃c: valid_chain(s,o,r,c)

I2. Delegation cannot amplify
    delegated(c₂,c₁) → rights(c₂) ⊆ rights(c₁)

I3. Object identity is content hash
    id(o) = sha512(content(o))

I4. Audit is ordered
    sequence(e₁) &lt; sequence(e₂) → time(e₁) ≤ time(e₂)

I5. Revocation is permanent
    revoked(c,t) → ∀t' &gt; t: ¬valid(c,t')

I6. No ambient authority
    ¬∃c: grants(c,,)
</pre>
</section>
<section>
<h2>References</h2>
<p>1. Ellison, C. et al., SPKI Certificate Theory, RFC 2693, 1999 2. Dennis, J. &amp; Van Horn, E., Programming Semantics for Multiprogrammed Computations, 1966 3. Miller, M., Robust Composition, 2006 4. Lampson, B., A Note on the Confinement Problem, 1973 5. DoD 5200.28-STD (Orange Book), 1985 - for the covert channel lens 6. Bell, D.E. &amp; LaPadula, L.J., Secure Computer Systems: Mathematical Foundations, 1973 - confidentiality model 7. Biba, K.J., Integrity Considerations for Secure Computer Systems, 1977 - integrity model</p>
</section>
<section>
<h2>Changelog</h2>
<p>- 2026-01-08 - Initial draft</p>
</section>
</body>
</html>
