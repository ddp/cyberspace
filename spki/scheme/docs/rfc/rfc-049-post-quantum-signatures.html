<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RFC-049: Post-Quantum Signatures</title>
  <link rel="stylesheet" href="rfc.css">
</head>
<body>
<h1>RFC-049: Post-Quantum Signatures</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>Ed25519 won't survive. Shor's algorithm breaks elliptic curve cryptography in polynomial time. When quantum computers arrive, every capability ever signed, every realm identity ever created, becomes forgeable. This RFC specifies the transition from Ed25519 to post-quantum signature schemes: SPHINCS+ and CRYSTALS-Dilithium.</p>
</section>
<section>
<h2>The Threat</h2>
<p>Ed25519 security relies on the hardness of the elliptic curve discrete logarithm problem. Shor's algorithm solves this in polynomial time on a quantum computer.</p>
<table>
<tr><th>Algorithm </th><th>Classical Security </th><th>Quantum Security </th></tr>
<tr><td>Ed25519 </td><td>128 bits </td><td>0 bits (broken) </td></tr>
<tr><td>RSA-2048 </td><td>112 bits </td><td>0 bits (broken) </td></tr>
<tr><td>SPHINCS+-256 </td><td>256 bits </td><td>128 bits </td></tr>
<tr><td>Dilithium3 </td><td>192 bits </td><td>128 bits </td></tr>
</table>
<p>When Q-Day arrives: - Every Ed25519 signature becomes forgeable - Every SPKI certificate can be counterfeited - Every realm identity can be stolen - Every sealed release can be replaced</p>
<p>The capability chain breaks. The sealed closure unseals. Cyberspace falls.</p>
<p>We must migrate before Q-Day.</p>
</section>
<section>
<h2>The Candidates</h2>
<p>NIST Post-Quantum Cryptography standardization selected:</p>
<h3>SPHINCS+ (Hash-Based)</h3>
<pre>
Type:           Stateless hash-based signatures
Security basis: Hash function security (SHAKE256)
Key size:       32 bytes (private), 32 bytes (public)
Signature size: 7,856 - 49,856 bytes (parameter dependent)
Speed:          Slow signing, fast verification
Maturity:       Conservative, well-understood
</pre>
<p>Why SPHINCS+: - Security reduces to hash function security - No number-theoretic assumptions - Stateless (no state management headaches) - Uses SHAKE256 (same as our Merkle trees)</p>
<p>Tradeoff: Large signatures. A SPHINCS+-256s signature is ~8 KB.</p>
<h3>CRYSTALS-Dilithium (Lattice-Based)</h3>
<pre>
Type:           Lattice-based (Module-LWE)
Security basis: Learning With Errors hardness
Key size:       1,312 bytes (private), 1,952 bytes (public)
Signature size: 2,420 - 4,595 bytes (parameter dependent)
Speed:          Fast signing, fast verification
Maturity:       Newer, but extensively analyzed
</pre>
<p>Why Dilithium: - Smaller signatures than SPHINCS+ - Faster operations - NIST primary recommendation</p>
<p>Tradeoff: Relies on lattice assumptions (less conservative than hash-based).</p>
</section>
<section>
<h2>Cyberspace Strategy: Both</h2>
<p>We support both. Different use cases, different tradeoffs:</p>
<table>
<tr><th>Use Case </th><th>Recommended </th><th>Why </th></tr>
<tr><td>Realm identity (keystore) </td><td>SPHINCS+ </td><td>Maximum conservatism for long-lived keys </td></tr>
<tr><td>Capability certificates </td><td>Dilithium </td><td>Smaller signatures, many certs </td></tr>
<tr><td>Sealed releases </td><td>SPHINCS+ </td><td>Archival, must survive </td></tr>
<tr><td>Agent delegation </td><td>Dilithium </td><td>Short-lived, performance matters </td></tr>
<tr><td>Audit entries </td><td>Dilithium </td><td>High volume </td></tr>
</table>
<p>The keystore can hold multiple key types:</p>
<pre class="language-scheme">
(keystore
  (realm-keys
    (ed25519 #${legacy-key...})           ; Legacy (sunset)
    (sphincs+ #${pq-primary...})          ; Post-quantum primary
    (dilithium #${pq-operational...}))    ; Post-quantum operational
  (active-signing 'sphincs+)
  (accept-verification '(sphincs+ dilithium ed25519)))
</pre>
</section>
<section>
<h2>Certificate Format</h2>
<h3>Current (Ed25519)</h3>
<pre class="language-scheme">
(spki-cert
  (issuer "ed25519:alice...")
  (subject "ed25519:bob...")
  (tag (read "sha512:doc..."))
  (signature #${64-byte-ed25519-sig}))
</pre>
<h3>Post-Quantum (SPHINCS+)</h3>
<pre class="language-scheme">
(spki-cert
  (issuer "sphincs+:alice...")
  (subject "sphincs+:bob...")
  (tag (read "shake256:doc..."))           ; Merkle root
  (signature-algorithm "sphincs+-shake-256s")
  (signature #${7856-byte-sphincs-sig}))
</pre>
<h3>Post-Quantum (Dilithium)</h3>
<pre class="language-scheme">
(spki-cert
  (issuer "dilithium:alice...")
  (subject "dilithium:bob...")
  (tag (read "shake256:doc..."))
  (signature-algorithm "dilithium3")
  (signature #${3293-byte-dilithium-sig}))
</pre>
<h3>Hybrid (Transition)</h3>
<p>During transition, sign with both:</p>
<pre class="language-scheme">
(spki-cert
  (issuer "hybrid:alice...")               ; Hybrid identity
  (subject "hybrid:bob...")
  (tag (read "shake256:doc..."))
  (signatures
    (ed25519 #${64-byte-sig})              ; Legacy
    (sphincs+ #${7856-byte-sig})))         ; Post-quantum
</pre>
<p>Both signatures must verify. If Ed25519 is later broken, SPHINCS+ still holds.</p>
</section>
<section>
<h2>Key Generation</h2>
<h3>SPHINCS+-SHAKE-256s</h3>
<pre class="language-scheme">
(define (sphincs+-keygen)
  "Generate SPHINCS+ keypair using SHAKE256"
  (let* ((seed (random-bytes 96))          ; 3 × 32-byte seeds
         (sk-seed (subbytevector seed 0 32))
         (sk-prf (subbytevector seed 32 64))
         (pk-seed (subbytevector seed 64 96))
         (keypair (sphincs+-generate sk-seed sk-prf pk-seed)))
    keypair))

;; Keystore storage (encrypted)
(realm-private-key
  (version 1)
  (algorithm "sphincs+-shake-256s")
  (parameters
    (n 32)                                 ; Security parameter
    (h 64)                                 ; Tree height
    (d 8)                                  ; Hypertree layers
    (k 22)                                 ; FORS trees
    (w 16))                                ; Winternitz parameter
  (protection "passphrase")
  (kdf "argon2id")
  (ciphertext #${encrypted-sk}))
</pre>
<h3>Dilithium3</h3>
<pre class="language-scheme">
(define (dilithium-keygen)
  "Generate Dilithium3 keypair"
  (let* ((seed (random-bytes 32))
         (keypair (dilithium3-generate seed)))
    keypair))

(realm-private-key
  (version 1)
  (algorithm "dilithium3")
  (parameters
    (k 6)                                  ; Module dimension
    (l 5)
    (eta 4)
    (beta 175)
    (omega 55))
  (protection "passphrase")
  (kdf "argon2id")
  (ciphertext #${encrypted-sk}))
</pre>
</section>
<section>
<h2>Signing Operations</h2>
<h3>SPHINCS+ Signing</h3>
<pre class="language-scheme">
(define (sphincs+-sign message private-key)
  "Sign message with SPHINCS+"
  (let* ((opt-rand (random-bytes 32))      ; Optional randomness
         (signature (sphincs+-sign-internal message private-key opt-rand)))
    signature))

;; Signature is large: 7,856 bytes for SPHINCS+-SHAKE-256s
</pre>
<h3>Dilithium Signing</h3>
<pre class="language-scheme">
(define (dilithium-sign message private-key)
  "Sign message with Dilithium3"
  (let* ((signature (dilithium3-sign-internal message private-key)))
    signature))

;; Signature is moderate: 3,293 bytes for Dilithium3
</pre>
<h3>Hybrid Signing</h3>
<pre class="language-scheme">
(define (hybrid-sign message ed25519-sk sphincs+-sk)
  "Sign with both algorithms for transition security"
  (let ((ed25519-sig (ed25519-sign message ed25519-sk))
        (sphincs+-sig (sphincs+-sign message sphincs+-sk)))
    `(hybrid-signature
      (ed25519 ,ed25519-sig)
      (sphincs+ ,sphincs+-sig))))
</pre>
</section>
<section>
<h2>Verification</h2>
<h3>Multi-Algorithm Verification</h3>
<pre class="language-scheme">
(define (verify-signature message signature public-key)
  "Verify signature, handling multiple algorithms"
  (let ((algorithm (signature-algorithm signature)))
    (case algorithm
      ((ed25519) (ed25519-verify message (sig-bytes signature) public-key))
      ((sphincs+) (sphincs+-verify message (sig-bytes signature) public-key))
      ((dilithium) (dilithium-verify message (sig-bytes signature) public-key))
      ((hybrid) (verify-hybrid message signature public-key))
      (else (error "Unknown signature algorithm" algorithm)))))

(define (verify-hybrid message signature public-keys)
  "Both signatures must verify"
  (and (ed25519-verify message (hybrid-ed25519 signature) (keys-ed25519 public-keys))
       (sphincs+-verify message (hybrid-sphincs+ signature) (keys-sphincs+ public-keys))))
</pre>
</section>
<section>
<h2>Realm Identity</h2>
<p>A realm's principal expands to include algorithm:</p>
<pre>
Current:   ed25519:7f3a2b4c5d6e...
Future:    sphincs+:8a9b0c1d2e3f...
           dilithium:4e5f6a7b8c9d...
           hybrid:7f3a2b4c|8a9b0c1d...
</pre>
<p>The principal is still coordinates in cyberspace - a place you can teleport to. The algorithm prefix tells you what cryptography guards the gate.</p>
</section>
<section>
<h2>Capability Chain Implications</h2>
<p>Capability chains must handle mixed algorithms:</p>
<pre class="language-scheme">
;; Alice (Ed25519) delegates to Bob (Dilithium) who delegates to Carol (SPHINCS+)
(cert-chain
  (cert-1
    (issuer "ed25519:alice...")
    (subject "dilithium:bob...")
    (signature #${ed25519-sig}))
  (cert-2
    (issuer "dilithium:bob...")
    (subject "sphincs+:carol...")
    (signature #${dilithium-sig})))
</pre>
<p>Each link verified with its own algorithm. The chain is as strong as its weakest link - but even one post-quantum link prevents total collapse after Q-Day.</p>
</section>
<section>
<h2>Migration Timeline</h2>
<h3>Phase 1: Preparation (Now)</h3>
<p>- Implement SPHINCS+ and Dilithium in crypto-ffi - Add multi-algorithm support to keystore - Test hybrid signatures</p>
<h3>Phase 2: Hybrid Default (Now + 1 year)</h3>
<p>- New realms generate hybrid keys (Ed25519 + SPHINCS+) - All signatures include both - Legacy realms can upgrade</p>
<h3>Phase 3: Post-Quantum Primary (Q-Day - 3 years)</h3>
<p>- SPHINCS+/Dilithium become primary - Ed25519 becomes secondary - Capability chains require at least one PQ signature</p>
<h3>Phase 4: Legacy Sunset (Q-Day)</h3>
<p>- Ed25519 signatures no longer trusted - Hybrid signatures verified by PQ component only - Legacy-only realms frozen (read-only)</p>
<h3>Phase 5: Pure Post-Quantum (Q-Day + 2 years)</h3>
<p>- Ed25519 removed from new certificates - Historical certificates retain for audit - Cyberspace survives</p>
</section>
<section>
<h2>Storage Implications</h2>
<p>Post-quantum signatures are larger:</p>
<table>
<tr><th>Component </th><th>Ed25519 </th><th>Dilithium3 </th><th>SPHINCS+-256s </th></tr>
<tr><td>Public key </td><td>32 B </td><td>1,952 B </td><td>32 B </td></tr>
<tr><td>Private key </td><td>64 B </td><td>4,000 B </td><td>128 B </td></tr>
<tr><td>Signature </td><td>64 B </td><td>3,293 B </td><td>7,856 B </td></tr>
<tr><td>Cert overhead </td><td>~200 B </td><td>~3,500 B </td><td>~8,100 B </td></tr>
</table>
<p>A realm with 10,000 capabilities: - Ed25519: ~2 MB - Dilithium: ~35 MB - SPHINCS+: ~81 MB</p>
<p>Storage is cheap. Quantum resistance is not.</p>
</section>
<section>
<h2>Performance</h2>
<table>
<tr><th>Operation </th><th>Ed25519 </th><th>Dilithium3 </th><th>SPHINCS+-256s </th></tr>
<tr><td>Keygen </td><td>0.03 ms </td><td>0.15 ms </td><td>2 ms </td></tr>
<tr><td>Sign </td><td>0.05 ms </td><td>0.5 ms </td><td>50 ms </td></tr>
<tr><td>Verify </td><td>0.1 ms </td><td>0.3 ms </td><td>1 ms </td></tr>
</table>
<p>SPHINCS+ signing is slow (50ms). Acceptable for: - Realm identity (rare) - Sealed releases (rare) - Capability grants (occasional)</p>
<p>Use Dilithium for: - Agent delegation (frequent) - Audit entries (constant) - Bulk operations</p>
</section>
<section>
<h2>Library Support</h2>
<h3>Required Libraries</h3>
<table>
<tr><th>Library </th><th>SPHINCS+ </th><th>Dilithium </th><th>Notes </th></tr>
<tr><td>liboqs </td><td>Yes </td><td>Yes </td><td>Open Quantum Safe project </td></tr>
<tr><td>libsodium </td><td>No </td><td>No </td><td>Not yet </td></tr>
<tr><td>OpenSSL 3.x </td><td>Provider </td><td>Provider </td><td>Via oqsprovider </td></tr>
<tr><td>BoringSSL </td><td>No </td><td>Partial </td><td>Google internal </td></tr>
</table>
<p>Recommended: liboqs (Open Quantum Safe) - Reference implementations - Actively maintained - C library, easy FFI</p>
<pre class="language-scheme">
;; crypto-ffi.scm addition
(define sphincs+-sign (foreign-lambda ...))
(define sphincs+-verify (foreign-lambda ...))
(define dilithium-sign (foreign-lambda ...))
(define dilithium-verify (foreign-lambda ...))
</pre>
</section>
<section>
<h2>Security Considerations</h2>
<h3>Algorithm Agility</h3>
<p>Cyberspace must survive algorithm obsolescence:</p>
<pre class="language-scheme">
(define supported-algorithms
  '((signatures . (ed25519 sphincs+ dilithium))
    (hashes . (sha512 shake256 blake3))
    (encryption . (xchacha20-poly1305 aes-256-gcm))))

(define (algorithm-status alg)
  (case alg
    ((ed25519) 'deprecated)    ; Quantum-vulnerable
    ((sphincs+) 'recommended)  ; Post-quantum, conservative
    ((dilithium) 'recommended) ; Post-quantum, performant
    ((sha512) 'legacy)         ; Quantum-reduced
    ((shake256) 'recommended)  ; Post-quantum
    ...))
</pre>
<h3>Side Channels</h3>
<p>Post-quantum implementations must be constant-time: - SPHINCS+: Hash operations are naturally constant-time - Dilithium: Requires careful NTT implementation</p>
<p>Use only audited implementations (liboqs reference, or formally verified).</p>
<h3>Hybrid Security</h3>
<p>During transition, hybrid signatures provide defense in depth: - If Ed25519 is broken → SPHINCS+ holds - If SPHINCS+ has unknown flaw → Ed25519 holds (pre-Q-Day)</p>
<p>Both must be broken to forge. Belt and suspenders.</p>
</section>
<section>
<h2>Invariants</h2>
<pre>
S1. Post-quantum signatures are unforgeable (given hash security)
    forge(sphincs+-sig) requires break(shake256)

S2. Hybrid requires both valid
    valid(hybrid-sig) ↔ valid(ed25519-sig) ∧ valid(pq-sig)

S3. Algorithm indicated in signature
    verify(sig) uses algorithm(sig), not ambient config

S4. Key algorithm matches signature algorithm
    sign(sphincs+-key, msg) produces sphincs+-signature

S5. Migration preserves capability validity
    valid-pre-migration(cert) → valid-post-migration(cert) [during transition]
</pre>
</section>
<section>
<h2>The Quantum Winter</h2>
<p>Q-Day is coming. We don't know when - estimates range from 2030 to 2040. But the harvest-now-decrypt-later threat is real today. Every Ed25519 signature captured now can be forged after Q-Day.</p>
<p>Cyberspace is built to last. The Library of Alexandria must not burn twice.</p>
<p>When the quantum winter comes: - Merkle trees (RFC-042) protect object identity - SPHINCS+/Dilithium protect signatures - The sealed closure remains sealed - The wilderness of mirrors endures</p>
<p>Prepare now. Migrate early. Survive.</p>
</section>
<section>
<h2>References</h2>
<p>1. NIST Post-Quantum Cryptography Standardization 2. SPHINCS+ specification - https://sphincs.org/ 3. CRYSTALS-Dilithium specification - https://pq-crystals.org/dilithium/ 4. Open Quantum Safe project - https://openquantumsafe.org/ 5. Shor, P., "Algorithms for Quantum Computation", 1994 6. RFC-041 - Keystore and Attestation 7. RFC-042 - Quantum-Resistant Merkle Trees</p>
</section>
<section>
<h2>Changelog</h2>
<p>- 2026-01-08 - Initial draft</p>
</section>
</body>
</html>
