<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <title>RFC-032: Rate Limiting and Quotas</title>
  <link rel="stylesheet" href="rfc.css">
</head>
<body>
<span class="theme-toggle" onclick="toggleTheme()" title="Toggle light/dark">[theme]</span>
<h1>RFC-032: Rate Limiting and Quotas</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This RFC specifies rate limiting and quotas for the Library of Cyberspace: how vaults protect themselves from abuse while ensuring fair access for legitimate users. Limits are capability-aware and auditable.</p>
</section>
<section>
<h2>Motivation</h2>
<p>Shared resources require protection:</p>
<ul>
<li>Denial of Service</li>
<li>Malicious overload</li>
<li>Resource exhaustion</li>
<li>Runaway processes</li>
<li>Fair sharing</li>
<li>Equal access for all users</li>
<li>Cost control</li>
<li>Prevent unbounded consumption</li>
</ul>
<p>Limits must be:</p>
<ul>
<li>Configurable</li>
<li>Different limits for different principals</li>
<li>Graceful</li>
<li>Degrade smoothly, don't cliff</li>
<li>Transparent</li>
<li>Users know their limits</li>
<li>Auditable</li>
<li>All limiting decisions logged</li>
</ul>
</section>
<section>
<h2>Rate Limiting</h2>
<h3>Token Bucket Algorithm</h3>
<pre class="language-scheme">
(define (make-token-bucket capacity fill-rate)
  "Create token bucket rate limiter"
  (let ((tokens capacity)
        (last-fill (current-time-ms)))

    (lambda (cost)
      ;; Refill tokens based on elapsed time
      (let ((now (current-time-ms))
             (elapsed (- now last-fill))
             (new-tokens (+ tokens ( fill-rate (/ elapsed 1000)))))
        (set! tokens (min capacity new-tokens))
        (set! last-fill now)

        ;; Try to consume tokens
        (if (&gt;= tokens cost)
            (begin
              (set! tokens (- tokens cost))
              #t)  ; Allowed
            #f))))) ; Denied

;; Example: 100 requests per second, burst of 200
(define request-limiter (make-token-bucket 200 100))
</pre>
<h3>Sliding Window</h3>
<pre class="language-scheme">
(define (make-sliding-window size interval)
  "Sliding window rate limiter"
  (let ((events (make-deque)))

    (lambda ()
      ;; Remove old events
      (let ((cutoff (- (current-time-ms) interval)))
        (while (and (not (deque-empty? events))
                    (&lt; (deque-front events) cutoff))
          (deque-pop-front! events)))

      ;; Check if under limit
      (if (&lt; (deque-length events) size)
          (begin
            (deque-push-back! events (current-time-ms))
            #t)
          #f))))
</pre>
<h3>Leaky Bucket</h3>
<pre class="language-scheme">
(define (make-leaky-bucket capacity leak-rate)
  "Leaky bucket for smoothing bursts"
  (let ((level 0)
        (last-leak (current-time-ms)))

    (lambda (amount)
      ;; Leak based on elapsed time
      (let ((now (current-time-ms))
             (elapsed (- now last-leak))
             (leaked ( leak-rate (/ elapsed 1000))))
        (set! level (max 0 (- level leaked)))
        (set! last-leak now)

        ;; Try to add to bucket
        (if (&lt;= (+ level amount) capacity)
            (begin
              (set! level (+ level amount))
              #t)
            #f)))))
</pre>
</section>
<section>
<h2>Quota System</h2>
<h3>Quota Types</h3>
<pre class="language-scheme">
(define quota-types
  '((storage . ((unit . bytes)
                (period . #f)          ; No reset
                (default . 10737418240))) ; 10GB

    (bandwidth . ((unit . bytes)
                  (period . monthly)
                  (default . 107374182400))) ; 100GB/month

    (requests . ((unit . count)
                 (period . daily)
                 (default . 100000)))    ; 100k/day

    (objects . ((unit . count)
                (period . #f)
                (default . 1000000)))))  ; 1M objects
</pre>
<h3>Quota Tracking</h3>
<pre class="language-scheme">
(define principal-quotas (make-hash-table))

(define (get-quota principal quota-type)
  "Get principal's quota for type"
  (let ((quotas (hash-table-ref principal-quotas principal '())))
    (or (assoc-ref quotas quota-type)
        (assoc-ref quota-types quota-type 'default))))

(define (get-usage principal quota-type)
  "Get principal's current usage"
  (let ((period (quota-period quota-type)))
    (soup-aggregate
      where: (and (type: 'usage-record)
                  (principal: principal)
                  (quota-type: quota-type)
                  (if period
                      (timestamp: (&gt; (period-start period)))
                      #t))
      aggregate: (sum 'amount))))

(define (check-quota principal quota-type amount)
  "Check if operation would exceed quota"
  (let ((quota (get-quota principal quota-type))
        (usage (get-usage principal quota-type)))
    (&lt;= (+ usage amount) quota)))
</pre>
<h3>Quota Enforcement</h3>
<pre class="language-scheme">
(define (enforce-quota principal quota-type amount)
  "Enforce quota, raise error if exceeded"
  (unless (check-quota principal quota-type amount)
    (let ((quota (get-quota principal quota-type))
          (usage (get-usage principal quota-type)))
      (audit-append action: 'quota-exceeded
                    principal: principal
                    quota-type: quota-type
                    quota: quota
                    usage: usage
                    requested: amount)
      (error 'quota-exceeded
             ((type . ,quota-type)
               (quota . ,quota)
               (usage . ,usage)
               (requested . ,amount))))))

(define (record-usage principal quota-type amount)
  "Record quota usage"
  (soup-put
    ((type . usage-record)
      (principal . ,principal)
      (quota-type . ,quota-type)
      (amount . ,amount)
      (timestamp . ,(current-time)))))
</pre>
</section>
<section>
<h2>Principal-Based Limits</h2>
<h3>Limit Tiers</h3>
<pre class="language-scheme">
(define limit-tiers
  '((anonymous . ((requests-per-second . 10)
                  (storage-bytes . 0)
                  (bandwidth-bytes . 1073741824)))

    (authenticated . ((requests-per-second . 100)
                      (storage-bytes . 10737418240)
                      (bandwidth-bytes . 107374182400)))

    (premium . ((requests-per-second . 1000)
                (storage-bytes . 1099511627776)
                (bandwidth-bytes . 10995116277760)))

    (admin . ((requests-per-second . #f)  ; Unlimited
              (storage-bytes . #f)
              (bandwidth-bytes . #f)))))

(define (principal-tier principal)
  "Determine principal's limit tier"
  (cond
    ((admin-principal? principal) 'admin)
    ((premium-principal? principal) 'premium)
    ((authenticated? principal) 'authenticated)
    (else 'anonymous)))
</pre>
<h3>Per-Principal Limiters</h3>
<pre class="language-scheme">
(define principal-limiters (make-hash-table))

(define (get-limiter principal)
  "Get or create rate limiter for principal"
  (or (hash-table-ref principal-limiters principal #f)
      (let ((tier (principal-tier principal))
             (rps (assoc-ref (assoc-ref limit-tiers tier)
                            'requests-per-second)))
        (if rps
            (let ((limiter (make-token-bucket ( rps 2) rps)))
              (hash-table-set! principal-limiters principal limiter)
              limiter)
            (lambda (_) #t)))))  ; Unlimited

(define (rate-limit-principal principal)
  "Apply rate limit to principal"
  (let ((limiter (get-limiter principal)))
    (unless (limiter 1)
      (audit-append action: 'rate-limited principal: principal)
      (error 'rate-limited))))
</pre>
<h3>Capability-Based Limits</h3>
<pre class="language-scheme">
;; Capabilities can include rate limits
(spki-cert
  (issuer vault-admin)
  (subject api-client)
  (capability
    (action read)
    (object vault-content)
    (rate-limit
      (requests-per-second 50)
      (burst 100)))
  (validity (not-after "2027-01-01")))

(define (capability-rate-limit cap)
  "Extract rate limit from capability"
  (assoc-ref cap 'rate-limit))
</pre>
</section>
<section>
<h2>Resource-Specific Limits</h2>
<h3>Storage Limits</h3>
<pre class="language-scheme">
(define (enforce-storage-limit principal size)
  "Enforce storage quota before write"
  (let* ((quota (get-quota principal 'storage))
         (used (principal-storage-used principal)))
    (when (and quota (&gt; (+ used size) quota))
      (error 'storage-quota-exceeded
             `((quota . ,quota)
               (used . ,used)
               (requested . ,size))))))

(define (principal-storage-used principal)
  "Calculate principal's storage usage"
  (soup-aggregate
    where: (owner: principal)
    aggregate: (sum 'size)))
</pre>
<h3>Bandwidth Limits</h3>
<pre class="language-scheme">
(define (enforce-bandwidth-limit principal bytes direction)
  "Enforce bandwidth quota"
  (let* ((quota (get-quota principal 'bandwidth))
         (used (principal-bandwidth-used principal)))
    (when (and quota (&gt; (+ used bytes) quota))
      (error 'bandwidth-quota-exceeded
             `((quota . ,quota)
               (used . ,used)
               (requested . ,bytes)
               (direction . ,direction))))))
</pre>
<h3>Connection Limits</h3>
<pre class="language-scheme">
(define max-connections-per-principal 100)
(define principal-connections (make-hash-table))

(define (enforce-connection-limit principal)
  "Limit concurrent connections"
  (let ((count (hash-table-ref principal-connections principal 0)))
    (when (&gt;= count max-connections-per-principal)
      (error 'connection-limit-exceeded
             `((limit . ,max-connections-per-principal)
               (current . ,count))))))

(define (track-connection principal direction)
  (let ((count (hash-table-ref principal-connections principal 0)))
    (hash-table-set! principal-connections principal
      (case direction
        ((open) (+ count 1))
        ((close) (max 0 (- count 1)))))))
</pre>
</section>
<section>
<h2>Backpressure</h2>
<h3>Request Queuing</h3>
<pre class="language-scheme">
(define request-queue (make-bounded-queue 1000))

(define (queue-request request)
  "Queue request with backpressure"
  (if (queue-full? request-queue)
      (begin
        (audit-append action: 'request-rejected reason: 'queue-full)
        (error 'service-unavailable))
      (queue-push! request-queue request)))
</pre>
<h3>Load Shedding</h3>
<pre class="language-scheme">
(define (should-shed-load?)
  "Determine if load shedding needed"
  (or (&gt; (cpu-usage) 0.9)
      (&gt; (memory-usage) 0.9)
      (&gt; (queue-length request-queue) 800)))

(define (shed-load request)
  "Selectively reject requests under load"
  (cond
    ;; Always allow admin requests
    ((admin-principal? (request-principal request))
     (process-request request))
    ;; Shed low-priority requests
    ((and (should-shed-load?)
          (low-priority-request? request))
     (audit-append action: 'load-shed request: (request-id request))
     (error 'service-unavailable))
    (else
     (process-request request))))
</pre>
<h3>Retry-After</h3>
<pre class="language-scheme">
(define (rate-limit-response retry-after)
  "Generate rate limit response"
  `((status . 429)
    (headers . ((Retry-After . ,retry-after)
                (X-RateLimit-Limit . ,(current-limit))
                (X-RateLimit-Remaining . ,(remaining-tokens))
                (X-RateLimit-Reset . ,(reset-time))))))
</pre>
</section>
<section>
<h2>Monitoring</h2>
<h3>Limit Metrics</h3>
<pre class="language-scheme">
(define (record-limit-metrics)
  "Record rate limiting metrics"
  (metric-set! 'ratelimit.requests.allowed allowed-count)
  (metric-set! 'ratelimit.requests.denied denied-count)
  (metric-set! 'ratelimit.requests.queued (queue-length request-queue))
  (metric-set! 'quota.storage.used total-storage-used)
  (metric-set! 'quota.storage.available total-storage-available))
</pre>
<h3>Limit Alerts</h3>
<pre class="language-scheme">
(define limit-alerts
  '((high-rejection-rate
     (condition (&gt; (/ denied-count (+ allowed-count denied-count)) 0.1))
     (severity warning)
     (message "High rate limit rejection rate"))

    (quota-near-limit
     (condition (&gt; (/ used quota) 0.9))
     (severity warning)
     (message "Principal approaching quota limit"))))
</pre>
</section>
<section>
<h2>Configuration</h2>
<h3>Dynamic Limits</h3>
<pre class="language-scheme">
;; Limits can be adjusted at runtime
(define (set-limit principal limit-type value)
  "Set custom limit for principal"
  (soup-put
    `((type . principal-limit)
      (principal . ,principal)
      (limit-type . ,limit-type)
      (value . ,value)
      (set-by . ,(current-principal))
      (set-at . ,(current-time)))
    type: 'configuration))

(define (get-effective-limit principal limit-type)
  "Get principal's effective limit"
  (or (soup-query-one type: 'principal-limit
                      principal: principal
                      limit-type: limit-type)
      (tier-limit (principal-tier principal) limit-type)))
</pre>
<h3>Limit Inheritance</h3>
<pre class="language-scheme">
;; Groups can have limits that members inherit
(define (group-limit group limit-type)
  (soup-query-one type: 'group-limit
                  group: group
                  limit-type: limit-type))

(define (effective-limit principal limit-type)
  "Resolve limit with inheritance"
  (or (get-effective-limit principal limit-type)
      (let ((groups (principal-groups principal)))
        (find (lambda (g) (group-limit g limit-type)) groups))
      (default-limit limit-type)))
</pre>
</section>
<section>
<h2>Security</h2>
<h3>Limit Bypass Prevention</h3>
<pre class="language-scheme">
;; Prevent limit bypass via identity rotation
(define (track-ip-limits ip)
  "Track limits by IP in addition to principal"
  (let ((limiter (get-ip-limiter ip)))
    (unless (limiter 1)
      (error 'ip-rate-limited))))

;; Combine principal and IP limits
(define (combined-rate-limit principal ip)
  (and (rate-limit-principal principal)
       (track-ip-limits ip)))
</pre>
<h3>Audit Trail</h3>
<pre class="language-scheme">
(define (audit-limit-event event-type principal details)
  (audit-append
    action: event-type
    principal: principal
    details: details
    timestamp: (current-time)))
</pre>
</section>
<section>
<h2>References</h2>
<p>1. [Token Bucket Algorithm](https://en.wikipedia.org/wiki/Tokenbucket) 2. [Leaky Bucket Algorithm](https://en.wikipedia.org/wiki/Leakybucket) 3. [RFC-021: Capability Delegation](rfc-021-capability-delegation.html) 4. [RFC-031: Monitoring](rfc-031-monitoring.html)</p>
</section>
<section>
<h2>Changelog</h2>
<ul>
<li>2026-01-07</li>
<li>Initial draft</li>
</ul>
</section>
<script>
function toggleTheme() {
  const html = document.documentElement;
  const current = html.getAttribute('data-theme');
  const next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  localStorage.setItem('theme', next);
}
(function() {
  const saved = localStorage.getItem('theme');
  if (saved) {
    document.documentElement.setAttribute('data-theme', saved);
  } else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script>
</body>
</html>
