<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RFC-014: Coq Extraction for TCB</title>
  <link rel="stylesheet" href="rfc.css">
</head>
<body>
<h1>RFC-014: Coq Extraction for TCB</h1>
<dl class="metadata">
</dl>
<hr>
<section>
<h2>Abstract</h2>
<p>This RFC specifies the use of Coq proof assistant for verified implementation of the Trusted Computing Base, with extraction to OCaml for production use. Prove once, trust forever.</p>
</section>
<section>
<h2>Motivation</h2>
<p>The Prime Directive (RFC-002):</p>
<blockquote>
<p>If it's in the TCB, it's in OCaml. Otherwise it's in Chicken Scheme.</p>
</blockquote>
<p>But even OCaml can have bugs. The TCB handles: - Ed25519 signatures - SHA-512 hashing - Signature chain verification</p>
<p>A single bug breaks everything.</p>
<p>Coq provides:</p>
<p>1. Machine-checked proofs: Theorems verified by computer 2. Extraction: Generate OCaml from proofs 3. Correctness by construction: Implementation matches specification 4. Eternal validity: Proofs don't expire</p>
<p>From the Coq motto:</p>
<blockquote>
<p>The proof is in the code.</p>
</blockquote>
</section>
<section>
<h2>Specification</h2>
<h3>Trusted Computing Base</h3>
<pre>
┌─────────────────────────────────────────────────────────────┐
│                    CYBERSPACE TCB                           │
│                                                             │
│   ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│   │   Ed25519   │  │   SHA-512   │  │   Verify    │        │
│   │   Proven    │  │   Proven    │  │   Proven    │        │
│   └──────┬──────┘  └──────┬──────┘  └──────┬──────┘        │
│          │                │                │                │
│          └────────────────┼────────────────┘                │
│                           │                                 │
│                    Coq Extraction                           │
│                           │                                 │
│                    ┌──────▼──────┐                          │
│                    │    OCaml    │                          │
│                    │   ~1000 LOC │                          │
│                    └─────────────┘                          │
│                                                             │
│   Proven in Coq. Extracted to OCaml. Called from Scheme.   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
</pre>
</section>
<section>
<h2>Coq Specifications</h2>
<h3>Types</h3>
<pre class="language-coq">
( Byte arrays )
Definition bytes := list byte.

( Keys )
Record ed25519publickey := {
  pkbytes : bytes;
  pklength : length pkbytes = 32
}.

Record ed25519privatekey := {
  skbytes : bytes;
  sklength : length skbytes = 64
}.

( Signatures )
Record ed25519signature := {
  sigbytes : bytes;
  siglength : length sigbytes = 64
}.

( Hashes )
Record sha512hash := {
  hashbytes : bytes;
  hashlength : length hashbytes = 64
}.
</pre>
<h3>Signature Specification</h3>
<pre class="language-coq">
( Abstract signature scheme )
Module Type ED25519SPEC.
  Parameter sign : ed25519privatekey -&gt; bytes -&gt; ed25519signature.
  Parameter verify : ed25519publickey -&gt; bytes -&gt; ed25519signature -&gt; bool.

  ( Correctness: valid signatures verify )
  Axiom signverifycorrect :
    forall sk pk msg,
      pk = derivepublic sk -&gt;
      verify pk msg (sign sk msg) = true.

  ( Security: cannot forge without private key )
  Axiom unforgeability :
    forall pk msg sig,
      verify pk msg sig = true -&gt;
      exists sk, pk = derivepublic sk /\ sig = sign sk msg.
End ED25519SPEC.
</pre>
<h3>Hash Specification</h3>
<pre class="language-coq">
Module Type SHA512SPEC.
  Parameter hash : bytes -&gt; sha512hash.

  ( Determinism )
  Axiom hashdeterministic :
    forall x, hash x = hash x.

  ( Collision resistance (assumed) )
  Axiom collisionresistant :
    forall x y, hash x = hash y -&gt; x = y. ( Idealized )
End SHA512_SPEC.
</pre>
<h3>Chain Verification</h3>
<pre class="language-coq">
( Certificate chain verification )
Fixpoint verifychain
  (root : ed25519publickey)
  (certs : list signedcert)
  (targettag : tag) : bool :=
  match certs with
  | nil =&gt; false
  | cert :: rest =&gt;
      let issuerkey := certissuer cert in
      let subjectkey := certsubject cert in
      let certtag := certtag cert in
      ( Check issuer matches current key )
      andb (keyeq root issuerkey)
      ( Check signature valid )
      (andb (verify issuerkey (certcontent cert) (certsignature cert))
      ( Check tag grants permission )
      (andb (tagimplies certtag targettag)
      ( Continue chain )
      (match rest with
       | nil =&gt; true
       |  =&gt; verifychain subjectkey rest targettag
       end)))
  end.

( Theorem: Valid chain implies authorization )
Theorem chainauthorization :
  forall root certs tag,
    verify_chain root certs tag = true -&gt;
    authorized root tag.
Proof.
  ( Proof by induction on chain length )
  ...
Qed.
</pre>
</section>
<section>
<h2>Extraction to OCaml</h2>
<h3>Extraction Directives</h3>
<pre class="language-coq">
Require Import ExtrOcamlBasic.
Require Import ExtrOcamlString.

( Extract to OCaml types )
Extract Inductive bool =&gt; "bool" ["true" "false"].
Extract Inductive list =&gt; "list" ["[]" "(::)"].

( Link to libsodium )
Extract Constant ed25519sign =&gt; "Sodium.Ed25519.sign".
Extract Constant ed25519verify =&gt; "Sodium.Ed25519.verify".
Extract Constant sha512hash =&gt; "Sodium.SHA512.hash".

( Generate OCaml )
Extraction "tcb.ml" verifychain sign verify hash.
</pre>
<h3>Generated OCaml</h3>
<pre class="language-ocaml">
( tcb.ml - Extracted from Coq )

let rec verifychain root certs targettag =
  match certs with
  | [] -&gt; false
  | cert :: rest -&gt;
      let issuerkey = certissuer cert in
      let subjectkey = certsubject cert in
      keyeq root issuerkey &amp;&amp;
      Sodium.Ed25519.verify issuerkey (certcontent cert) (certsignature cert) &amp;&amp;
      tagimplies (certtag cert) targettag &amp;&amp;
      (match rest with
       | [] -&gt; true
       |  -&gt; verifychain subjectkey rest targettag)
</pre>
</section>
<section>
<h2>Integration with Scheme</h2>
<h3>FFI Layer</h3>
<pre class="language-ocaml">
( tcbffi.ml - FFI bindings for Chicken Scheme )

let () = Callback.register "tcbverifychain" verifychain
let () = Callback.register "tcbsign" sign
let () = Callback.register "tcbverify" verify
let () = Callback.register "tcb_hash" hash
</pre>
<h3>Scheme Bindings</h3>
<pre class="language-scheme">
;; crypto-ffi.scm
(module crypto-ffi
  (ed25519-sign ed25519-verify sha512-hash verify-chain)

  (import (chicken foreign))

  ;; Call into verified OCaml
  (define ed25519-sign
    (foreign-lambda blob ((blob key) (blob msg))
      "return tcbsign(key, msg);"))

  (define verify-chain
    (foreign-lambda bool ((blob root) (pointer certs) (pointer tag))
      "return tcbverify_chain(root, certs, tag);"))

  ...)
</pre>
</section>
<section>
<h2>Proof Obligations</h2>
<h3>What We Prove</h3>
<p>1. Signature correctness: Valid signatures verify 2. Chain soundness: Valid chain implies authorization 3. Hash properties: Determinism, length preservation 4. Type safety: No buffer overflows, no null pointers</p>
<h3>What We Assume</h3>
<p>1. Cryptographic hardness: Ed25519 unforgeability 2. libsodium correctness: Implementation matches spec 3. OCaml runtime: Extraction target is correct 4. Hardware: CPU executes instructions correctly</p>
<h3>Trust Chain</h3>
<pre>
Mathematical proof (Coq)
    ↓
Extraction (verified by Coq)
    ↓
OCaml code (typed, memory-safe)
    ↓
libsodium (audited, widely deployed)
    ↓
CPU instructions (trust hardware)
</pre>
</section>
<section>
<h2>Development Workflow</h2>
<h3>1. Specify in Coq</h3>
<pre class="language-coq">
( Define types and operations )
( State properties and theorems )
</pre>
<h3>2. Prove Correctness</h3>
<pre class="language-coq">
( Prove theorems )
( Coq checks proofs mechanically )
</pre>
<h3>3. Extract to OCaml</h3>
<pre class="language-bash">
$ coqc -R . Cyberspace tcb.v
$ coqc -R . Cyberspace extract.v
$ ls *.ml
tcb.ml tcb_types.ml
</pre>
<h3>4. Compile and Link</h3>
<pre class="language-bash">
$ ocamlfind ocamlopt -package sodium -linkpkg \
    tcb.ml tcb_ffi.ml -o tcb.cmxa
</pre>
<h3>5. Call from Scheme</h3>
<pre class="language-scheme">
(import crypto-ffi)
(ed25519-sign key message)  ; Calls verified code
</pre>
</section>
<section>
<h2>Existing Verified Libraries</h2>
<h3>Fiat-Crypto</h3>
<ul>
<li>Verified elliptic curve implementations</li>
<li>Used by BoringSSL, Chrome</li>
<li>Extraction to C, Java, Go</li>
</ul>
<h3>HACL*</h3>
<ul>
<li>Verified cryptographic library</li>
<li>Written in F* (similar to Coq)</li>
<li>Used by Firefox, Wireguard</li>
</ul>
<h3>Potential Use</h3>
<pre class="language-coq">
Require Import Fiat.Crypto.Ed25519.
( Use pre-verified Ed25519 implementation )
</pre>
</section>
<section>
<h2>Security Considerations</h2>
<h3>Verified Components</h3>
<ul>
<li>Signature operations</li>
<li>Hash operations</li>
<li>Chain verification logic</li>
</ul>
<h3>Unverified (Trusted)</h3>
<ul>
<li>FFI layer (small, auditable) - libsodium bindings</li>
<li>Scheme runtime</li>
</ul>
<h3>Audit Surface</h3>
<pre>
Total TCB:     ~1000 lines OCaml
Verified:      ~800 lines (extracted from ~2000 lines Coq)
Trusted:       ~200 lines (FFI, bindings)
</pre>
</section>
<section>
<h2>References</h2>
<p>1. Coq Development Team. The Coq Proof Assistant Reference Manual. 2. Erbsen, A., et al. (2019). Simple High-Level Code for Cryptographic Arithmetic. 3. Protzenko, J., et al. (2017). Verified Low-Level Programming Embedded in F*. 4. Chlipala, A. (2013). Certified Programming with Dependent Types. 5. RFC-002: Cyberspace Architecture</p>
</section>
<section>
<h2>Changelog</h2>
<ul>
<li>2026-01-06</li>
<li>Initial specification</li>
</ul>
</section>
</body>
</html>
