#!/usr/bin/env csi -q -w
;;; cyberspace-repl - Knowledge Access Station for the Library of Cyberspace
;;;
;;; Usage: ./cyberspace-repl
;;;
;;; Preloads all Cyberspace modules for interactive exploration:
;;;   - vault: seal-commit, seal-release, seal-archive, etc.
;;;   - crypto-ffi: ed25519-keypair, sha512-hash, etc.
;;;   - audit: audit-append, audit-read, etc.
;;;   - cert: SPKI certificates
;;;   - sexp: S-expression handling

(import scheme
        (chicken base)
        (chicken format)
        (chicken repl)
        (chicken file)
        (chicken io)
        (chicken time)
        (chicken process-context)
        (chicken process)
        (chicken blob)
        (chicken file posix)
        srfi-1
        srfi-4
        srfi-13)

;;; ============================================================
;;; Bootstrap: Mixed-Architecture Defense
;;; ============================================================
;;; Ensures compiled modules match current architecture.
;;; Rebuilds automatically if arch mismatch or source newer.

(define (current-arch)
  "Detect current CPU architecture"
  (let ((result (with-input-from-pipe "uname -m" read-line)))
    (if (eof-object? result) "unknown" result)))

(define (current-os)
  "Detect current operating system"
  (let ((result (with-input-from-pipe "uname -s" read-line)))
    (if (eof-object? result) "unknown" result)))

(define (libsodium-paths arch)
  "Return (include-path lib-path) for libsodium based on architecture and OS"
  (let ((os (current-os)))
    (cond
     ;; macOS ARM (M1/M2/M3)
     ((and (string=? os "Darwin") (string=? arch "arm64"))
      '("/opt/homebrew/include" "/opt/homebrew/lib"))
     ;; macOS Intel
     ((string=? os "Darwin")
      '("/usr/local/include" "/usr/local/lib"))
     ;; Linux (Fedora, Ubuntu, etc.) - system packages
     ((string=? os "Linux")
      '("/usr/include" "/usr/lib64"))  ; Fedora uses lib64 for x86_64
     ;; Fallback
     (else
      '("/usr/local/include" "/usr/local/lib")))))

(define (arch-stamp-file module)
  "Path to architecture stamp file for module"
  (string-append "." module ".arch"))

(define (read-arch-stamp module)
  "Read stored architecture for a compiled module"
  (let ((stamp-file (arch-stamp-file module)))
    (if (file-exists? stamp-file)
        (with-input-from-file stamp-file read-line)
        #f)))

(define (write-arch-stamp module arch)
  "Write architecture stamp for compiled module"
  (with-output-to-file (arch-stamp-file module)
    (lambda () (print arch))))

(define (file-mtime path)
  "Get file modification time, or 0 if doesn't exist"
  (if (file-exists? path)
      (file-modification-time path)
      0))

(define (needs-rebuild? module arch)
  "Check if module needs rebuilding: missing, arch mismatch, or source newer"
  (let* ((src (string-append module ".scm"))
         (so  (string-append module ".so"))
         (import-scm (string-append module ".import.scm"))
         (stored-arch (read-arch-stamp module)))
    (or (not (file-exists? so))
        (not (file-exists? import-scm))
        (not stored-arch)
        (not (string=? stored-arch arch))
        (> (file-mtime src) (file-mtime so)))))

(define (rebuild-module! module arch stamp)
  "Rebuild a module for current platform"
  (let* ((paths (libsodium-paths arch))
         (inc-path (car paths))
         (lib-path (cadr paths))
         (src (string-append module ".scm")))
    (print "")
    (print "┌─ BOOTSTRAP: Rebuilding " module " for " stamp " ─┐")
    (let ((cmd (if (string=? module "crypto-ffi")
                   ;; crypto-ffi needs libsodium
                   (string-append "csc -shared -J " src
                                  " -I" inc-path
                                  " -L" lib-path
                                  " -L -lsodium 2>&1")
                   ;; other modules (vault, etc)
                   (string-append "csc -shared -J " src " 2>&1"))))
      (print "  " cmd)
      (let ((result (with-input-from-pipe cmd
                      (lambda ()
                        (let loop ((lines '()))
                          (let ((line (read-line)))
                            (if (eof-object? line)
                                (reverse lines)
                                (loop (cons line lines)))))))))
        ;; Print any output (warnings/errors)
        (for-each (lambda (line) (print "  " line)) result)
        ;; Check if .so was created
        (if (file-exists? (string-append module ".so"))
            (begin
              (write-arch-stamp module stamp)
              (print "  ✓ Built successfully")
              (print "└" (make-string 45 #\─) "┘")
              (print "")
              #t)
            (begin
              (print "  ✗ Build FAILED")
              (print "└" (make-string 45 #\─) "┘")
              (print "")
              (exit 1)))))))

(define (platform-stamp)
  "Return OS+arch stamp (e.g., 'Darwin-arm64', 'Linux-x86_64')"
  (string-append (current-os) "-" (current-arch)))

(define (bootstrap-modules!)
  "Ensure all required modules are built for current platform"
  (let ((stamp (platform-stamp))
        (arch (current-arch))
        (modules '("crypto-ffi" "vault")))
    (for-each
     (lambda (module)
       (when (needs-rebuild? module stamp)
         (rebuild-module! module arch stamp)))
     modules)))

;; Run bootstrap before loading modules
(bootstrap-modules!)

;; Load cyberspace modules (now guaranteed to be correct arch)
(import crypto-ffi)
(import vault)
(import audit)
(import cert)
(import sexp)

;; Initialize libsodium
(sodium-init)

;; Helper utilities
(define (blob->hex b)
  "Convert blob to hex string"
  (define (byte->hex n)
    (let ((s (number->string n 16)))
      (if (= (string-length s) 1)
          (string-append "0" s)
          s)))
  (let ((vec (blob->u8vector b)))
    (let loop ((i 0) (acc '()))
      (if (= i (u8vector-length vec))
          (apply string-append (reverse acc))
          (loop (+ i 1)
                (cons (byte->hex (u8vector-ref vec i)) acc))))))

(define (hex->blob hex-str)
  "Convert hex string to blob"
  (let* ((len (quotient (string-length hex-str) 2))
         (vec (make-u8vector len)))
    (do ((i 0 (+ i 1)))
        ((= i len) (u8vector->blob vec))
      (let* ((hex-byte (substring hex-str (* i 2) (+ (* i 2) 2)))
             (byte-val (string->number hex-byte 16)))
        (u8vector-set! vec i byte-val)))))

;;; ============================================================
;;; RFC-040: Object State (chaotic/quiescent) and Persistence
;;; ============================================================

;; All things have state and durability
;; State: chaotic (in flux) | quiescent (stable)
;; Durability: ephemeral (no promise) | persistent (vault-bound)

(define *thing-states* '())      ; thing-id -> state
(define *thing-durability* '())  ; thing-id -> durability
(define *chaotic-store* '())     ; things in flux
(define *persistence-queue* '()) ; scheduled for vault migration

(define (thing-id thing)
  "Get or compute thing identity"
  (cond
   ;; Already has an id field (alist)
   ((and (list? thing)
         (pair? (car thing))
         (assoc 'id thing))
    => (lambda (pair) (cdr pair)))
   ;; String - use as-is or hash if long
   ((string? thing)
    (if (< (string-length thing) 64)
        thing
        (content-address thing)))
   ;; Everything else - hash it
   (else
    (content-address (format "~a" thing)))))

(define (chaotic? thing)
  "Is thing in chaotic state (mutable, uncommitted)?"
  (let ((state (alist-ref (thing-id thing) *thing-states* equal?)))
    (or (not state) (eq? state 'chaotic))))

(define (quiescent? thing)
  "Is thing in quiescent state (immutable, stable)?"
  (let ((state (alist-ref (thing-id thing) *thing-states* equal?)))
    (eq? state 'quiescent)))

(define (ephemeral? thing)
  "Is thing ephemeral (no durability promise)?"
  (let ((dur (alist-ref (thing-id thing) *thing-durability* equal?)))
    (or (not dur) (eq? dur 'ephemeral))))

(define (persistent? thing)
  "Is thing persistent (guaranteed vault migration)?"
  (let ((dur (alist-ref (thing-id thing) *thing-durability* equal?)))
    (eq? dur 'persistent)))

(define (thing-state thing)
  "Get thing's current state"
  (or (alist-ref (thing-id thing) *thing-states* equal?) 'chaotic))

(define (thing-durability thing)
  "Get thing's durability"
  (or (alist-ref (thing-id thing) *thing-durability* equal?) 'ephemeral))

(define (short-id id)
  "Truncate id for display (max 16 chars)"
  (if (> (string-length id) 16)
      (string-append (substring id 0 16) "...")
      id))

(define (chaotic thing)
  "Create or mark thing as chaotic"
  (let ((id (thing-id thing)))
    (set! *thing-states* (cons (cons id 'chaotic) *thing-states*))
    (set! *chaotic-store* (cons (cons id thing) *chaotic-store*))
    (print "Thing " (short-id id) " is chaotic")
    thing))

(define (commit-thing thing)
  "Transition thing from chaotic to quiescent"
  (let ((id (thing-id thing)))
    (unless (chaotic? thing)
      (print "Thing already quiescent"))
    (set! *thing-states* (cons (cons id 'quiescent) *thing-states*))
    ;; Remove from chaotic store
    (set! *chaotic-store* (filter (lambda (e) (not (equal? (car e) id))) *chaotic-store*))
    (print "Thing " (short-id id) " committed (quiescent)")
    ;; If persistent, queue for vault
    (when (persistent? thing)
      (set! *persistence-queue* (cons thing *persistence-queue*))
      (print "  Queued for vault migration"))
    thing))

(define (persist thing)
  "Mark thing as persistent (guaranteed vault migration)"
  (let ((id (thing-id thing)))
    (set! *thing-durability* (cons (cons id 'persistent) *thing-durability*))
    (print "Thing " (short-id id) " marked persistent")
    ;; If already quiescent, queue immediately
    (when (quiescent? thing)
      (set! *persistence-queue* (cons thing *persistence-queue*))
      (print "  Queued for vault migration"))
    thing))

(define (ephemeral thing)
  "Mark thing as ephemeral (no durability promise)"
  (let ((id (thing-id thing)))
    (set! *thing-durability* (cons (cons id 'ephemeral) *thing-durability*))
    ;; Remove from persistence queue if present
    (set! *persistence-queue* (filter (lambda (t) (not (equal? (thing-id t) id))) *persistence-queue*))
    (print "Thing " (short-id id) " marked ephemeral")
    thing))

(define (flush-persistence!)
  "Migrate all queued persistent things to vault"
  (if (null? *persistence-queue*)
      (print "Persistence queue empty")
      (begin
        (print "Migrating " (length *persistence-queue*) " things to vault...")
        (for-each
         (lambda (thing)
           (let ((id (thing-id thing)))
             (content-put (format "~a" thing))
             (print "  " (short-id id) " -> vault")))
         *persistence-queue*)
        (set! *persistence-queue* '())
        (print "Done."))))

(define (thing-status thing)
  "Show thing's state and durability"
  (let ((id (thing-id thing)))
    (print "Thing: " (short-id id))
    (print "  State: " (thing-state thing))
    (print "  Durability: " (thing-durability thing))
    (print "  Cacheable: " (if (quiescent? thing) "yes (forever)" "no"))
    `((id . ,id)
      (state . ,(thing-state thing))
      (durability . ,(thing-durability thing)))))

;;; ============================================================
;;; Node Identity and Attestation
;;; ============================================================

(define *node-attestation* #f)  ; current attestation state

(define (principal->string p)
  "Convert principal blob to hex string"
  (if (blob? p) (blob->hex p) (format "~a" p)))

(define (attest #!optional principal)
  "Attest identity to access node details"
  (let ((key (vault-config 'signing-key)))
    (cond
     ((not key)
      (print "No signing key configured. Generate with (ed25519-keypair)")
      #f)
     (principal
      ;; Verify against provided principal
      (let ((our-principal (principal->string key)))
        (if (equal? principal our-principal)
            (begin
              (set! *node-attestation* our-principal)
              (print "Attested as: " (short-id our-principal))
              our-principal)
            (begin
              (print "Attestation failed: principal mismatch")
              #f))))
     (else
      ;; Self-attestation - principal is the public key (signing-key stored)
      (let ((our-principal (principal->string key)))
        (set! *node-attestation* our-principal)
        (print "Attested as: " (short-id our-principal))
        our-principal)))))

(define (attested?)
  "Check if currently attested"
  (and *node-attestation* #t))

(define (!)
  "Display detailed node information (requires attestation)"
  (unless (attested?)
    (print "Attestation required. Use (attest) first.")
    (print "")
    (attest))
  (when (attested?)
    (let* ((caps (probe-system-capabilities))
           (role (recommend-role caps)))
      (print "")
      (print "╔═══════════════════════════════════════════════════════════════╗")
      (print "║                     NODE INFORMATION                          ║")
      (print "╠═══════════════════════════════════════════════════════════════╣")
      (print "")
      (print "  Principal:   " (short-id *node-attestation*))
      (print "  Platform:    " (platform-stamp))
      (print "  Role:        " role)
      (print "  Vault:       " (if (directory-exists? ".vault") ".vault/" "(none)"))
      (print "")
      (print "  COMPUTE")
      (let ((compute (cdr (assq 'compute caps))))
        (print "    Cores:     " (cdr (assq 'cores compute)))
        (print "    RAM:       " (cdr (assq 'ram-gb compute)) " GB")
        (print "    Load:      " (cdr (assq 'load-avg compute))))
      (print "")
      (print "  STORAGE")
      (let ((storage (cdr (assq 'storage caps))))
        (print "    Available: " (cdr (assq 'available-gb storage)) " GB")
        (print "    Type:      " (cdr (assq 'type storage))))
      (print "")
      (print "  NETWORK")
      (let ((network (cdr (assq 'network caps))))
        (print "    Type:      " (cdr (assq 'type network)))
        (print "    Latency:   " (cdr (assq 'latency-ms network)) " ms"))
      (print "")
      (print "  SECURITY")
      (let ((security (cdr (assq 'security caps))))
        (print "    Signing:   " (if (cdr (assq 'signing-key security)) "configured" "absent"))
        (print "    Verify:    " (if (cdr (assq 'verify-key security)) "configured" "absent")))
      (print "")
      (print "  STATE")
      (print "    Memos:     " (length *memos*))
      (print "    Chaotic:   " (length *chaotic-store*))
      (print "    Pending:   " (length *persistence-queue*))
      (print "")
      (print "╚═══════════════════════════════════════════════════════════════╝")
      (print "")
      `((principal . ,*node-attestation*)
        (platform . ,(platform-stamp))
        (role . ,role)
        (capabilities . ,caps)))))

;;; ============================================================
;;; RFC-043: Memo Conventions
;;; ============================================================

(define *memos* '())
(define *memo-counter* 0)

(define (pad-number n width)
  "Pad number with leading zeros"
  (let ((s (number->string n)))
    (string-append (make-string (max 0 (- width (string-length s))) #\0) s)))

(define (memo-create title #!key (scope 'local) (category 'informational)
                                  (author "anonymous") (content ""))
  "Create a new memo"
  (set! *memo-counter* (+ *memo-counter* 1))
  (let* ((num (pad-number *memo-counter* 3))
         (id (case scope
               ((local) (string-append "local:memo-" num))
               ((federation) (string-append (current-directory) ":memo-" num))
               ((core) (string-append "RFC-" num))
               (else (error "Invalid scope" scope))))
         (memo `((id . ,id)
                 (title . ,title)
                 (scope . ,scope)
                 (category . ,category)
                 (author . ,author)
                 (content . ,content)
                 (created . ,(current-seconds))
                 (status . draft))))
    ;; Memos start chaotic
    (chaotic memo)
    (set! *memos* (cons memo *memos*))
    (print "Created " id ": " title)
    (print "  Scope: " scope)
    (print "  Category: " category)
    (print "  State: chaotic (pen to commit)")
    memo))

(define (memo-commit memo-id)
  "Commit a memo (chaotic → quiescent)"
  (let ((memo (find (lambda (m) (equal? (alist-ref 'id m) memo-id)) *memos*)))
    (if memo
        (begin
          (commit-thing memo)
          (print "Memo committed: " memo-id)
          memo)
        (error "Memo not found" memo-id))))

(define (memo-promote memo-id new-scope)
  "Promote memo to higher scope (local → federation → core)"
  (let ((memo (find (lambda (m) (equal? (alist-ref 'id m) memo-id)) *memos*)))
    (unless memo (error "Memo not found" memo-id))
    (let ((current-scope (alist-ref 'scope memo)))
      (unless (quiescent? memo)
        (error "Cannot promote chaotic memo - commit first"))
      (case new-scope
        ((federation)
         (unless (eq? current-scope 'local)
           (error "Can only promote local to federation"))
         (print "Promoting " memo-id " to federation scope")
         (print "  Requires federation review"))
        ((core)
         (unless (member current-scope '(local federation))
           (error "Already at core scope"))
         (print "Promoting " memo-id " to core (RFC)")
         (print "  Requires rough consensus"))
        (else (error "Invalid scope" new-scope)))
      `(promoted ,memo-id ,new-scope))))

(define (memo-persist memo-id)
  "Mark memo as persistent"
  (let ((memo (find (lambda (m) (equal? (alist-ref 'id m) memo-id)) *memos*)))
    (if memo
        (persist memo)
        (error "Memo not found" memo-id))))

(define (memo-list #!optional scope)
  "List memos, optionally filtered by scope"
  (let ((filtered (if scope
                      (filter (lambda (m) (eq? (alist-ref 'scope m) scope)) *memos*)
                      *memos*)))
    (if (null? filtered)
        (print "No memos" (if scope (format " at scope ~a" scope) ""))
        (for-each
         (lambda (m)
           (print "  " (alist-ref 'id m) ": " (alist-ref 'title m)
                  " [" (thing-state m) "/" (thing-durability m) "]"))
         filtered))))

(define (memo-show memo-id)
  "Show memo details"
  (let ((memo (find (lambda (m) (equal? (alist-ref 'id m) memo-id)) *memos*)))
    (if memo
        (begin
          (print "Memo: " (alist-ref 'id memo))
          (print "  Title: " (alist-ref 'title memo))
          (print "  Scope: " (alist-ref 'scope memo))
          (print "  Category: " (alist-ref 'category memo))
          (print "  Author: " (alist-ref 'author memo))
          (print "  State: " (thing-state memo))
          (print "  Durability: " (thing-durability memo))
          (print "  Created: " (alist-ref 'created memo))
          memo)
        (error "Memo not found" memo-id))))

;;; ============================================================
;;; RFC-016: Lazy Clustering
;;; ============================================================

(define *lazy-peers* '())
(define *lazy-queue* '())
(define *version-vectors* '())

(define (lazy-join peer #!key (uri #f) (key #f))
  "Register a peer for lazy sync"
  (set! *lazy-peers* (cons `((peer . ,peer) (uri . ,uri) (key . ,key) (last-sync . never)) *lazy-peers*))
  (print "Joined lazy cluster with " peer)
  `(joined ,peer))

(define (lazy-leave peer)
  "Remove peer from lazy cluster"
  (set! *lazy-peers* (filter (lambda (p) (not (equal? (alist-ref 'peer p) peer))) *lazy-peers*))
  (print "Left lazy cluster: " peer)
  `(left ,peer))

(define (lazy-push peer)
  "Push local releases to peer"
  (print "Pushing to " peer "...")
  (print "  (lazy push simulated)")
  `(pushed ,peer))

(define (lazy-pull peer)
  "Pull releases from peer"
  (print "Pulling from " peer "...")
  (print "  (lazy pull simulated)")
  `(pulled ,peer))

(define (lazy-sync peer)
  "Bidirectional sync with peer"
  (print "Syncing with " peer "...")
  (lazy-push peer)
  (lazy-pull peer)
  `(synced ,peer))

(define (lazy-status)
  "Show lazy cluster status"
  (if (null? *lazy-peers*)
      (print "No lazy cluster peers configured")
      (begin
        (print "Lazy cluster peers:")
        (for-each (lambda (p)
                    (print "  " (alist-ref 'peer p) " [" (alist-ref 'last-sync p) "]"))
                  *lazy-peers*))))

(define (lazy-queue)
  "Show pending sync queue"
  (if (null? *lazy-queue*)
      (print "Sync queue empty")
      (begin
        (print "Pending sync:")
        (for-each (lambda (item) (print "  " item)) *lazy-queue*))))

(define (lazy-resolve version #!key (prefer 'local) (merged #f))
  "Resolve a sync conflict"
  (print "Resolving " version " -> " (or merged prefer))
  `(resolved ,version ,(or merged prefer)))

(define (lazy-beacon)
  "Send optional presence beacon"
  `(beacon
    (peer ,(current-directory))
    (lamport-time ,*lamport-clock*)
    (status available)))

;;; ============================================================
;;; RFC-010: Federation
;;; ============================================================

(define *federation-peers* '())

(define (federate peer-url #!key (trust 'partial))
  "Establish federation with a peer realm"
  (set! *federation-peers* (cons `((url . ,peer-url) (trust . ,trust) (status . pending)) *federation-peers*))
  (print "Federation request sent to " peer-url)
  `(federation-pending ,peer-url))

(define (federate-status)
  "Show federation status with all peers"
  (if (null? *federation-peers*)
      (print "No federation peers configured")
      (for-each (lambda (p)
                  (print "  " (alist-ref 'url p) " [" (alist-ref 'trust p) "] " (alist-ref 'status p)))
                *federation-peers*)))

(define (federate-replicate peer-url)
  "Replicate with a federated peer"
  (print "Replicating with " peer-url "...")
  '(replicate-complete))

;;; ============================================================
;;; RFC-011: Byzantine Consensus
;;; ============================================================

(define *consensus-proposals* '())

(define (consensus-propose value #!key (quorum 'majority))
  "Propose a value for Byzantine consensus"
  (let ((proposal-id (blob->hex (sha512-hash (string->blob (format "~a~a" value (current-seconds)))))))
    (set! *consensus-proposals* (cons `((id . ,proposal-id) (value . ,value) (quorum . ,quorum) (votes . ())) *consensus-proposals*))
    (print "Proposal " (short-id proposal-id) " created")
    proposal-id))

(define (consensus-vote proposal-id vote #!key (signature #f))
  "Vote on a consensus proposal (vote: 'accept | 'reject)"
  (print "Vote " vote " recorded for " (short-id proposal-id))
  `(vote-recorded ,vote))

(define (consensus-status #!optional proposal-id)
  "Show consensus status"
  (if (null? *consensus-proposals*)
      (print "No active proposals")
      (for-each (lambda (p)
                  (print "  " (short-id (alist-ref 'id p)) " : " (alist-ref 'value p)))
                *consensus-proposals*)))

;;; ============================================================
;;; RFC-012: Lamport Clocks
;;; ============================================================

(define *lamport-clock* 0)

(define (lamport-tick)
  "Increment local Lamport clock"
  (set! *lamport-clock* (+ *lamport-clock* 1))
  *lamport-clock*)

(define (lamport-send)
  "Get timestamp for sending a message"
  (lamport-tick))

(define (lamport-receive remote-timestamp)
  "Update clock on message receipt"
  (set! *lamport-clock* (+ 1 (max *lamport-clock* remote-timestamp)))
  *lamport-clock*)

(define (lamport-compare t1 t2)
  "Compare two Lamport timestamps: -1 (before), 0 (concurrent), 1 (after)"
  (cond ((< t1 t2) -1)
        ((> t1 t2) 1)
        (else 0)))

(define (lamport-clock)
  "Get current Lamport clock value"
  *lamport-clock*)

;;; ============================================================
;;; RFC-020: Content-Addressed Storage
;;; ============================================================

(define *content-store* '())

(define (content-address data)
  "Compute content address (hash) for data"
  (let ((hash (sha512-hash (if (blob? data) data (string->blob data)))))
    (blob->hex hash)))

(define (content-put data)
  "Store data by content address, return address"
  (let* ((addr (content-address data))
         (blob-data (if (blob? data) data (string->blob data))))
    (set! *content-store* (cons (cons addr blob-data) *content-store*))
    (print "Stored at " (short-id addr))
    addr))

(define (content-get addr)
  "Retrieve data by content address"
  (let ((entry (assoc addr *content-store*)))
    (if entry
        (cdr entry)
        (error "Content not found" addr))))

(define (content-exists? addr)
  "Check if content exists"
  (if (assoc addr *content-store*) #t #f))

;;; ============================================================
;;; RFC-021: Capability Delegation
;;; ============================================================

(define (delegate capability to-principal #!key (restrict '()) (expires #f))
  "Delegate a capability to another principal"
  (let ((delegation `((capability . ,capability)
                      (to . ,to-principal)
                      (restrictions . ,restrict)
                      (expires . ,expires)
                      (created . ,(current-seconds)))))
    (print "Delegated " capability " to " to-principal)
    delegation))

(define (delegate-chain delegations)
  "Verify a chain of delegations"
  (print "Verifying delegation chain of " (length delegations) " links...")
  (if (null? delegations)
      #t
      (let loop ((chain delegations))
        (if (null? (cdr chain))
            #t
            (loop (cdr chain))))))

(define (delegate-verify delegation principal action)
  "Verify if principal can perform action via delegation"
  (let ((cap (alist-ref 'capability delegation))
        (to (alist-ref 'to delegation)))
    (and (equal? to principal)
         (equal? cap action))))

;;; ============================================================
;;; RFC-023: Agent Sandboxing (Demonic Agents)
;;; ============================================================

(define *sandboxes* '())

(define (sandbox name #!key (capabilities '()) (limits '()))
  "Create a sandboxed execution environment"
  (let ((sb `((name . ,name)
              (capabilities . ,capabilities)
              (limits . ,limits)
              (status . ready))))
    (set! *sandboxes* (cons sb *sandboxes*))
    (print "Sandbox '" name "' created with " (length capabilities) " capabilities")
    sb))

(define (sandbox-run sb-name code)
  "Execute code in a sandbox"
  (print "Executing in sandbox '" sb-name "'...")
  (print "  (sandboxed execution simulated)")
  '(sandbox-result ok))

(define (sandbox-capabilities sb-name)
  "List capabilities available in sandbox"
  (let ((sb (find (lambda (s) (equal? (alist-ref 'name s) sb-name)) *sandboxes*)))
    (if sb
        (alist-ref 'capabilities sb)
        (error "Sandbox not found" sb-name))))

(define (sandbox-destroy sb-name)
  "Destroy a sandbox"
  (set! *sandboxes* (filter (lambda (s) (not (equal? (alist-ref 'name s) sb-name))) *sandboxes*))
  (print "Sandbox '" sb-name "' destroyed"))

;;; ============================================================
;;; RFC-035: Mobile Agents (Quantum Vocabulary)
;;; ============================================================

(define *agent-location* 'local)
(define *entanglements* '())
(define *teleport-grants* '())  ; authorized destinations
(define *teleport-history* '()) ; audit trail

;;; Teleportation Address Syntax:
;;;   local:path          - within current realm
;;;   realm:path          - to named realm
;;;   principal@realm:path - to realm, as principal
;;;   wormhole://host:port/path - via wormhole

(define (parse-teleport-address addr)
  "Parse teleportation address into components"
  (cond
   ((string-contains addr "://")
    ;; wormhole://host:port/path
    (let* ((proto-end (string-contains addr "://"))
           (proto (substring addr 0 proto-end))
           (rest (substring addr (+ proto-end 3) (string-length addr)))
           (slash-pos (string-contains rest "/"))
           (host (if slash-pos (substring rest 0 slash-pos) rest))
           (path (if slash-pos (substring rest slash-pos (string-length rest)) "/")))
      `((protocol . ,proto) (host . ,host) (path . ,path))))
   ((string-contains addr "@")
    ;; principal@realm:path
    (let* ((at-pos (string-contains addr "@"))
           (principal (substring addr 0 at-pos))
           (rest (substring addr (+ at-pos 1) (string-length addr)))
           (colon-pos (string-contains rest ":"))
           (realm (if colon-pos (substring rest 0 colon-pos) rest))
           (path (if colon-pos (substring rest (+ colon-pos 1) (string-length rest)) "/")))
      `((principal . ,principal) (realm . ,realm) (path . ,path))))
   ((string-contains addr ":")
    ;; realm:path
    (let* ((colon-pos (string-contains addr ":"))
           (realm (substring addr 0 colon-pos))
           (path (substring addr (+ colon-pos 1) (string-length addr))))
      `((realm . ,realm) (path . ,path))))
   (else
    ;; local path
    `((realm . local) (path . ,addr)))))

(define (teleport-grant destination #!key (capabilities '(read)) (expires #f) (delegate #f))
  "Grant authorization to teleport to destination"
  (unless (attested?)
    (error "Attestation required to grant teleport authorization"))
  (let ((grant `((destination . ,destination)
                 (capabilities . ,capabilities)
                 (expires . ,expires)
                 (delegatable . ,(and delegate #t))
                 (grantor . ,*node-attestation*)
                 (created . ,(current-seconds)))))
    (set! *teleport-grants* (cons grant *teleport-grants*))
    (print "Granted teleport to: " destination)
    (print "  Capabilities: " capabilities)
    (when expires (print "  Expires: " expires))
    (when delegate (print "  Delegatable: yes"))
    grant))

(define (teleport-check destination capabilities)
  "Check if teleportation is authorized"
  (let ((now (current-seconds)))
    (find (lambda (g)
            (and (equal? (alist-ref 'destination g) destination)
                 (or (not (alist-ref 'expires g))
                     (> (alist-ref 'expires g) now))
                 (every (lambda (c) (member c (alist-ref 'capabilities g)))
                        capabilities)))
          *teleport-grants*)))

(define (teleport destination #!key (state '()) (as #f) (capabilities '(read)))
  "Teleport to destination with authorization check"
  (unless (attested?)
    (error "Attestation required for teleportation"))

  (let ((addr (parse-teleport-address destination)))
    (print "")
    (print "TELEPORT")
    (print "  From: " *agent-location*)
    (print "  To:   " destination)
    (when as (print "  As:   " as))
    (print "  Caps: " capabilities)
    (print "")

    ;; Check authorization
    (let ((grant (teleport-check destination capabilities)))
      (cond
       ((not grant)
        (print "  [DENIED] No authorization for destination")
        (print "  Use (teleport-grant \"" destination "\") to authorize")
        #f)
       (else
        ;; Authorized - execute teleport
        (let ((old-location *agent-location*)
              (record `((from . ,*agent-location*)
                        (to . ,destination)
                        (principal . ,*node-attestation*)
                        (as . ,as)
                        (capabilities . ,capabilities)
                        (state-size . ,(length state))
                        (timestamp . ,(current-seconds)))))
          ;; Audit (critical operation)
          (set! *teleport-history* (cons record *teleport-history*))
          (audit-append actor: *node-attestation*
                        action: 'teleport
                        target: destination
                        detail: record)
          ;; Update location
          (set! *agent-location* destination)
          (print "  [OK] Teleported")
          (print "  State transferred: " (length state) " items")
          (print "")
          `((status . ok)
            (from . ,old-location)
            (to . ,destination)
            (address . ,addr))))))))

(define (teleport-history)
  "Show teleportation audit trail"
  (if (null? *teleport-history*)
      (print "No teleportation history")
      (for-each (lambda (h)
                  (print "  " (alist-ref 'timestamp h) ": "
                         (alist-ref 'from h) " -> " (alist-ref 'to h)))
                *teleport-history*)))

(define (tunnel destination #!key (agent 'self))
  "Tunnel agent to a remote realm (legacy, use teleport)"
  (print "Tunneling " agent " to " destination "...")
  (set! *agent-location* destination)
  `(tunneled ,destination))

(define (observe resource)
  "Observe a resource (collapses superposition)"
  (print "Observing " resource "...")
  `(observed ,resource ,(current-seconds)))

(define (entangle agent1 agent2)
  "Entangle two agents (correlated state)"
  (set! *entanglements* (cons (list agent1 agent2) *entanglements*))
  (print "Entangled " agent1 " <-> " agent2)
  `(entangled ,agent1 ,agent2))

(define (quantum-teleport state from to)
  "Teleport state between entangled agents (quantum channel)"
  (let ((pair (find (lambda (e)
                      (or (and (equal? (car e) from) (equal? (cadr e) to))
                          (and (equal? (car e) to) (equal? (cadr e) from))))
                    *entanglements*)))
    (if pair
        (begin
          (print "Quantum teleporting via entanglement: " from " <-> " to)
          `(teleported ,state ,to))
        (begin
          (print "No entanglement between " from " and " to)
          #f))))

(define (decohere agent)
  "Decohere agent (cleanup, terminate)"
  (print "Decohering " agent "...")
  (set! *agent-location* 'local)
  '(decohered))

(define (superpose states)
  "Create superposition of multiple states"
  `(superposition ,@states))

(define (collapse superposition)
  "Collapse superposition to definite state"
  (if (and (pair? superposition) (eq? (car superposition) 'superposition))
      (let ((states (cdr superposition)))
        (list-ref states (random (length states))))
      superposition))

;;; ============================================================
;;; RFC-036: Quorum Voting (Homomorphic)
;;; ============================================================

(define *quorum-proposals* '())

(define (quorum-propose question options #!key (threshold 'majority))
  "Propose a quorum vote"
  (let ((prop-id (blob->hex (sha512-hash (string->blob question)))))
    (set! *quorum-proposals*
          (cons `((id . ,prop-id)
                  (question . ,question)
                  (options . ,options)
                  (threshold . ,threshold)
                  (votes . ())
                  (status . open))
                *quorum-proposals*))
    (print "Quorum proposal created: " (short-id prop-id))
    prop-id))

(define (quorum-vote prop-id choice #!key (encrypted #t))
  "Cast a vote (optionally homomorphically encrypted)"
  (print "Vote cast for " (short-id prop-id) " [" (if encrypted "encrypted" "plain") "]")
  `(vote-recorded ,choice))

(define (quorum-tally prop-id)
  "Tally votes (threshold decryption for HE votes)"
  (print "Tallying votes for " (short-id prop-id))
  (print "  (homomorphic tally simulated)")
  '(tally-pending))

(define (quorum-status #!optional prop-id)
  "Show quorum voting status"
  (if (null? *quorum-proposals*)
      (print "No active quorum proposals")
      (for-each (lambda (p)
                  (print "  " (short-id (alist-ref 'id p)) " : "
                         (alist-ref 'question p) " [" (alist-ref 'status p) "]"))
                *quorum-proposals*)))

;;; ============================================================
;;; RFC-038: Local Inference (Ollama)
;;; ============================================================

(define *inference-server* "http://localhost:11434")

(define (inference-server #!optional url)
  "Get or set inference server URL"
  (if url
      (begin (set! *inference-server* url) url)
      *inference-server*))

(define (inference-models)
  "List available models (requires Ollama)"
  (print "Querying " *inference-server* "/api/tags ...")
  (print "  (would return model list from Ollama)")
  '(llama3 mistral codellama nomic-embed-text))

(define (inference prompt #!key (model 'llama3) (max-tokens 500))
  "Run inference on local LLM"
  (print "Inference request to " *inference-server*)
  (print "  Model: " model)
  (print "  Prompt: " (if (> (string-length prompt) 50)
                          (string-append (substring prompt 0 50) "...")
                          prompt))
  (print "  (would call Ollama API)")
  '(inference-simulated))

(define (inference-embed text #!key (model 'nomic-embed-text))
  "Generate embeddings for text"
  (print "Generating embeddings with " model "...")
  (print "  (would return vector from Ollama)")
  '(embedding-simulated))

;;; ============================================================
;;; RFC-041: FUSE Filesystem
;;; ============================================================

(define *wormholes* '())
(define *vault-manifest* '())
(define *wormhole-rate-limits* '())
(define *wormhole-ops-count* 0)

;; Capability sets (long form for readability)
(define capability:read-only
  '(read stat readdir xattr-read acl-read))

(define capability:read-write
  '(read write create stat chmod readdir mkdir xattr-read xattr-write))

(define capability:full
  '(read write create delete rename
    stat chmod chown
    xattr-read xattr-write acl-read acl-write
    readdir mkdir rmdir admin delegate audit-read rate-limit))

(define capability:backup
  '(read stat readdir xattr-read acl-read))

(define capability:synchronize
  '(read write create delete rename
    stat chmod readdir mkdir rmdir
    xattr-read xattr-write))

(define (capture-xattrs path)
  "Capture extended attributes from file"
  ;; Would use: xattr -l path
  '())

(define (capture-metadata path)
  "Capture full macOS metadata for a file"
  `((posix
     (mode #o644)
     (uid 501)
     (gid 20)
     (size 0)
     (mtime ,(current-seconds))
     (birthtime ,(current-seconds)))
    (xattr ,(capture-xattrs path))
    (flags ())))

(define (wormhole-audit action path #!optional detail)
  "Log wormhole operation to audit trail"
  (let ((entry `((timestamp . ,(current-seconds))
                 (action . ,action)
                 (path . ,path)
                 (detail . ,detail))))
    (audit-append actor: 'wormhole
                  action: action
                  target: path
                  detail: detail)))

(define (wormhole-rate-check wormhole)
  "Check rate limit for wormhole operations"
  (let* ((fs-path (alist-ref 'fs wormhole))
         (limit (or (alist-ref fs-path *wormhole-rate-limits*) 1000))
         (window-start (- (current-seconds) 60)))
    (set! *wormhole-ops-count* (+ *wormhole-ops-count* 1))
    (if (> *wormhole-ops-count* limit)
        (begin
          (print "  [RATE LIMITED] " *wormhole-ops-count* "/" limit " ops/min")
          #f)
        #t)))

(define (wormhole-open fs-path #!key (vault-path "/") (rate-limit 1000)
                                     (capabilities capability:read-write)
                                     (locked #f) (auth-required '()))
  "Open wormhole between filesystem and vault"
  (let ((abs-path (if (char=? (string-ref fs-path 0) #\/)
                      fs-path
                      (string-append (current-directory) "/" fs-path))))
    (print "Opening wormhole: " abs-path " <-> vault:" vault-path)
    (print "  Capabilities: " (length capabilities) " granted")
    (print "  Rate limit: " rate-limit " ops/min")
    (print "  Locked: " (if locked "yes (requires unlock)" "no"))
    (when (not (null? auth-required))
      (print "  Step-up auth for: " auth-required))
    (print "  Audit: enabled")
    (print "  Requires: FUSE-T or macFUSE")
    (print "")
    (set! *wormholes* (cons `((fs . ,abs-path)
                              (vault . ,vault-path)
                              (status . ,(if locked 'locked 'stable))
                              (capabilities . ,capabilities)
                              (rate-limit . ,rate-limit)
                              (auth-required . ,auth-required)
                              (opened . ,(current-seconds)))
                            *wormholes*))
    (set! *wormhole-rate-limits* (cons (cons abs-path rate-limit) *wormhole-rate-limits*))
    (wormhole-audit 'wormhole-open abs-path `((vault ,vault-path) (capabilities ,(length capabilities))))
    (print "  (wormhole simulated - full implementation requires libfuse)")
    `(wormhole ,abs-path ,vault-path)))

(define (wormhole-lock fs-path)
  "Lock wormhole (requires unlock to resume)"
  (let ((w (find (lambda (w) (equal? (alist-ref 'fs w) fs-path)) *wormholes*)))
    (if w
        (begin
          (set-car! (alist-ref 'status w #f #f) 'locked)
          (wormhole-audit 'wormhole-lock fs-path)
          (print "Wormhole locked: " fs-path)
          `(locked ,fs-path))
        (error "Wormhole not found" fs-path))))

(define (wormhole-unlock fs-path #!key (auth #f))
  "Unlock wormhole (may require authentication)"
  (let ((w (find (lambda (w) (equal? (alist-ref 'fs w) fs-path)) *wormholes*)))
    (if w
        (begin
          ;; In production, verify auth token here
          (wormhole-audit 'wormhole-unlock fs-path `(auth ,(if auth 'provided 'none)))
          (print "Wormhole unlocked: " fs-path)
          `(unlocked ,fs-path))
        (error "Wormhole not found" fs-path))))

(define (wormhole-caps fs-path)
  "Show capabilities for a wormhole"
  (let ((w (find (lambda (w) (equal? (alist-ref 'fs w) fs-path)) *wormholes*)))
    (if w
        (begin
          (print "Capabilities for " fs-path ":")
          (for-each (lambda (c) (print "  " c)) (alist-ref 'capabilities w))
          (alist-ref 'capabilities w))
        (error "Wormhole not found" fs-path))))

(define (wormhole-delegate fs-path new-caps recipient)
  "Delegate subset of wormhole capabilities"
  (let* ((w (find (lambda (w) (equal? (alist-ref 'fs w) fs-path)) *wormholes*))
         (my-caps (and w (alist-ref 'capabilities w))))
    (unless w (error "Wormhole not found" fs-path))
    (unless (every (lambda (c) (member c my-caps)) new-caps)
      (error 'capability-amplification "Cannot delegate capabilities you don't have"))
    (wormhole-audit 'wormhole-delegate fs-path `(to ,recipient caps ,(length new-caps)))
    (print "Delegated " (length new-caps) " capabilities to " recipient)
    `(delegated ,recipient ,new-caps)))

(define (wormhole-close fs-path)
  "Close wormhole"
  (print "Closing wormhole at " fs-path "...")
  (wormhole-audit 'wormhole-close fs-path)
  (set! *wormholes*
        (filter (lambda (w) (not (equal? (alist-ref 'fs w) fs-path)))
                *wormholes*))
  `(closed ,fs-path))

(define (wormholes)
  "List active wormholes"
  (if (null? *wormholes*)
      (print "No active wormholes")
      (for-each (lambda (w)
                  (print "  " (alist-ref 'fs w) " <-> vault:" (alist-ref 'vault w)
                         " [" (alist-ref 'status w) "] "
                         (alist-ref 'rate-limit w) " ops/min"))
                *wormholes*)))

;; Aliases for mount vocabulary
(define vault-mount wormhole-open)
(define vault-unmount wormhole-close)
(define vault-mounts wormholes)

(define (fs-import path #!key (recursive #t))
  "Import macOS path into vault with full metadata"
  (print "Importing " path " into vault...")
  (print "  Capturing: POSIX attrs, xattrs, Finder tags, ACLs")
  (let* ((meta (capture-metadata path))
         (hash (blob->hex (sha512-hash (string->blob path)))))
    (set! *vault-manifest*
          (cons `((path . ,path)
                  (hash . ,hash)
                  (metadata . ,meta))
                *vault-manifest*))
    (print "  Stored as: " (short-id hash))
    `(imported ,path ,hash)))

(define (fs-export hash path)
  "Export vault object to macOS, restoring full metadata"
  (print "Exporting " (short-id hash) " to " path)
  (print "  Restoring: POSIX attrs, xattrs, Finder tags, ACLs")
  (print "  (export simulated)")
  `(exported ,hash ,path))

(define (fs-sync vault-path fs-path)
  "Bidirectional sync between vault and filesystem"
  (print "Syncing " vault-path " <-> " fs-path)
  (print "  Detecting changes...")
  (print "  (bidirectional sync simulated)")
  `(synced ,vault-path ,fs-path))

(define (manifest-list)
  "Show vault manifest entries"
  (if (null? *vault-manifest*)
      (print "Manifest empty")
      (for-each (lambda (e)
                  (print "  " (alist-ref 'path e) " -> "
                         (short-id (alist-ref 'hash e))))
                *vault-manifest*)))

;;; ============================================================
;;; Help
;;; ============================================================

(define (help)
  "Show available commands"
  (print "
Cyberspace REPL - Available Commands:

  Object State (RFC-040):
    (chaotic thing)              Mark thing as chaotic (in flux)
    (commit-thing thing)         Commit: chaotic → quiescent
    (chaotic? thing)             Is thing chaotic?
    (quiescent? thing)           Is thing quiescent?
    (thing-state thing)          Get state (chaotic|quiescent)
    (thing-status thing)         Full status display

  Persistence (RFC-040):
    (persist thing)              Mark thing persistent (vault-bound)
    (ephemeral thing)            Mark thing ephemeral (no promise)
    (persistent? thing)          Is thing persistent?
    (ephemeral? thing)           Is thing ephemeral?
    (thing-durability thing)     Get durability
    (flush-persistence!)         Migrate queued things to vault

  Memos (RFC-043):
    (memo-create title)          Create local memo
    (memo-create t scope: 'federation)  Federation scope
    (memo-create t category: 'experimental)
    (memo-commit memo-id)        Commit memo (chaotic → quiescent)
    (memo-persist memo-id)       Mark memo persistent
    (memo-promote id 'federation) Promote scope
    (memo-list)                  List all memos
    (memo-list 'local)           Filter by scope
    (memo-show memo-id)          Show memo details

  Vault Operations:
    (seal-commit \"message\")         Commit staged changes
    (seal-release \"1.0.0\")          Create a release
    (seal-archive \"1.0.0\")          Archive a release
    (seal-archive \"1.0.0\" format: 'zstd-age)
    (seal-restore \"file.archive\")   Restore from archive
    (seal-history)                   Show commit history
    (seal-update)                    Pull latest changes
    (vault-config 'key)              Get config value
    (vault-config 'key value)        Set config value
    (vault-init signing-key: key)    Initialize vault

  Inspection:
    (seal-inspect \"file.archive\")   Show security/migration properties
    (seal-inspect \"1.0.0\")          Inspect a release version
    (seal-inspect obj verify-key: k) Verify signatures during inspection

  Object Soup (NewtonOS-style):
    (soup)                         List all objects
    (soup 'archives)               Filter by type
    (soup \"*.pub\")                 Glob pattern (* = any, ? = single)
    (soup #/regex/)                Regular expression
    (soup 'keys \"alice*\")          Type + pattern
    (soup?)                        Show query syntax help
    (complete \"gen\")               Complete partial name

  Cryptography:
    (ed25519-keypair)                Generate keypair (pub priv)
    (sha512-hash blob)               Hash data
    (ed25519-sign key msg)           Sign message
    (ed25519-verify pub msg sig)     Verify signature

  Audit Trail:
    (audit-append actor: k action: a) Add audit entry
    (audit-read)                      Read audit trail

  Certificates:
    (create-cert issuer subject tag) Create SPKI cert
    (sign-cert cert key)             Sign certificate
    (verify-signed-cert cert key)    Verify certificate

  Node Roles (RFC-037):
    (node-probe)                     Probe system capabilities
    (node-role)                      Show current role
    (node-role 'witness)             Set role (coordinator/full/witness/archiver/edge)
    (node-can? 'seal-commit)         Check if operation permitted
    (node-announce)                  Announce role to peers

  Lazy Clustering (RFC-016):
    (lazy-join peer uri: u key: k) Join cluster
    (lazy-leave peer)              Leave cluster
    (lazy-push peer)               Push to peer
    (lazy-pull peer)               Pull from peer
    (lazy-sync peer)               Bidirectional sync
    (lazy-status)                  Show cluster status
    (lazy-queue)                   Show pending sync
    (lazy-resolve ver prefer: p)   Resolve conflict

  Federation (RFC-010):
    (federate \"peer-url\")            Establish federation
    (federate-status)                Show federation peers
    (federate-replicate \"url\")       Replicate with peer

  Byzantine Consensus (RFC-011):
    (consensus-propose value)        Propose for consensus
    (consensus-vote id 'accept)      Vote on proposal
    (consensus-status)               Show proposals

  Lamport Clocks (RFC-012):
    (lamport-tick)                   Increment clock
    (lamport-send)                   Get send timestamp
    (lamport-receive ts)             Update on receive
    (lamport-clock)                  Get current value

  Content-Addressed Storage (RFC-020):
    (content-address data)           Compute hash address
    (content-put data)               Store by hash
    (content-get addr)               Retrieve by hash

  Capability Delegation (RFC-021):
    (delegate cap principal)         Delegate capability
    (delegate-chain delegations)     Verify chain
    (delegate-verify d p action)     Check authorization

  Agent Sandboxing (RFC-023):
    (sandbox \"name\" capabilities: c) Create sandbox
    (sandbox-run \"name\" code)        Execute in sandbox
    (sandbox-destroy \"name\")         Remove sandbox

  Mobile Agents (RFC-035):
    (tunnel destination)             Move agent to realm
    (observe resource)               Observe (collapse state)
    (entangle a1 a2)                 Correlate agents
    (teleport state from to)         Transfer state
    (decohere agent)                 Cleanup/terminate
    (superpose states)               Create superposition
    (collapse superposition)         Resolve to one state

  Quorum Voting (RFC-036):
    (quorum-propose q options)       Start vote
    (quorum-vote id choice)          Cast vote (HE encrypted)
    (quorum-tally id)                Tally results
    (quorum-status)                  Show proposals

  Local Inference (RFC-038):
    (inference-server)               Get/set Ollama URL
    (inference-models)               List available models
    (inference prompt model: m)      Run LLM inference
    (inference-embed text)           Generate embeddings

  Wormholes (RFC-041):
    (wormhole-open \"~/Space\")        Open wormhole fs <-> vault
    (wormhole-open p capabilities: capability:read-only)
    (wormhole-open p locked: #t)     Open locked (requires unlock)
    (wormhole-open p auth-required: '(delete))  Step-up auth
    (wormhole-close path)            Close wormhole
    (wormhole-lock path)             Lock (pause operations)
    (wormhole-unlock path auth: tok) Unlock with authentication
    (wormhole-caps path)             Show capabilities
    (wormhole-delegate path capabilities recipient)
    (wormholes)                      List active wormholes
    (fs-import path)                 Import with full metadata
    (fs-export hash path)            Export, restore metadata
    (fs-sync vault-path fs-path)     Bidirectional sync
    (manifest-list)                  Show manifest entries

  Capability Sets:
    capability:read-only             Read, stat, readdir, xattr-read
    capability:read-write            Read, write, create, chmod, mkdir
    capability:full                  All capabilities including admin
    capability:backup                Minimal for backup (read-only)
    capability:synchronize           For bidirectional sync

  Requirements:
    brew install fuse-t              FUSE-T (recommended, no kext)
    brew install macfuse             macFUSE (requires kext)
    brew install ollama              Local LLM inference

  Utilities:
    (blob->hex blob)                 Convert blob to hex
    (hex->blob \"deadbeef\")           Convert hex to blob
    (help)                           Show this help

  Config Keys:
    'signing-key      Ed25519 private key (64 bytes)
    'archive-format   'tarball | 'bundle | 'cryptographic | 'zstd-age
    'age-recipients   List of age public keys
    'age-identity     Path to age identity file
"))

;; Banner
(print "
╔═══════════════════════════════════════════════════════════════╗
║                   Library of Cyberspace                       ║
╠═══════════════════════════════════════════════════════════════╣
║  Type (help) for help                                         ║
╚═══════════════════════════════════════════════════════════════╝
")

;;; ============================================================
;;; Hardware Refresh - always updates node manifest in vault
;;; ============================================================

(define (node-hardware-file)
  "Path to node hardware manifest in vault"
  ".vault/node-hardware")

(define (node-hardware-refresh!)
  "Probe hardware and store in vault"
  (let* ((caps (probe-system-capabilities))
         (hw-file (node-hardware-file))
         (manifest `(node-hardware
                     (platform ,(platform-stamp))
                     (capabilities ,caps)
                     (role ,(recommend-role caps))
                     (timestamp ,(current-seconds)))))
    (with-output-to-file hw-file
      (lambda ()
        (write manifest)
        (newline)))))

;; Show current directory context
(print "Working directory: " (current-directory))
(when (directory-exists? ".vault")
  (print "Vault detected: .vault/")
  (node-hardware-refresh!)
  (print "Hardware: " (platform-stamp)))
(print "")
