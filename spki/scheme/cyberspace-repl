#!/usr/bin/env csi -q -w
;;; cyberspace-repl - Interactive REPL for the Library of Cyberspace
;;;
;;; Usage: ./cyberspace-repl
;;;
;;; Preloads all Cyberspace modules for interactive exploration:
;;;   - vault: seal-commit, seal-release, seal-archive, etc.
;;;   - crypto-ffi: ed25519-keypair, sha512-hash, etc.
;;;   - audit: audit-append, audit-read, etc.
;;;   - cert: SPKI certificates
;;;   - sexp: S-expression handling

(import scheme
        (chicken base)
        (chicken format)
        (chicken repl)
        (chicken file)
        (chicken io)
        (chicken time)
        (chicken process-context)
        (chicken process)
        (chicken blob)
        (chicken file posix)
        srfi-4)

;;; ============================================================
;;; Bootstrap: Mixed-Architecture Defense
;;; ============================================================
;;; Ensures compiled modules match current architecture.
;;; Rebuilds automatically if arch mismatch or source newer.

(define (current-arch)
  "Detect current CPU architecture"
  (let ((result (with-input-from-pipe "uname -m" read-line)))
    (if (eof-object? result) "unknown" result)))

(define (current-os)
  "Detect current operating system"
  (let ((result (with-input-from-pipe "uname -s" read-line)))
    (if (eof-object? result) "unknown" result)))

(define (libsodium-paths arch)
  "Return (include-path lib-path) for libsodium based on architecture and OS"
  (let ((os (current-os)))
    (cond
     ;; macOS ARM (M1/M2/M3)
     ((and (string=? os "Darwin") (string=? arch "arm64"))
      '("/opt/homebrew/include" "/opt/homebrew/lib"))
     ;; macOS Intel
     ((string=? os "Darwin")
      '("/usr/local/include" "/usr/local/lib"))
     ;; Linux (Fedora, Ubuntu, etc.) - system packages
     ((string=? os "Linux")
      '("/usr/include" "/usr/lib64"))  ; Fedora uses lib64 for x86_64
     ;; Fallback
     (else
      '("/usr/local/include" "/usr/local/lib")))))

(define (arch-stamp-file module)
  "Path to architecture stamp file for module"
  (string-append "." module ".arch"))

(define (read-arch-stamp module)
  "Read stored architecture for a compiled module"
  (let ((stamp-file (arch-stamp-file module)))
    (if (file-exists? stamp-file)
        (with-input-from-file stamp-file read-line)
        #f)))

(define (write-arch-stamp module arch)
  "Write architecture stamp for compiled module"
  (with-output-to-file (arch-stamp-file module)
    (lambda () (print arch))))

(define (file-mtime path)
  "Get file modification time, or 0 if doesn't exist"
  (if (file-exists? path)
      (file-modification-time path)
      0))

(define (needs-rebuild? module arch)
  "Check if module needs rebuilding: missing, arch mismatch, or source newer"
  (let* ((src (string-append module ".scm"))
         (so  (string-append module ".so"))
         (import-scm (string-append module ".import.scm"))
         (stored-arch (read-arch-stamp module)))
    (or (not (file-exists? so))
        (not (file-exists? import-scm))
        (not stored-arch)
        (not (string=? stored-arch arch))
        (> (file-mtime src) (file-mtime so)))))

(define (rebuild-module! module arch stamp)
  "Rebuild a module for current platform"
  (let* ((paths (libsodium-paths arch))
         (inc-path (car paths))
         (lib-path (cadr paths))
         (src (string-append module ".scm")))
    (print "")
    (print "┌─ BOOTSTRAP: Rebuilding " module " for " stamp " ─┐")
    (let ((cmd (if (string=? module "crypto-ffi")
                   ;; crypto-ffi needs libsodium
                   (string-append "csc -shared -J " src
                                  " -I" inc-path
                                  " -L" lib-path
                                  " -L -lsodium 2>&1")
                   ;; other modules (vault, etc)
                   (string-append "csc -shared -J " src " 2>&1"))))
      (print "  " cmd)
      (let ((result (with-input-from-pipe cmd
                      (lambda ()
                        (let loop ((lines '()))
                          (let ((line (read-line)))
                            (if (eof-object? line)
                                (reverse lines)
                                (loop (cons line lines)))))))))
        ;; Print any output (warnings/errors)
        (for-each (lambda (line) (print "  " line)) result)
        ;; Check if .so was created
        (if (file-exists? (string-append module ".so"))
            (begin
              (write-arch-stamp module stamp)
              (print "  ✓ Built successfully")
              (print "└" (make-string 45 #\─) "┘")
              (print "")
              #t)
            (begin
              (print "  ✗ Build FAILED")
              (print "└" (make-string 45 #\─) "┘")
              (print "")
              (exit 1)))))))

(define (platform-stamp)
  "Return OS+arch stamp (e.g., 'Darwin-arm64', 'Linux-x86_64')"
  (string-append (current-os) "-" (current-arch)))

(define (bootstrap-modules!)
  "Ensure all required modules are built for current platform"
  (let ((stamp (platform-stamp))
        (arch (current-arch))
        (modules '("crypto-ffi" "vault")))
    (for-each
     (lambda (module)
       (when (needs-rebuild? module stamp)
         (rebuild-module! module arch stamp)))
     modules)))

;; Run bootstrap before loading modules
(bootstrap-modules!)

;; Load cyberspace modules (now guaranteed to be correct arch)
(import crypto-ffi)
(import vault)
(import audit)
(import cert)
(import sexp)

;; Initialize libsodium
(sodium-init)

;; Helper utilities
(define (blob->hex b)
  "Convert blob to hex string"
  (define (byte->hex n)
    (let ((s (number->string n 16)))
      (if (= (string-length s) 1)
          (string-append "0" s)
          s)))
  (let ((vec (blob->u8vector b)))
    (let loop ((i 0) (acc '()))
      (if (= i (u8vector-length vec))
          (apply string-append (reverse acc))
          (loop (+ i 1)
                (cons (byte->hex (u8vector-ref vec i)) acc))))))

(define (hex->blob hex-str)
  "Convert hex string to blob"
  (let* ((len (quotient (string-length hex-str) 2))
         (vec (make-u8vector len)))
    (do ((i 0 (+ i 1)))
        ((= i len) (u8vector->blob vec))
      (let* ((hex-byte (substring hex-str (* i 2) (+ (* i 2) 2)))
             (byte-val (string->number hex-byte 16)))
        (u8vector-set! vec i byte-val)))))

;;; ============================================================
;;; RFC-016: Lazy Clustering
;;; ============================================================

(define *lazy-peers* '())
(define *lazy-queue* '())
(define *version-vectors* '())

(define (lazy-join peer #!key (uri #f) (key #f))
  "Register a peer for lazy sync"
  (set! *lazy-peers* (cons `((peer . ,peer) (uri . ,uri) (key . ,key) (last-sync . never)) *lazy-peers*))
  (print "Joined lazy cluster with " peer)
  `(joined ,peer))

(define (lazy-leave peer)
  "Remove peer from lazy cluster"
  (set! *lazy-peers* (filter (lambda (p) (not (equal? (alist-ref 'peer p) peer))) *lazy-peers*))
  (print "Left lazy cluster: " peer)
  `(left ,peer))

(define (lazy-push peer)
  "Push local releases to peer"
  (print "Pushing to " peer "...")
  (print "  (lazy push simulated)")
  `(pushed ,peer))

(define (lazy-pull peer)
  "Pull releases from peer"
  (print "Pulling from " peer "...")
  (print "  (lazy pull simulated)")
  `(pulled ,peer))

(define (lazy-sync peer)
  "Bidirectional sync with peer"
  (print "Syncing with " peer "...")
  (lazy-push peer)
  (lazy-pull peer)
  `(synced ,peer))

(define (lazy-status)
  "Show lazy cluster status"
  (if (null? *lazy-peers*)
      (print "No lazy cluster peers configured")
      (begin
        (print "Lazy cluster peers:")
        (for-each (lambda (p)
                    (print "  " (alist-ref 'peer p) " [" (alist-ref 'last-sync p) "]"))
                  *lazy-peers*))))

(define (lazy-queue)
  "Show pending sync queue"
  (if (null? *lazy-queue*)
      (print "Sync queue empty")
      (begin
        (print "Pending sync:")
        (for-each (lambda (item) (print "  " item)) *lazy-queue*))))

(define (lazy-resolve version #!key (prefer 'local) (merged #f))
  "Resolve a sync conflict"
  (print "Resolving " version " -> " (or merged prefer))
  `(resolved ,version ,(or merged prefer)))

(define (lazy-beacon)
  "Send optional presence beacon"
  `(beacon
    (peer ,(current-directory))
    (lamport-time ,*lamport-clock*)
    (status available)))

;;; ============================================================
;;; RFC-010: Federation
;;; ============================================================

(define *federation-peers* '())

(define (federate peer-url #!key (trust 'partial))
  "Establish federation with a peer realm"
  (set! *federation-peers* (cons `((url . ,peer-url) (trust . ,trust) (status . pending)) *federation-peers*))
  (print "Federation request sent to " peer-url)
  `(federation-pending ,peer-url))

(define (federate-status)
  "Show federation status with all peers"
  (if (null? *federation-peers*)
      (print "No federation peers configured")
      (for-each (lambda (p)
                  (print "  " (alist-ref 'url p) " [" (alist-ref 'trust p) "] " (alist-ref 'status p)))
                *federation-peers*)))

(define (federate-replicate peer-url)
  "Replicate with a federated peer"
  (print "Replicating with " peer-url "...")
  '(replicate-complete))

;;; ============================================================
;;; RFC-011: Byzantine Consensus
;;; ============================================================

(define *consensus-proposals* '())

(define (consensus-propose value #!key (quorum 'majority))
  "Propose a value for Byzantine consensus"
  (let ((proposal-id (blob->hex (sha512-hash (string->blob (format "~a~a" value (current-seconds)))))))
    (set! *consensus-proposals* (cons `((id . ,proposal-id) (value . ,value) (quorum . ,quorum) (votes . ())) *consensus-proposals*))
    (print "Proposal " (substring proposal-id 0 16) "... created")
    proposal-id))

(define (consensus-vote proposal-id vote #!key (signature #f))
  "Vote on a consensus proposal (vote: 'accept | 'reject)"
  (print "Vote " vote " recorded for " (substring proposal-id 0 16) "...")
  `(vote-recorded ,vote))

(define (consensus-status #!optional proposal-id)
  "Show consensus status"
  (if (null? *consensus-proposals*)
      (print "No active proposals")
      (for-each (lambda (p)
                  (print "  " (substring (alist-ref 'id p) 0 16) "... : " (alist-ref 'value p)))
                *consensus-proposals*)))

;;; ============================================================
;;; RFC-012: Lamport Clocks
;;; ============================================================

(define *lamport-clock* 0)

(define (lamport-tick)
  "Increment local Lamport clock"
  (set! *lamport-clock* (+ *lamport-clock* 1))
  *lamport-clock*)

(define (lamport-send)
  "Get timestamp for sending a message"
  (lamport-tick))

(define (lamport-receive remote-timestamp)
  "Update clock on message receipt"
  (set! *lamport-clock* (+ 1 (max *lamport-clock* remote-timestamp)))
  *lamport-clock*)

(define (lamport-compare t1 t2)
  "Compare two Lamport timestamps: -1 (before), 0 (concurrent), 1 (after)"
  (cond ((< t1 t2) -1)
        ((> t1 t2) 1)
        (else 0)))

(define (lamport-clock)
  "Get current Lamport clock value"
  *lamport-clock*)

;;; ============================================================
;;; RFC-020: Content-Addressed Storage
;;; ============================================================

(define *content-store* '())

(define (content-address data)
  "Compute content address (hash) for data"
  (let ((hash (sha512-hash (if (blob? data) data (string->blob data)))))
    (blob->hex hash)))

(define (content-put data)
  "Store data by content address, return address"
  (let* ((addr (content-address data))
         (blob-data (if (blob? data) data (string->blob data))))
    (set! *content-store* (cons (cons addr blob-data) *content-store*))
    (print "Stored at " (substring addr 0 16) "...")
    addr))

(define (content-get addr)
  "Retrieve data by content address"
  (let ((entry (assoc addr *content-store*)))
    (if entry
        (cdr entry)
        (error "Content not found" addr))))

(define (content-exists? addr)
  "Check if content exists"
  (if (assoc addr *content-store*) #t #f))

;;; ============================================================
;;; RFC-021: Capability Delegation
;;; ============================================================

(define (delegate capability to-principal #!key (restrict '()) (expires #f))
  "Delegate a capability to another principal"
  (let ((delegation `((capability . ,capability)
                      (to . ,to-principal)
                      (restrictions . ,restrict)
                      (expires . ,expires)
                      (created . ,(current-seconds)))))
    (print "Delegated " capability " to " to-principal)
    delegation))

(define (delegate-chain delegations)
  "Verify a chain of delegations"
  (print "Verifying delegation chain of " (length delegations) " links...")
  (if (null? delegations)
      #t
      (let loop ((chain delegations))
        (if (null? (cdr chain))
            #t
            (loop (cdr chain))))))

(define (delegate-verify delegation principal action)
  "Verify if principal can perform action via delegation"
  (let ((cap (alist-ref 'capability delegation))
        (to (alist-ref 'to delegation)))
    (and (equal? to principal)
         (equal? cap action))))

;;; ============================================================
;;; RFC-023: Agent Sandboxing (Demonic Agents)
;;; ============================================================

(define *sandboxes* '())

(define (sandbox name #!key (capabilities '()) (limits '()))
  "Create a sandboxed execution environment"
  (let ((sb `((name . ,name)
              (capabilities . ,capabilities)
              (limits . ,limits)
              (status . ready))))
    (set! *sandboxes* (cons sb *sandboxes*))
    (print "Sandbox '" name "' created with " (length capabilities) " capabilities")
    sb))

(define (sandbox-run sb-name code)
  "Execute code in a sandbox"
  (print "Executing in sandbox '" sb-name "'...")
  (print "  (sandboxed execution simulated)")
  '(sandbox-result ok))

(define (sandbox-capabilities sb-name)
  "List capabilities available in sandbox"
  (let ((sb (find (lambda (s) (equal? (alist-ref 'name s) sb-name)) *sandboxes*)))
    (if sb
        (alist-ref 'capabilities sb)
        (error "Sandbox not found" sb-name))))

(define (sandbox-destroy sb-name)
  "Destroy a sandbox"
  (set! *sandboxes* (filter (lambda (s) (not (equal? (alist-ref 'name s) sb-name))) *sandboxes*))
  (print "Sandbox '" sb-name "' destroyed"))

;;; ============================================================
;;; RFC-035: Mobile Agents (Quantum Vocabulary)
;;; ============================================================

(define *agent-location* 'local)
(define *entanglements* '())

(define (tunnel destination #!key (agent 'self))
  "Tunnel agent to a remote realm"
  (print "Tunneling " agent " to " destination "...")
  (set! *agent-location* destination)
  `(tunneled ,destination))

(define (observe resource)
  "Observe a resource (collapses superposition)"
  (print "Observing " resource "...")
  `(observed ,resource ,(current-seconds)))

(define (entangle agent1 agent2)
  "Entangle two agents (correlated state)"
  (set! *entanglements* (cons (list agent1 agent2) *entanglements*))
  (print "Entangled " agent1 " <-> " agent2)
  `(entangled ,agent1 ,agent2))

(define (teleport state from to)
  "Teleport state between entangled agents"
  (print "Teleporting state from " from " to " to)
  `(teleported ,state ,to))

(define (decohere agent)
  "Decohere agent (cleanup, terminate)"
  (print "Decohering " agent "...")
  (set! *agent-location* 'local)
  '(decohered))

(define (superpose states)
  "Create superposition of multiple states"
  `(superposition ,@states))

(define (collapse superposition)
  "Collapse superposition to definite state"
  (if (and (pair? superposition) (eq? (car superposition) 'superposition))
      (let ((states (cdr superposition)))
        (list-ref states (random (length states))))
      superposition))

;;; ============================================================
;;; RFC-036: Quorum Voting (Homomorphic)
;;; ============================================================

(define *quorum-proposals* '())

(define (quorum-propose question options #!key (threshold 'majority))
  "Propose a quorum vote"
  (let ((prop-id (blob->hex (sha512-hash (string->blob question)))))
    (set! *quorum-proposals*
          (cons `((id . ,prop-id)
                  (question . ,question)
                  (options . ,options)
                  (threshold . ,threshold)
                  (votes . ())
                  (status . open))
                *quorum-proposals*))
    (print "Quorum proposal created: " (substring prop-id 0 16) "...")
    prop-id))

(define (quorum-vote prop-id choice #!key (encrypted #t))
  "Cast a vote (optionally homomorphically encrypted)"
  (print "Vote cast for " (substring prop-id 0 16) "... [" (if encrypted "encrypted" "plain") "]")
  `(vote-recorded ,choice))

(define (quorum-tally prop-id)
  "Tally votes (threshold decryption for HE votes)"
  (print "Tallying votes for " (substring prop-id 0 16) "...")
  (print "  (homomorphic tally simulated)")
  '(tally-pending))

(define (quorum-status #!optional prop-id)
  "Show quorum voting status"
  (if (null? *quorum-proposals*)
      (print "No active quorum proposals")
      (for-each (lambda (p)
                  (print "  " (substring (alist-ref 'id p) 0 16) "... : "
                         (alist-ref 'question p) " [" (alist-ref 'status p) "]"))
                *quorum-proposals*)))

;;; ============================================================
;;; RFC-038: Local Inference (Ollama)
;;; ============================================================

(define *inference-server* "http://localhost:11434")

(define (inference-server #!optional url)
  "Get or set inference server URL"
  (if url
      (begin (set! *inference-server* url) url)
      *inference-server*))

(define (inference-models)
  "List available models (requires Ollama)"
  (print "Querying " *inference-server* "/api/tags ...")
  (print "  (would return model list from Ollama)")
  '(llama3 mistral codellama nomic-embed-text))

(define (inference prompt #!key (model 'llama3) (max-tokens 500))
  "Run inference on local LLM"
  (print "Inference request to " *inference-server*)
  (print "  Model: " model)
  (print "  Prompt: " (if (> (string-length prompt) 50)
                          (string-append (substring prompt 0 50) "...")
                          prompt))
  (print "  (would call Ollama API)")
  '(inference-simulated))

(define (inference-embed text #!key (model 'nomic-embed-text))
  "Generate embeddings for text"
  (print "Generating embeddings with " model "...")
  (print "  (would return vector from Ollama)")
  '(embedding-simulated))

;;; ============================================================
;;; Help
;;; ============================================================

(define (help)
  "Show available commands"
  (print "
Cyberspace REPL - Available Commands:

  Vault Operations:
    (seal-commit \"message\")         Commit staged changes
    (seal-release \"1.0.0\")          Create a release
    (seal-archive \"1.0.0\")          Archive a release
    (seal-archive \"1.0.0\" format: 'zstd-age)
    (seal-restore \"file.archive\")   Restore from archive
    (seal-history)                   Show commit history
    (seal-update)                    Pull latest changes
    (vault-config 'key)              Get config value
    (vault-config 'key value)        Set config value
    (vault-init signing-key: key)    Initialize vault

  Inspection:
    (seal-inspect \"file.archive\")   Show security/migration properties
    (seal-inspect \"1.0.0\")          Inspect a release version
    (seal-inspect obj verify-key: k) Verify signatures during inspection

  Object Soup (NewtonOS-style):
    (soup)                         List all objects
    (soup 'archives)               Filter by type
    (soup \"*.pub\")                 Glob pattern (* = any, ? = single)
    (soup #/regex/)                Regular expression
    (soup 'keys \"alice*\")          Type + pattern
    (soup?)                        Show query syntax help
    (complete \"gen\")               Complete partial name

  Cryptography:
    (ed25519-keypair)                Generate keypair (pub priv)
    (sha512-hash blob)               Hash data
    (ed25519-sign key msg)           Sign message
    (ed25519-verify pub msg sig)     Verify signature

  Audit Trail:
    (audit-append actor: k action: a) Add audit entry
    (audit-read)                      Read audit trail

  Certificates:
    (create-cert issuer subject tag) Create SPKI cert
    (sign-cert cert key)             Sign certificate
    (verify-signed-cert cert key)    Verify certificate

  Node Roles (RFC-037):
    (node-probe)                     Probe system capabilities
    (node-role)                      Show current role
    (node-role 'witness)             Set role (coordinator/full/witness/archiver/edge)
    (node-can? 'seal-commit)         Check if operation permitted
    (node-announce)                  Announce role to peers

  Lazy Clustering (RFC-016):
    (lazy-join peer uri: u key: k) Join cluster
    (lazy-leave peer)              Leave cluster
    (lazy-push peer)               Push to peer
    (lazy-pull peer)               Pull from peer
    (lazy-sync peer)               Bidirectional sync
    (lazy-status)                  Show cluster status
    (lazy-queue)                   Show pending sync
    (lazy-resolve ver prefer: p)   Resolve conflict

  Federation (RFC-010):
    (federate \"peer-url\")            Establish federation
    (federate-status)                Show federation peers
    (federate-replicate \"url\")       Replicate with peer

  Byzantine Consensus (RFC-011):
    (consensus-propose value)        Propose for consensus
    (consensus-vote id 'accept)      Vote on proposal
    (consensus-status)               Show proposals

  Lamport Clocks (RFC-012):
    (lamport-tick)                   Increment clock
    (lamport-send)                   Get send timestamp
    (lamport-receive ts)             Update on receive
    (lamport-clock)                  Get current value

  Content-Addressed Storage (RFC-020):
    (content-address data)           Compute hash address
    (content-put data)               Store by hash
    (content-get addr)               Retrieve by hash

  Capability Delegation (RFC-021):
    (delegate cap principal)         Delegate capability
    (delegate-chain delegations)     Verify chain
    (delegate-verify d p action)     Check authorization

  Agent Sandboxing (RFC-023):
    (sandbox \"name\" capabilities: c) Create sandbox
    (sandbox-run \"name\" code)        Execute in sandbox
    (sandbox-destroy \"name\")         Remove sandbox

  Mobile Agents (RFC-035):
    (tunnel destination)             Move agent to realm
    (observe resource)               Observe (collapse state)
    (entangle a1 a2)                 Correlate agents
    (teleport state from to)         Transfer state
    (decohere agent)                 Cleanup/terminate
    (superpose states)               Create superposition
    (collapse superposition)         Resolve to one state

  Quorum Voting (RFC-036):
    (quorum-propose q options)       Start vote
    (quorum-vote id choice)          Cast vote (HE encrypted)
    (quorum-tally id)                Tally results
    (quorum-status)                  Show proposals

  Local Inference (RFC-038):
    (inference-server)               Get/set Ollama URL
    (inference-models)               List available models
    (inference prompt model: m)      Run LLM inference
    (inference-embed text)           Generate embeddings

  Utilities:
    (blob->hex blob)                 Convert blob to hex
    (hex->blob \"deadbeef\")           Convert hex to blob
    (help)                           Show this help

  Config Keys:
    'signing-key      Ed25519 private key (64 bytes)
    'archive-format   'tarball | 'bundle | 'cryptographic | 'zstd-age
    'age-recipients   List of age public keys
    'age-identity     Path to age identity file
"))

;; Banner
(print "
╔═══════════════════════════════════════════════════════════════╗
║           LIBRARY OF CYBERSPACE - Interactive REPL            ║
╠═══════════════════════════════════════════════════════════════╣
║  Modules: vault, crypto-ffi, audit, cert, sexp                ║
║  Type (help) for available commands                           ║
╚═══════════════════════════════════════════════════════════════╝
")

;;; ============================================================
;;; Hardware Refresh - always updates node manifest in vault
;;; ============================================================

(define (node-hardware-file)
  "Path to node hardware manifest in vault"
  ".vault/node-hardware")

(define (node-hardware-refresh!)
  "Probe hardware and store in vault"
  (let* ((caps (probe-system-capabilities))
         (hw-file (node-hardware-file))
         (manifest `(node-hardware
                     (platform ,(platform-stamp))
                     (capabilities ,caps)
                     (role ,(recommend-role caps))
                     (timestamp ,(current-seconds)))))
    (with-output-to-file hw-file
      (lambda ()
        (write manifest)
        (newline)))))

;; Show current directory context
(print "Working directory: " (current-directory))
(when (directory-exists? ".vault")
  (print "Vault detected: .vault/")
  (node-hardware-refresh!)
  (print "Hardware: " (platform-stamp)))
(print "")
