<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Module (chicken base) - The CHICKEN Scheme wiki</title>
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel="stylesheet" type="text/css" href="/chicken.css" />
<meta name="viewport" content="width=device-width, initial-scale=1" /></head>
<body>
<div id="menu">
<ul>
<li><a href="/" class="internal">Wiki</a></li>
<li><a href="//code.call-cc.org/" class="external">Download</a></li>
<li><a href="/manual/index" class="internal">Manual</a></li>
<li><a href="//eggs.call-cc.org" class="external">Eggs</a></li>
<li><a href="//api.call-cc.org/5/doc/" class="external">API</a></li>
<li><a href="//tests.call-cc.org/" class="external">Tests</a></li>
<li><a href="//bugs.call-cc.org/" class="external">Bugs</a></li></ul></div>
<ul id="page-specific-links">
<li><a href="?action=show">show</a></li>
<li><a href="?action=edit" rel="nofollow">edit</a></li>
<li><a href="?action=history">history</a></li></ul>
<div id="content">
<ul class="tags">
<li>manual</li></ul>
<div id="toc">
<ol>
<li><a href="#module-chicken-base">Module (chicken base)</a>
<ol>
<li><a href="#numeric-predicates">Numeric predicates</a>
<ol>
<li><a href="#fixnum">fixnum?</a></li>
<li><a href="#flonum">flonum?</a></li>
<li><a href="#bignum">bignum?</a></li>
<li><a href="#exact-integer">exact-integer?</a></li>
<li><a href="#cplxnum">cplxnum?</a></li>
<li><a href="#ratnum">ratnum?</a></li>
<li><a href="#nan">nan?</a></li>
<li><a href="#infinite">infinite?</a></li>
<li><a href="#finite">finite?</a></li>
<li><a href="#equal">equal=?</a></li></ol></li>
<li><a href="#arithmetic">Arithmetic</a>
<ol>
<li><a href="#add1sub1">add1/sub1</a></li>
<li><a href="#exact-integer-sqrt">exact-integer-sqrt</a></li>
<li><a href="#exact-integer-nth-root">exact-integer-nth-root</a></li>
<li><a href="#division-with-quotient-and-remainder">Division with quotient and remainder</a></li>
<li><a href="#signum">signum</a></li></ol></li>
<li><a href="#weak-pairs">Weak pairs</a>
<ol>
<li><a href="#weak-cons">weak-cons</a></li></ol></li>
<li><a href="#lazy-evaluation">Lazy evaluation</a>
<ol>
<li><a href="#delay-force">delay-force</a></li>
<li><a href="#make-promise">make-promise</a></li>
<li><a href="#promise">promise?</a></li></ol></li>
<li><a href="#inputoutput">Input/Output</a>
<ol>
<li><a href="#current-error-port">current-error-port</a></li>
<li><a href="#print">print</a></li>
<li><a href="#print">print*</a></li></ol></li>
<li><a href="#interrupts-and-error-handling">Interrupts and error-handling</a>
<ol>
<li><a href="#enable-warnings">enable-warnings</a></li>
<li><a href="#error">error</a></li>
<li><a href="#assert">assert</a></li>
<li><a href="#get-call-chain">get-call-chain</a></li>
<li><a href="#print-call-chain">print-call-chain</a></li>
<li><a href="#procedure-information">procedure-information</a></li>
<li><a href="#warning">warning</a></li></ol></li>
<li><a href="#lists">Lists</a>
<ol>
<li><a href="#alist-ref">alist-ref</a></li>
<li><a href="#alist-update">alist-update</a></li>
<li><a href="#atom">atom?</a></li>
<li><a href="#butlast">butlast</a></li>
<li><a href="#chop">chop</a></li>
<li><a href="#compress">compress</a></li>
<li><a href="#flatten">flatten</a></li>
<li><a href="#foldl">foldl</a></li>
<li><a href="#foldr">foldr</a></li>
<li><a href="#intersperse">intersperse</a></li>
<li><a href="#join">join</a></li>
<li><a href="#rassoc">rassoc</a></li>
<li><a href="#tail">tail?</a></li></ol></li>
<li><a href="#vectors">Vectors</a>
<ol>
<li><a href="#vector-copy">vector-copy!</a></li>
<li><a href="#vector-resize">vector-resize</a></li>
<li><a href="#subvector">subvector</a></li></ol></li>
<li><a href="#combinators">Combinators</a>
<ol>
<li><a href="#constantly">constantly</a></li>
<li><a href="#complement">complement</a></li>
<li><a href="#compose">compose</a></li>
<li><a href="#conjoin">conjoin</a></li>
<li><a href="#disjoin">disjoin</a></li>
<li><a href="#each">each</a></li>
<li><a href="#flip">flip</a></li>
<li><a href="#identity">identity</a></li>
<li><a href="#list-of">list-of?</a></li>
<li><a href="#o">o</a></li></ol></li>
<li><a href="#user-defined-named-characters">User-defined named characters</a>
<ol>
<li><a href="#char-name">char-name</a></li></ol></li>
<li><a href="#the-unspecified-value">The unspecified value</a>
<ol>
<li><a href="#void">void</a></li></ol></li>
<li><a href="#continuations">Continuations</a>
<ol>
<li><a href="#callcc">call/cc</a></li></ol></li>
<li><a href="#symbols">Symbols</a>
<ol>
<li><a href="#symbol-utilities">Symbol utilities</a>
<ol>
<li><a href="#symbol-append">symbol-append</a></li></ol></li>
<li><a href="#uninterned-symbols-gensyms">Uninterned symbols (&quot;gensyms&quot;)</a>
<ol>
<li><a href="#gensym">gensym</a></li>
<li><a href="#string-uninterned-symbol">string-&gt;uninterned-symbol</a></li></ol></li></ol></li>
<li><a href="#setters">Setters</a>
<ol>
<li><a href="#setter">setter</a></li>
<li><a href="#getter-with-setter">getter-with-setter</a></li></ol></li>
<li><a href="#binding-forms-for-optional-arguments">Binding forms for optional arguments</a>
<ol>
<li><a href="#optional">optional</a></li>
<li><a href="#case-lambda">case-lambda</a></li>
<li><a href="#let-optionals">let-optionals</a></li>
<li><a href="#let-optionals">let-optionals*</a></li></ol></li>
<li><a href="#other-binding-forms">Other binding forms</a>
<ol>
<li><a href="#and-let">and-let*</a></li>
<li><a href="#letrec">letrec*</a></li>
<li><a href="#rec">rec</a></li>
<li><a href="#cut">cut</a></li>
<li><a href="#define-values">define-values</a></li>
<li><a href="#fluid-let">fluid-let</a></li>
<li><a href="#let-values">let-values</a></li>
<li><a href="#let-values">let*-values</a></li>
<li><a href="#letrec-values">letrec-values</a></li>
<li><a href="#receive">receive</a></li>
<li><a href="#set-values">set!-values</a></li>
<li><a href="#nth-value">nth-value</a></li></ol></li>
<li><a href="#parameters">Parameters</a>
<ol>
<li><a href="#parameterize">parameterize</a></li>
<li><a href="#make-parameter">make-parameter</a></li></ol></li>
<li><a href="#substitution-forms-and-macros">Substitution forms and macros</a>
<ol>
<li><a href="#define-constant">define-constant</a></li>
<li><a href="#define-inline">define-inline</a></li></ol></li>
<li><a href="#conditional-forms">Conditional forms</a>
<ol>
<li><a href="#unless">unless</a></li>
<li><a href="#when">when</a></li></ol></li>
<li><a href="#record-structures">Record structures</a>
<ol>
<li><a href="#define-record">define-record</a>
<ol>
<li><a href="#srfi-17-setters">SRFI-17 setters</a></li></ol></li>
<li><a href="#define-record-type">define-record-type</a></li>
<li><a href="#record-printer">record-printer</a></li>
<li><a href="#set-record-printer">set-record-printer!</a></li></ol></li>
<li><a href="#other-forms">Other forms</a>
<ol>
<li><a href="#include">include</a></li>
<li><a href="#include-relative">include-relative</a></li></ol></li>
<li><a href="#making-extra-libraries-and-extensions-available">Making extra libraries and extensions available</a>
<ol>
<li><a href="#require-extension">require-extension</a></li>
<li><a href="#require-library">require-library</a></li></ol></li>
<li><a href="#process-shutdown">Process shutdown</a>
<ol>
<li><a href="#emergency-exit">emergency-exit</a></li>
<li><a href="#exit">exit</a></li></ol></li>
<li><a href="#exit-handler">exit-handler</a></li>
<li><a href="#implicit-exit-handler">implicit-exit-handler</a>
<ol>
<li><a href="#on-exit">on-exit</a></li></ol></li>
<li><a href="#system-interface">System interface</a>
<ol>
<li><a href="#sleep">sleep</a></li></ol></li>
<li><a href="#ports">Ports</a>
<ol>
<li><a href="#string-ports">String ports</a>
<ol>
<li><a href="#get-output-string">get-output-string</a></li>
<li><a href="#open-input-string">open-input-string</a></li>
<li><a href="#open-output-string">open-output-string</a></li></ol></li></ol></li>
<li><a href="#file-inputoutput">File Input/Output</a>
<ol>
<li><a href="#flush-output">flush-output</a></li></ol></li>
<li><a href="#port-predicates">Port predicates</a>
<ol>
<li><a href="#input-port-open">input-port-open?</a></li>
<li><a href="#port-closed">port-closed?</a></li>
<li><a href="#port">port?</a></li></ol></li>
<li><a href="#built-in-parameters">Built-in parameters</a>
<ol>
<li><a href="#case-sensitive">case-sensitive</a></li>
<li><a href="#keyword-style">keyword-style</a></li>
<li><a href="#parentheses-synonyms">parentheses-synonyms</a></li>
<li><a href="#symbol-escape">symbol-escape</a></li></ol></li></ol></li></ol></div><a href="#module-chicken-base">
<h2 id="module-chicken-base">Module (chicken base)</h2></a>
<p>Core procedures and macros, acting as basic extensions to the R5RS standard and other essential features.</p>
<p>This module is used by default, unless a program is compiled with the <tt>-explicit-use</tt> option.</p><a href="#numeric-predicates">
<h3 id="numeric-predicates">Numeric predicates</h3></a>
<p>These allow you to make a more precise differentiation between number types and their properties, not provided by R5RS.</p><a href="#fixnum">
<h4 id="fixnum">fixnum?</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(fixnum? X)</tt>
<br /></span>
<p>Returns <tt>#t</tt> if <tt>X</tt> is a fixnum, or <tt>#f</tt> otherwise.</p><a href="#flonum">
<h4 id="flonum">flonum?</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(flonum? X)</tt>
<br /></span>
<p>Returns <tt>#t</tt> if <tt>X</tt> is a flonum, or <tt>#f</tt> otherwise.</p><a href="#bignum">
<h4 id="bignum">bignum?</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(bignum? X)</tt>
<br /></span>
<p>Returns <tt>#t</tt> if <tt>X</tt> is a bignum (integer larger than fits in a fixnum), or <tt>#f</tt> otherwise.</p><a href="#exact-integer">
<h4 id="exact-integer">exact-integer?</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(exact-integer? X)</tt>
<br /></span>
<p>Returns <tt>#t</tt> if <tt>X</tt> is an exact integer (i.e., a fixnum or a bignum), or <tt>#f</tt> otherwise.</p>
<p>This procedure is compatible with the definition from the R7RS <tt>(scheme base)</tt> library.</p><a href="#cplxnum">
<h4 id="cplxnum">cplxnum?</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(cplxnum? X)</tt>
<br /></span>
<p>Returns <tt>#t</tt> if <tt>X</tt> is a true complex number (it has an imaginary component), or <tt>#f</tt> otherwise.</p>
<p>Please note that <tt>complex?</tt> will always return <tt>#t</tt> for any number type supported by CHICKEN, so you can use this predicate if you want to know the representational type of a number.</p><a href="#ratnum">
<h4 id="ratnum">ratnum?</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(ratnum? X)</tt>
<br /></span>
<p>Returns <tt>#t</tt> if <tt>X</tt> is a true rational number (it is a fraction with a denominator that's not 1), or <tt>#f</tt> otherwise.</p>
<p>Please note that <tt>rational?</tt> will always return <tt>#t</tt> for any number type supported by CHICKEN except complex numbers and non-finite flonums, so you can use this predicate if you want to know the representational type of a number.</p><a href="#nan">
<h4 id="nan">nan?</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(nan? N)</tt>
<br /></span>
<p>Returns <tt>#t</tt> if <tt>N</tt> is not a number (a IEEE flonum NaN-value).  If <tt>N</tt> is a complex number, it's considered nan if it has a real or imaginary component that's nan.</p>
<p>This procedure is compatible with the definition from the R7RS <tt>(scheme inexact)</tt> library.</p><a href="#infinite">
<h4 id="infinite">infinite?</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(infinite? N)</tt>
<br /></span>
<p>Returns <tt>#t</tt> if <tt>N</tt> is negative or positive infinity, and <tt>#f</tt> otherwise.  If <tt>N</tt> is a complex number, it's considered infinite if it has a real or imaginary component that's infinite.</p>
<p>This procedure is compatible with the definition from the R7RS <tt>(scheme inexact)</tt> library.</p><a href="#finite">
<h4 id="finite">finite?</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(finite? N)</tt>
<br /></span>
<p>Returns <tt>#t</tt> if <tt>N</tt> represents a finite number and <tt>#f</tt> otherwise.  Positive and negative infinity as well as NaNs are not considered finite.  If <tt>N</tt> is a complex number, it's considered finite if both the real and imaginary components are finite.</p>
<p>This procedure is compatible with the definition from the R7RS <tt>(scheme inexact)</tt> library.</p><a href="#equal">
<h4 id="equal">equal=?</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(equal=? X y)</tt>
<br /></span>
<p>Similar to the standard procedure <tt>equal?</tt>, but compares numbers using the <tt>=</tt> operator, so <tt>equal=?</tt> allows structural comparison in combination with comparison of numerical data by value.</p><a href="#arithmetic">
<h3 id="arithmetic">Arithmetic</h3></a><a href="#add1sub1">
<h4 id="add1sub1">add1/sub1</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(add1 N)</tt>
<br /></span><span class="definition procedure"><em>[procedure]</em> <tt>(sub1 N)</tt>
<br /></span>
<p>Adds/subtracts 1 from <tt>N</tt>.</p><a href="#exact-integer-sqrt">
<h4 id="exact-integer-sqrt">exact-integer-sqrt</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(exact-integer-sqrt K)</tt>
<br /></span>
<p>Returns two values <tt>s</tt> and <tt>r</tt>, where <tt>s^2 + r = K</tt> and <tt>K &lt; (s+1)^2</tt>. In other words, <tt>s</tt> is the closest square root we can find that's equal to or smaller than <tt>K</tt>, and <tt>r</tt> is the rest if <tt>K</tt> isn't a neat square of two numbers.</p>
<p>This procedure is compatible with the definition from the R7RS <tt>(scheme base)</tt> library.</p><a href="#exact-integer-nth-root">
<h4 id="exact-integer-nth-root">exact-integer-nth-root</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(exact-integer-nth-root K N)</tt>
<br /></span>
<p>Like <tt>exact-integer-sqrt</tt>, but with any base value.  Calculates <tt>\sqrt[N]{K</tt>}, the <tt>N</tt>th root of <tt>K</tt> and returns two values <tt>s</tt> and <tt>r</tt> where <tt>s^N + r = K</tt> and <tt>K &lt; (s+1)^N</tt>.</p><a href="#division-with-quotient-and-remainder">
<h4 id="division-with-quotient-and-remainder">Division with quotient and remainder</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(quotient&amp;remainder X Y)</tt>
<br /></span><span class="definition procedure"><em>[procedure]</em> <tt>(quotient&amp;modulo X Y)</tt>
<br /></span>
<p>Returns two values: the quotient and the remainder (or modulo) of <tt>X</tt> divided by <tt>Y</tt>.  Could be defined as <tt>(values (quotient X Y) (remainder X Y))</tt>, but is much more efficient when dividing very large numbers.</p><a href="#signum">
<h4 id="signum">signum</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(signum N)</tt>
<br /></span>
<p>For real numbers, returns <tt>1</tt> if <tt>N</tt> is positive, <tt>-1</tt> if <tt>N</tt> is negative or <tt>0</tt> if <tt>N</tt> is zero. <tt>signum</tt> is exactness preserving.</p>
<p>For complex numbers, returns a complex number of the same angle but with magnitude 1.</p><a href="#weak-pairs">
<h3 id="weak-pairs">Weak pairs</h3></a>
<p><i>Weak pairs</i> behave identically to regular pairs, with one exception: the car value may be garbage collected.  When that happens, it gets replaced with a sentinel &quot;broken-weak-pointer&quot; value.</p>
<p>They are indistinguishable from regular pairs: <tt>car</tt>, <tt>cdr</tt>, etc all work on them, <tt>pair?</tt> returns true, etc.  The <tt>WRITE</tt> representation is identical to regular pairs, so they will be read back as pairs.  In other words, they have no read/write invariance.</p>
<p>They're the same as regular pairs for all intents and purposes. However, there's a <tt>weak-pair?</tt> predicate which <i>can</i> distinguish between regular pairs and weak pairs.</p>
<p>NOTE: Due to internal limitations, <tt>set-car!</tt> on a weak pair currently may cause it to hold onto the value for one more GC cycle in some situations.</p><a href="#weak-cons">
<h4 id="weak-cons">weak-cons</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(weak-cons obj[1] obj[2])</tt>
<br /></span>
<p>Returns a newly allocated weak pair whose car is obj[1] and whose cdr is obj[2]. The pair is indistinguishable from normal pairs, except as noted above.</p>
<pre><tt>(weak-cons 'a '())                   ===&gt;  (a)
(weak-cons '(a) '(b c d))            ===&gt;  ((a) b c d)
(weak-cons &quot;a&quot; '(b c))               ===&gt;  (&quot;a&quot; b c)
(weak-cons 'a 3)                     ===&gt;  (a . 3)
(weak-cons '(a b) 'c)                ===&gt;  ((a b) . c)

(import (chicken gc))

(let* ((x '(a b))
       (y (weak-cons x 'c)))
  (gc #t)
  (car x))                           ===&gt; (a b)

(let ((x (weak-cons '(a b) 'c)))
  (gc #t)
  (car x))                           ===&gt;  #!bwp</tt></pre>
<p>As the final two examples show, when something <i>else</i> still holds on to the value that's stored in the car of a weak pair, it will not be reclaimed.  But if the value is <i>only</i> referenced by one or more weak pairs, it is reclaimed and the car of the weak pair is replaced with the <i>broken-weak-pointer</i> value <tt>#!bwp</tt>.</p><span class="definition procedure"><em>[procedure]</em> <tt>(weak-pair? obj)</tt>
<br /></span>
<p>This predicate returns <tt>#t</tt> if and only if <tt>obj</tt> is a weak pair.</p>
<pre><tt>(weak-pair? (weak-cons 'a '()))      ===&gt;  #t
(weak-pair? (cons 'a '()))           ===&gt;  #f
(weak-pair? (vector 'a '()))         ===&gt;  #f</tt></pre><span class="definition procedure"><em>[procedure]</em> <tt>(bwp-object? obj)</tt>
<br /></span>
<p>This predicate returns <tt>#t</tt> if <tt>obj</tt> is the broken-weak-pointer value, otherwise <tt>#f</tt>.</p><a href="#lazy-evaluation">
<h3 id="lazy-evaluation">Lazy evaluation</h3></a><a href="#delay-force">
<h4 id="delay-force">delay-force</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(delay-force &lt;expression&gt;)</tt>
<br /></span>
<p>The expression <tt>(delay-force expression)</tt> is conceptually similar to <tt>(delay (force expression))</tt>, with the difference that forcing the result of <tt>delay-force</tt> will in effect result in a tail call to <tt>(force expression)</tt>, while forcing the result of <tt>(delay (force expression))</tt> might not.</p>
<p>Thus iterative lazy algorithms that might result in a long series of chains of delay and force can be rewritten using delay-force to prevent consuming unbounded space during evaluation.</p>
<p>This special form is compatible with the definition from the R7RS <tt>(scheme lazy)</tt> library.</p>
<p>See the description of force under <a href="Module scheme#control-features" class="internal">Control features</a> in the &quot;scheme&quot; module documentation for a more complete description of delayed evaluation.</p>
<p>For more information regarding the unbounded build-up of space, see the <a href="http://srfi.schemers.org/srfi-45/srfi-45.html" class="external">SRFI-45</a> rationale.</p><a href="#make-promise">
<h4 id="make-promise">make-promise</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(make-promise obj)</tt>
<br /></span>
<p>The make-promise procedure returns a promise which, when forced, will return <tt>obj</tt> . It is similar to <tt>delay</tt>, but does not delay its argument: it is a procedure rather than syntax. If <tt>obj</tt> is already a promise, it is returned.</p>
<p>This procedure is compatible with the definition from the R7RS <tt>(scheme lazy)</tt> library.</p><a href="#promise">
<h4 id="promise">promise?</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(promise? X)</tt>
<br /></span>
<p>Returns <tt>#t</tt> if <tt>X</tt> is a promise returned by <tt>delay</tt>, or <tt>#f</tt> otherwise.</p>
<p>This procedure is compatible with the definition from the R7RS <tt>(scheme lazy)</tt> library.</p><a href="#inputoutput">
<h3 id="inputoutput">Input/Output</h3></a><a href="#current-error-port">
<h4 id="current-error-port">current-error-port</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(current-error-port [PORT])</tt>
<br /></span>
<p>Returns default error output port. If <tt>PORT</tt> is given, then that port is selected as the new current error output port.</p>
<p>Note that the default error output port is not buffered. Use <a href="Module (chicken port)#set-buffering-mode" class="internal"><tt>set-buffering-mode!</tt></a> if you need a different behaviour.</p><a href="#print">
<h4 id="print">print</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(print [EXP1 ...])</tt>
<br /></span>
<p>Outputs the optional arguments <tt>EXP1 ...</tt> using <tt>display</tt> and writes a newline character to the port that is the value of <tt>(current-output-port)</tt>. Returns <tt>(void)</tt>.</p><a href="#print">
<h4 id="print">print*</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(print* [EXP1 ...])</tt>
<br /></span>
<p>Similar to <tt>print</tt>, but does not output a terminating newline character and performs a <tt>flush-output</tt> after writing its arguments.</p><a href="#interrupts-and-error-handling">
<h3 id="interrupts-and-error-handling">Interrupts and error-handling</h3></a><a href="#enable-warnings">
<h4 id="enable-warnings">enable-warnings</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(enable-warnings [BOOL])</tt>
<br /></span>
<p>Enables or disables warnings, depending on wether <tt>BOOL</tt> is true or false.  If called with no arguments, this procedure returns <tt>#t</tt> if warnings are currently enabled, or <tt>#f</tt> otherwise. Note that this is not a parameter.  The current state (whether warnings are enabled or disabled) is global and not thread-local.</p><a href="#error">
<h4 id="error">error</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(error [LOCATION] [STRING] EXP ...)</tt>
<br /></span>
<p>Prints error message, writes all extra arguments to the value of <tt>(current-error-port)</tt> and invokes the current exception-handler. This conforms to <a href="http://srfi.schemers.org/srfi-23/srfi-23.html" class="external">SRFI-23</a>.  If <tt>LOCATION</tt> is given and a symbol, it specifies the <i>location</i> (the name of the procedure) where the error occurred.</p><a href="#assert">
<h4 id="assert">assert</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(assert EXP [OBJ ...])</tt>
<br /></span>
<p>Evaluates <tt>EXP</tt>, if it returns #f, <tt>error</tt> is applied to <tt>OBJ ...</tt>, else the result of <tt>EXP</tt> is returned. When compiling in unsafe mode, assertions of this kind are disabled.</p><a href="#get-call-chain">
<h4 id="get-call-chain">get-call-chain</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(get-call-chain [START [THREAD]])</tt>
<br /></span>
<p>Returns a list with the call history. Backtrace information is only generated in code compiled without <tt>-no-trace</tt> and evaluated code. If the optional argument <tt>START</tt> is given, the backtrace starts at this offset, i.e. when <tt>START</tt> is 1, the next to last trace-entry is printed, and so on. If the optional argument <tt>THREAD</tt> is given, then the call-chain will only be constructed for calls performed by this thread.</p><a href="#print-call-chain">
<h4 id="print-call-chain">print-call-chain</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(print-call-chain [PORT [START [THREAD [HEADER]]]])</tt>
<br /></span>
<p>Prints a backtrace of the procedure call history to <tt>PORT</tt>, which defaults to <tt>(current-output-port)</tt>. The output is prefixed by the <tt>HEADER</tt>, which defaults to <tt>&quot;\n\tCall history:\n&quot;</tt>.</p><a href="#procedure-information">
<h4 id="procedure-information">procedure-information</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(procedure-information PROC)</tt>
<br /></span>
<p>Returns an s-expression with debug information for the procedure <tt>PROC</tt>, or <tt>#f</tt>, if <tt>PROC</tt> has no associated debug information.</p><a href="#warning">
<h4 id="warning">warning</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(warning MESSAGE [EXP ...])</tt>
<br /></span>
<p>Displays a warning message (if warnings are enabled with <tt>enable-warnings</tt>), from the <tt>MESSAGE</tt>, and optional <tt>EXP</tt> arguments, then continues execution. <tt>MESSAGE</tt>, and <tt>EXP</tt>, may be <tt>any</tt> object.</p><a href="#lists">
<h3 id="lists">Lists</h3></a><a href="#alist-ref">
<h4 id="alist-ref">alist-ref</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(alist-ref KEY ALIST [TEST [DEFAULT]])</tt>
<br /></span>
<p>Looks up <tt>KEY</tt> in <tt>ALIST</tt> using <tt>TEST</tt> as the comparison function (or <tt>eqv?</tt> if no test was given) and returns the cdr of the found pair, or <tt>DEFAULT</tt> (which defaults to <tt>#f</tt>).</p><a href="#alist-update">
<h4 id="alist-update">alist-update</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(alist-update KEY VALUE ALIST [TEST])</tt>
<br /></span><span class="definition procedure"><em>[procedure]</em> <tt>(alist-update! KEY VALUE ALIST [TEST])</tt>
<br /></span>
<p>If the list <tt>ALIST</tt> contains a pair of the form <tt>(KEY . X)</tt>, then this procedure replaces <tt>X</tt> with <tt>VALUE</tt> and returns <tt>ALIST</tt>. If <tt>ALIST</tt> contains no such item, then <tt>alist-update</tt> returns <tt>((KEY . VALUE) . ALIST)</tt>. The optional argument <tt>TEST</tt> specifies the comparison procedure to search a matching pair in <tt>ALIST</tt> and defaults to <tt>eqv?</tt>. <tt>alist-update!</tt> is the destructive version of <tt>alist-update</tt>.</p><a href="#atom">
<h4 id="atom">atom?</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(atom? X)</tt>
<br /></span>
<p>Returns <tt>#t</tt> if <tt>X</tt> is not a pair.</p><a href="#butlast">
<h4 id="butlast">butlast</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(butlast LIST)</tt>
<br /></span>
<p>Returns a fresh list with all elements but the last of <tt>LIST</tt>.</p><a href="#chop">
<h4 id="chop">chop</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(chop LIST N)</tt>
<br /></span>
<p>Returns a new list of sublists, where each sublist contains <tt>N</tt> elements of <tt>LIST</tt>. If <tt>LIST</tt> has a length that is not a multiple of <tt>N</tt>, then the last sublist contains the remaining elements.</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default">chop '<span class="paren2">(<span class="default">1 2 3 4 5 6</span>)</span> 2</span>)</span> ==&gt; <span class="paren1">(<span class="default"><span class="paren2">(<span class="default">1 2</span>)</span> <span class="paren2">(<span class="default">3 4</span>)</span> <span class="paren2">(<span class="default">5 6</span>)</span></span>)</span>
<span class="paren1">(<span class="default">chop '<span class="paren2">(<span class="default">a b c d</span>)</span> 3</span>)</span>     ==&gt; <span class="paren1">(<span class="default"><span class="paren2">(<span class="default">a b c</span>)</span> <span class="paren2">(<span class="default">d</span>)</span></span>)</span></tt></pre><a href="#compress">
<h4 id="compress">compress</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(compress BLIST LIST)</tt>
<br /></span>
<p>Returns a new list with elements taken from <tt>LIST</tt> with corresponding true values in the list <tt>BLIST</tt>.</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> nums '<span class="paren2">(<span class="default">99 100 110 401 1234</span>)</span></span>)</span>
<span class="paren1">(<span class="default">compress <span class="paren2">(<span class="default">map odd? nums</span>)</span> nums</span>)</span>      ==&gt; <span class="paren1">(<span class="default">99 401</span>)</span></tt></pre><a href="#flatten">
<h4 id="flatten">flatten</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(flatten LIST1 ...)</tt>
<br /></span>
<p>Returns <tt>LIST1 ...</tt> concatenated together, with nested lists removed (flattened).</p><a href="#foldl">
<h4 id="foldl">foldl</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(foldl PROCEDURE INIT LIST)</tt>
<br /></span>
<p>Applies <tt>PROCEDURE</tt> to the elements from <tt>LIST</tt>, beginning from the left:</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default">foldl + 0 '<span class="paren2">(<span class="default">1 2 3</span>)</span></span>)</span>    ==&gt;    <span class="paren1">(<span class="default">+ <span class="paren2">(<span class="default">+ <span class="paren3">(<span class="default">+ 0 1</span>)</span> 2</span>)</span> 3</span>)</span></tt></pre>
<p>Note that the order of arguments taken by <tt>PROCEDURE</tt> is different from the <tt>SRFI-1</tt> <tt>fold</tt> procedure, but matches the more natural order used in Haskell and Objective Caml.</p><a href="#foldr">
<h4 id="foldr">foldr</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(foldr PROCEDURE INIT LIST)</tt>
<br /></span>
<p>Applies <tt>PROCEDURE</tt> to the elements from <tt>LIST</tt>, beginning from the right:</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default">foldr + 0 '<span class="paren2">(<span class="default">1 2 3</span>)</span></span>)</span>    ==&gt;    <span class="paren1">(<span class="default">+ 1 <span class="paren2">(<span class="default">+ 2 <span class="paren3">(<span class="default">+ 3 0</span>)</span></span>)</span></span>)</span></tt></pre><a href="#intersperse">
<h4 id="intersperse">intersperse</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(intersperse LIST X)</tt>
<br /></span>
<p>Returns a new list with <tt>X</tt> placed between each element.</p><a href="#join">
<h4 id="join">join</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(join LISTOFLISTS [LIST])</tt>
<br /></span>
<p>Concatenates the lists in <tt>LISTOFLISTS</tt> with <tt>LIST</tt> placed between each sublist. <tt>LIST</tt> defaults to the empty list.</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default">join '<span class="paren2">(<span class="default"><span class="paren3">(<span class="default">a b</span>)</span> <span class="paren3">(<span class="default">c d</span>)</span> <span class="paren3">(<span class="default">e</span>)</span></span>)</span> '<span class="paren2">(<span class="default">x y</span>)</span></span>)</span> ==&gt; <span class="paren1">(<span class="default">a b x y c d x y e</span>)</span>
<span class="paren1">(<span class="default">join '<span class="paren2">(<span class="default"><span class="paren3">(<span class="default">p q</span>)</span> <span class="paren3">(<span class="default"></span>)</span> <span class="paren3">(<span class="default">r <span class="paren4">(<span class="default">s</span>)</span> t</span>)</span></span>)</span> '<span class="paren2">(<span class="default">-</span>)</span></span>)</span>  ==&gt; <span class="paren1">(<span class="default">p q - - r <span class="paren2">(<span class="default">s</span>)</span> t</span>)</span></tt></pre>
<p><tt>join</tt> could be implemented as follows:</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">join lstoflsts #!optional <span class="paren3">(<span class="default">lst '<span class="paren4">(<span class="default"></span>)</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="default">apply append <span class="paren3">(<span class="default">intersperse lstoflists lst</span>)</span></span>)</span> </span>)</span></tt></pre><a href="#rassoc">
<h4 id="rassoc">rassoc</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(rassoc KEY LIST [TEST])</tt>
<br /></span>
<p>Similar to <tt>assoc</tt>, but compares <tt>KEY</tt> with the <tt>cdr</tt> of each pair in <tt>LIST</tt> using <tt>TEST</tt> as the comparison procedures (which defaults to <tt>eqv?</tt>).</p><a href="#tail">
<h4 id="tail">tail?</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(tail? X LIST)</tt>
<br /></span>
<p>Returns true if <tt>X</tt> is one of the tails (cdr's) of <tt>LIST</tt>.</p><a href="#vectors">
<h3 id="vectors">Vectors</h3></a><a href="#vector-copy">
<h4 id="vector-copy">vector-copy!</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(vector-copy! VECTOR1 VECTOR2 [COUNT])</tt>
<br /></span>
<p>Copies contents of <tt>VECTOR1</tt> into <tt>VECTOR2</tt>. If the argument <tt>COUNT</tt> is given, it specifies the maximal number of elements to be copied. If not given, the minimum of the lengths of the argument vectors is copied.</p>
<p>Exceptions: <tt>(exn bounds)</tt></p><a href="#vector-resize">
<h4 id="vector-resize">vector-resize</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(vector-resize VECTOR N [INIT])</tt>
<br /></span>
<p>Creates and returns a new vector with the contents of <tt>VECTOR</tt> and length <tt>N</tt>. If <tt>N</tt> is greater than the original length of <tt>VECTOR</tt>, then all additional items are initialized to <tt>INIT</tt>. If <tt>INIT</tt> is not specified, the contents are initialized to some unspecified value.</p><a href="#subvector">
<h4 id="subvector">subvector</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(subvector VECTOR FROM [TO])</tt>
<br /></span>
<p>Returns a new vector with elements taken from <tt>VECTOR</tt> in the given range. <tt>TO</tt> defaults to <tt>(vector-length VECTOR)</tt>.</p>
<p><tt>subvector</tt> was introduced in CHICKEN 4.7.3.</p><a href="#combinators">
<h3 id="combinators">Combinators</h3></a><a href="#constantly">
<h4 id="constantly">constantly</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(constantly X ...)</tt>
<br /></span>
<p>Returns a procedure that always returns the values <tt>X ...</tt> regardless of the number and value of its arguments.</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default">constantly X</span>)</span> &lt;=&gt; <span class="paren1">(<span class="default"><i><span class="symbol">lambda</span></i> args X</span>)</span></tt></pre><a href="#complement">
<h4 id="complement">complement</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(complement PROC)</tt>
<br /></span>
<p>Returns a procedure that returns the boolean inverse of <tt>PROC</tt>.</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default">complement PROC</span>)</span> &lt;=&gt; <span class="paren1">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren2">(<span class="default">x</span>)</span> <span class="paren2">(<span class="default">not <span class="paren3">(<span class="default">PROC x</span>)</span></span>)</span></span>)</span></tt></pre><a href="#compose">
<h4 id="compose">compose</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(compose PROC1 PROC2 ...)</tt>
<br /></span>
<p>Returns a procedure that represents the composition of the argument-procedures <tt>PROC1 PROC2 ...</tt>.</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default">compose F G</span>)</span> &lt;=&gt; <span class="paren1">(<span class="default"><i><span class="symbol">lambda</span></i> args
                      <span class="paren2">(<span class="default">call-with-values
                         <span class="paren3">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren4">(<span class="default"></span>)</span> <span class="paren4">(<span class="default">apply G args</span>)</span></span>)</span>
                         F</span>)</span></span>)</span></tt></pre>
<p><tt>(compose)</tt> is equivalent to <tt>values</tt>.</p><a href="#conjoin">
<h4 id="conjoin">conjoin</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(conjoin PRED ...)</tt>
<br /></span>
<p>Returns a procedure that returns <tt>#t</tt> if its argument satisfies the predicates <tt>PRED ...</tt>.</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default"><span class="paren2">(<span class="default">conjoin odd? positive?</span>)</span> 33</span>)</span>   ==&gt;  #t
<span class="paren1">(<span class="default"><span class="paren2">(<span class="default">conjoin odd? positive?</span>)</span> -33</span>)</span>  ==&gt;  #f</tt></pre><a href="#disjoin">
<h4 id="disjoin">disjoin</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(disjoin PRED ...)</tt>
<br /></span>
<p>Returns a procedure that returns <tt>#t</tt> if its argument satisfies any predicate <tt>PRED ...</tt>.</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default"><span class="paren2">(<span class="default">disjoin odd? positive?</span>)</span> 32</span>)</span>    ==&gt;  #t
<span class="paren1">(<span class="default"><span class="paren2">(<span class="default">disjoin odd? positive?</span>)</span> -32</span>)</span>   ==&gt;  #f</tt></pre><a href="#each">
<h4 id="each">each</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(each PROC ...)</tt>
<br /></span>
<p>Returns a procedure that applies <tt>PROC ...</tt> to its arguments, and returns the result(s) of the last procedure application. For example</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default">each pp eval</span>)</span></tt></pre>
<p>is equivalent to</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default"><i><span class="symbol">lambda</span></i> args 
  <span class="paren2">(<span class="default">apply pp args</span>)</span>
  <span class="paren2">(<span class="default">apply eval args</span>)</span> </span>)</span></tt></pre>
<p><tt>(each PROC)</tt> is equivalent to <tt>PROC</tt> and <tt>(each)</tt> is equivalent to <tt>void</tt>.</p><a href="#flip">
<h4 id="flip">flip</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(flip PROC)</tt>
<br /></span>
<p>Returns a two-argument procedure that calls <tt>PROC</tt> with its arguments swapped:</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default">flip PROC</span>)</span> &lt;=&gt; <span class="paren1">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren2">(<span class="default">x y</span>)</span> <span class="paren2">(<span class="default">PROC y x</span>)</span></span>)</span></tt></pre><a href="#identity">
<h4 id="identity">identity</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(identity X)</tt>
<br /></span>
<p>Returns its sole argument <tt>X</tt>.</p><a href="#list-of">
<h4 id="list-of">list-of?</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(list-of? PRED)</tt>
<br /></span>
<p>Returns a procedure of one argument that returns <tt>#t</tt> when applied to a list of elements that all satisfy the predicate procedure <tt>PRED</tt>, or <tt>#f</tt> otherwise.</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default"><span class="paren2">(<span class="default">list-of? even?</span>)</span> '<span class="paren2">(<span class="default">1 2 3</span>)</span></span>)</span>   ==&gt; #f
<span class="paren1">(<span class="default"><span class="paren2">(<span class="default">list-of? number?</span>)</span> '<span class="paren2">(<span class="default">1 2 3</span>)</span></span>)</span> ==&gt; #t</tt></pre><a href="#o">
<h4 id="o">o</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(o PROC ...)</tt>
<br /></span>
<p>A single value version of <tt>compose</tt> (slightly faster). <tt>(o)</tt> is equivalent to <tt>identity</tt>.</p><a href="#user-defined-named-characters">
<h3 id="user-defined-named-characters">User-defined named characters</h3></a><a href="#char-name">
<h4 id="char-name">char-name</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(char-name SYMBOL-OR-CHAR [CHAR])</tt>
<br /></span>
<p>This procedure can be used to inquire about character names or to define new ones. With a single argument the behavior is as follows: If <tt>SYMBOL-OR-CHAR</tt> is a symbol, then <tt>char-name</tt> returns the character with this name, or <tt>#f</tt> if no character is defined under this name. If <tt>SYMBOL-OR-CHAR</tt> is a character, then the name of the character is returned as a symbol, or <tt>#f</tt> if the character has no associated name.</p>
<p>If the optional argument <tt>CHAR</tt> is provided, then <tt>SYMBOL-OR-CHAR</tt> should be a symbol that will be the new name of the given character. If multiple names designate the same character, then the <tt>write</tt> will use the character name that was defined last.</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default">char-name 'space</span>)</span>                  ==&gt; <span class="character">#\space</span>
<span class="paren1">(<span class="default">char-name <span class="character">#\space</span></span>)</span>                 ==&gt; space
<span class="paren1">(<span class="default">char-name 'bell</span>)</span>                   ==&gt; #f
<span class="paren1">(<span class="default">char-name <span class="paren2">(<span class="default">integer-&gt;char 7</span>)</span></span>)</span>       ==&gt; #f
<span class="paren1">(<span class="default">char-name 'bell <span class="paren2">(<span class="default">integer-&gt;char 7</span>)</span></span>)</span>
<span class="paren1">(<span class="default">char-name 'bell</span>)</span>                   ==&gt; <span class="character">#\bell</span>
<span class="paren1">(<span class="default">char-&gt;integer <span class="paren2">(<span class="default">char-name 'bell</span>)</span></span>)</span>   ==&gt; 7</tt></pre><a href="#the-unspecified-value">
<h3 id="the-unspecified-value">The unspecified value</h3></a><a href="#void">
<h4 id="void">void</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(void ARGUMENT ...)</tt>
<br /></span>
<p>Ignores <tt>ARGUMENT ...</tt> and returns an unspecified value.</p><a href="#continuations">
<h3 id="continuations">Continuations</h3></a><a href="#callcc">
<h4 id="callcc">call/cc</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(call/cc PROCEDURE)</tt>
<br /></span>
<p>An alias for <tt>call-with-current-continuation</tt>.</p>
<p>This procedure is compatible with the definition from the R7RS <tt>(scheme base)</tt> library.</p><a href="#symbols">
<h3 id="symbols">Symbols</h3></a><a href="#symbol-utilities">
<h4 id="symbol-utilities">Symbol utilities</h4></a><a href="#symbol-append">
<h5 id="symbol-append">symbol-append</h5></a><span class="definition procedure"><em>[procedure]</em> <tt>(symbol-append SYMBOL1 ...)</tt>
<br /></span>
<p>Creates a new symbol from the concatenated names of the argument symbols <tt>(SYMBOL1 ...)</tt>.</p><a href="#uninterned-symbols-gensyms">
<h4 id="uninterned-symbols-gensyms">Uninterned symbols (&quot;gensyms&quot;)</h4></a>
<p>Symbols may be &quot;interned&quot; or &quot;uninterned&quot;. Interned symbols are registered in a global table, and when read back from a port are identical to a symbol written before:</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> sym 'foo</span>)</span>

<span class="paren1">(<span class="default">eq? sym <span class="paren2">(<span class="default"><i><span class="symbol">with-input-from-string</span></i>
            <span class="paren3">(<span class="default"><i><span class="symbol">with-output-to-string</span></i> 
              <span class="paren4">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren5">(<span class="default"></span>)</span> <span class="paren5">(<span class="default">write sym</span>)</span></span>)</span></span>)</span>
	    read</span>)</span></span>)</span>

  =&gt; #t</tt></pre>
<p>Uninterned symbols on the other hand are not globally registered and so multiple symbols with the same name may coexist:</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> sym <span class="paren2">(<span class="default">gensym 'foo</span>)</span></span>)</span>   <span class="comment">; sym is a uninterned symbol like &quot;foo42&quot;
</span>
<span class="paren1">(<span class="default">eq? sym <span class="paren2">(<span class="default"><i><span class="symbol">with-input-from-string</span></i>    <span class="comment">; the symbol read will be an interned symbol
</span>            <span class="paren3">(<span class="default"><i><span class="symbol">with-output-to-string</span></i> 
              <span class="paren4">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren5">(<span class="default"></span>)</span> <span class="paren5">(<span class="default">write sym</span>)</span></span>)</span></span>)</span>
	    read</span>)</span></span>)</span>

  =&gt; #f

<span class="paren1">(<span class="default">eq? <span class="paren2">(<span class="default">string-&gt;uninterned-symbol <span class="string">&quot;foo&quot;</span></span>)</span> <span class="paren2">(<span class="default">string-&gt;uninterned-symbol <span class="string">&quot;foo&quot;</span></span>)</span></span>)</span>

  =&gt; #f</tt></pre>
<p>Use uninterned symbols if you need to generate unique values that can be compared quickly, for example as keys into a hash-table or association list. Note that uninterned symbols lose their uniqueness property when written to a file and read back in, as in the example above.</p><a href="#gensym">
<h5 id="gensym">gensym</h5></a><span class="definition procedure"><em>[procedure]</em> <tt>(gensym [STRING-OR-SYMBOL])</tt>
<br /></span>
<p>Returns a newly created uninterned symbol. If an argument is provided, the new symbol is prefixed with that argument.</p><a href="#string-uninterned-symbol">
<h5 id="string-uninterned-symbol">string-&gt;uninterned-symbol</h5></a><span class="definition procedure"><em>[procedure]</em> <tt>(string-&gt;uninterned-symbol STRING)</tt>
<br /></span>
<p>Returns a newly created, unique symbol with the name <tt>STRING</tt>.</p><a href="#setters">
<h3 id="setters">Setters</h3></a>
<p>SRFI-17 is fully implemented. For more information see: <a href="http://srfi.schemers.org/srfi-17/srfi-17.html" class="external">SRFI-17</a>.</p><a href="#setter">
<h4 id="setter">setter</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(setter PROCEDURE)</tt>
<br /></span>
<p>Returns the setter-procedure of <tt>PROCEDURE</tt>, or signals an error if <tt>PROCEDURE</tt> has no associated setter-procedure.</p>
<p>Note that <tt>(set! (setter PROC) ...)</tt> for a procedure that has no associated setter procedure yet is a very slow operation (the old procedure is replaced by a modified copy, which involves a garbage collection).</p><a href="#getter-with-setter">
<h4 id="getter-with-setter">getter-with-setter</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(getter-with-setter GETTER SETTER)</tt>
<br /></span>
<p>Returns a copy of the procedure <tt>GETTER</tt> with the associated setter procedure <tt>SETTER</tt>. Contrary to the SRFI specification, the setter of the returned procedure may be changed.</p><a href="#binding-forms-for-optional-arguments">
<h3 id="binding-forms-for-optional-arguments">Binding forms for optional arguments</h3></a><a href="#optional">
<h4 id="optional">optional</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(optional ARGS DEFAULT)</tt>
<br /></span>
<p>Use this form for procedures that take a single optional argument. If <tt>ARGS</tt> is the empty list <tt>DEFAULT</tt> is evaluated and returned, otherwise the first element of the list <tt>ARGS</tt>. It is an error if <tt>ARGS</tt> contains more than one value.</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">incr x . i</span>)</span> <span class="paren2">(<span class="default">+ x <span class="paren3">(<span class="default">optional i 1</span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="default">incr 10</span>)</span>                                   ==&gt; 11
<span class="paren1">(<span class="default">incr 12 5</span>)</span>                                 ==&gt; 17</tt></pre><a href="#case-lambda">
<h4 id="case-lambda">case-lambda</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(case-lambda (LAMBDA-LIST1 EXP1 ...) ...)</tt>
<br /></span>
<p>Expands into a lambda that invokes the body following the first matching lambda-list.</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> plus
  <span class="paren2">(<span class="default">case-lambda 
    <span class="paren3">(<span class="default"><span class="paren4">(<span class="default"></span>)</span> 0</span>)</span>
    <span class="paren3">(<span class="default"><span class="paren4">(<span class="default">x</span>)</span> x</span>)</span>
    <span class="paren3">(<span class="default"><span class="paren4">(<span class="default">x y</span>)</span> <span class="paren4">(<span class="default">+ x y</span>)</span></span>)</span>
    <span class="paren3">(<span class="default"><span class="paren4">(<span class="default">x y z</span>)</span> <span class="paren4">(<span class="default">+ <span class="paren5">(<span class="default">+ x y</span>)</span> z</span>)</span></span>)</span>
    <span class="paren3">(<span class="default">args <span class="paren4">(<span class="default">apply + args</span>)</span></span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="default">plus</span>)</span>                      ==&gt; 0
<span class="paren1">(<span class="default">plus 1</span>)</span>                    ==&gt; 1
<span class="paren1">(<span class="default">plus 1 2 3</span>)</span>                ==&gt; 6</tt></pre>
<p>For more information see the documentation for <a href="http://srfi.schemers.org/srfi-16/srfi-16.html" class="external">SRFI-16</a></p>
<p>This special form is also compatible with the definition from the R7RS <tt>(scheme case-lambda)</tt> library.</p><a href="#let-optionals">
<h4 id="let-optionals">let-optionals</h4></a><span class="definition syntax"><em>[syntax]</em> <tt> (let-optionals ARGS ((VAR1 DEFAULT1) ...) BODY ...)</tt>
<br /></span>
<p>Binding constructs for optional procedure arguments. <tt>ARGS</tt> is normally a rest-parameter taken from a lambda-list. <tt>let-optionals</tt> binds <tt>VAR1 ...</tt> to available arguments in parallel, or to <tt>DEFAULT1 ...</tt> if not enough arguments were provided. <tt>let-optionals*</tt> binds <tt>VAR1 ...</tt> sequentially, so every variable sees the previous ones. it is an error if any excess arguments are provided.</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default">let-optionals '<span class="paren2">(<span class="default">one two</span>)</span> <span class="paren2">(<span class="default"><span class="paren3">(<span class="default">a 1</span>)</span> <span class="paren3">(<span class="default">b 2</span>)</span> <span class="paren3">(<span class="default">c 3</span>)</span></span>)</span>
  <span class="paren2">(<span class="default">list a b c</span>)</span> </span>)</span>                               ==&gt; <span class="paren1">(<span class="default">one two 3</span>)</span></tt></pre><a href="#let-optionals">
<h4 id="let-optionals">let-optionals*</h4></a><span class="definition syntax"><em>[syntax]</em> <tt> (let-optionals* ARGS ((VAR1 DEFAULT1) ... [RESTVAR]) BODY ...)</tt>
<br /></span>
<p>Binding constructs for optional procedure arguments. <tt>ARGS</tt> is normally a rest-parameter taken from a lambda-list. <tt>let-optionals</tt> binds <tt>VAR1 ...</tt> to available arguments in parallel, or to <tt>DEFAULT1 ...</tt> if not enough arguments were provided. <tt>let-optionals*</tt> binds <tt>VAR1 ...</tt> sequentially, so every variable sees the previous ones. If a single variable <tt>RESTVAR</tt> is given, then it is bound to any remaining arguments, otherwise it is an error if any excess arguments are provided.</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default">let-optionals* '<span class="paren2">(<span class="default">one two</span>)</span> <span class="paren2">(<span class="default"><span class="paren3">(<span class="default">a 1</span>)</span> <span class="paren3">(<span class="default">b 2</span>)</span> <span class="paren3">(<span class="default">c a</span>)</span></span>)</span>
  <span class="paren2">(<span class="default">list a b c</span>)</span> </span>)</span>                               ==&gt; <span class="paren1">(<span class="default">one two one</span>)</span></tt></pre><a href="#other-binding-forms">
<h3 id="other-binding-forms">Other binding forms</h3></a><a href="#and-let">
<h4 id="and-let">and-let*</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(and-let* (BINDING ...) EXP1 EXP2 ...)</tt>
<br /></span>
<p>Bind sequentially and execute body. <tt>BINDING</tt> can be a list of a variable and an expression, a list with a single expression, or a single variable. If the value of an expression bound to a variable is <tt>#f</tt>, the <tt>and-let*</tt> form evaluates to <tt>#f</tt> (and the subsequent bindings and the body are not executed).  Otherwise the next binding is performed. If all bindings/expressions evaluate to a true result, the body is executed normally and the result of the last expression is the result of the <tt>and-let*</tt> form. See also the documentation for <a href="http://srfi.schemers.org/srfi-2/srfi-2.html" class="external">SRFI-2</a>.</p><a href="#letrec">
<h4 id="letrec">letrec*</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(letrec* ((VARIABLE EXPRESSION) ...) BODY ...)</tt>
<br /></span>
<p>Implements R6RS/R7RS <tt>letrec*</tt>. <tt>letrec*</tt> is similar to <tt>letrec</tt> but binds the variables sequentially and is to <tt>letrec</tt> what <tt>let*</tt> is to <tt>let</tt>.</p>
<p>This special form is compatible with the definition from the R7RS <tt>(scheme base)</tt> library.</p><a href="#rec">
<h4 id="rec">rec</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(rec NAME EXPRESSION)</tt>
<br /></span><span class="definition syntax"><em>[syntax]</em> <tt>(rec (NAME VARIABLE ...) BODY ...)</tt>
<br /></span>
<p>Allows simple definition of recursive definitions. <tt>(rec NAME EXPRESSION)</tt> is equivalent to <tt>(letrec ((NAME EXPRESSION)) NAME)</tt> and <tt>(rec (NAME VARIABLE ...) BODY ...)</tt> is the same as <tt>(letrec ((NAME (lambda (VARIABLE ...) BODY ...))) NAME)</tt>.</p><a href="#cut">
<h4 id="cut">cut</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(cut SLOT ...)</tt>
<br /></span><span class="definition syntax"><em>[syntax]</em> <tt>(cute SLOT ...)</tt>
<br /></span>
<p><a href="http://srfi.schemers.org/srfi-26/srfi-26.html" class="external">Syntactic sugar for specializing parameters</a>.</p><a href="#define-values">
<h4 id="define-values">define-values</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(define-values (NAME ...) VALUEEXP)</tt>
<br /></span><span class="definition syntax"><em>[syntax]</em> <tt>(define-values (NAME1 ... NAMEn . NAMEn+1) VALUEEXP)</tt>
<br /></span><span class="definition syntax"><em>[syntax]</em> <tt>(define-values NAME VALUEEXP)</tt>
<br /></span>
<p>Defines several variables at once, with the result values of expression <tt>VALUEEXP</tt>, similar to <tt>set!-values</tt>.</p>
<p>This special form is compatible with the definition from the R7RS <tt>(scheme base)</tt> library.</p><a href="#fluid-let">
<h4 id="fluid-let">fluid-let</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(fluid-let ((VAR1 X1) ...) BODY ...)</tt>
<br /></span>
<p>Binds the variables <tt>VAR1 ...</tt> dynamically to the values <tt>X1 ...</tt> during execution of <tt>BODY ...</tt>.  This implements <a href="http://srfi.schemers.org/srfi-15/srfi-15.html" class="external">SRFI-15</a>.</p><a href="#let-values">
<h4 id="let-values">let-values</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(let-values (((NAME ...) VALUEEXP) ...) BODY ...)</tt>
<br /></span>
<p>Binds multiple variables to the result values of <tt>VALUEEXP ...</tt>. All variables are bound simultaneously.  Like <tt>define-values</tt>, the <tt>(NAME ...)</tt> expression can be any basic lambda list (dotted tail notation is supported).</p>
<p>This special form implements <a href="http://srfi.schemers.org/srfi-11/srfi-11.html" class="external">SRFI-11</a>, and it is also compatible with the definition from the R7RS <tt>(scheme base)</tt> library.</p><a href="#let-values">
<h4 id="let-values">let*-values</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(let*-values (((NAME ...) VALUEEXP) ...) BODY ...)</tt>
<br /></span>
<p>Binds multiple variables to the result values of <tt>VALUEEXP ...</tt>. The variables are bound sequentially.  Like <tt>let-values</tt>, the <tt>(NAME ...)</tt> expression can be any basic lambda list (dotted tail notation is supported).</p>
<p>This is also part of <a href="http://srfi.schemers.org/srfi-11/srfi-11.html" class="external">SRFI-11</a> and is also compatible with the definition from the R7RS <tt>(scheme base)</tt> library.</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default">let*-values <span class="paren2">(<span class="default"><span class="paren3">(<span class="default"><span class="paren4">(<span class="default">a b</span>)</span> <span class="paren4">(<span class="default">values 2 3</span>)</span></span>)</span>
              <span class="paren3">(<span class="default"><span class="paren4">(<span class="default">p</span>)</span> <span class="paren4">(<span class="default">+ a b</span>)</span></span>)</span> </span>)</span>
  p</span>)</span>                               ==&gt; 5</tt></pre><a href="#letrec-values">
<h4 id="letrec-values">letrec-values</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(letrec-values (((NAME ...) VALUEEXP) ...) BODY ...)</tt>
<br /></span>
<p>Binds the result values of <tt>VALUEEXP ...</tt> to multiple variables at once.  All variables are mutually recursive.  Like <tt>let-values</tt>, the <tt>(NAME ...)</tt> expression can be any basic lambda list (dotted tail notation is supported).</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default">letrec-values <span class="paren2">(<span class="default"><span class="paren3">(<span class="default"><span class="paren4">(<span class="default">odd even</span>)</span>
                   <span class="paren4">(<span class="default">values 
                     <span class="paren5">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren6">(<span class="default">n</span>)</span> <span class="paren6">(<span class="default"><i><span class="symbol">if</span></i> <span class="paren1">(<span class="default">zero? n</span>)</span> #f <span class="paren1">(<span class="default">even <span class="paren2">(<span class="default">sub1 n</span>)</span></span>)</span></span>)</span></span>)</span>
                     <span class="paren5">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren6">(<span class="default">n</span>)</span> <span class="paren6">(<span class="default"><i><span class="symbol">if</span></i> <span class="paren1">(<span class="default">zero? n</span>)</span> #t <span class="paren1">(<span class="default">odd <span class="paren2">(<span class="default">sub1 n</span>)</span></span>)</span></span>)</span></span>)</span> </span>)</span> </span>)</span> </span>)</span>
  <span class="paren2">(<span class="default">odd 17</span>)</span> </span>)</span>                           ==&gt; #t</tt></pre><a href="#receive">
<h4 id="receive">receive</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(receive (NAME ...) VALUEEXP BODY ...)</tt>
<br /></span><span class="definition syntax"><em>[syntax]</em> <tt>(receive (NAME1 ... NAMEn . NAMEn+1) VALUEEXP BODY ...)</tt>
<br /></span><span class="definition syntax"><em>[syntax]</em> <tt>(receive NAME VALUEEXP BODY ...)</tt>
<br /></span><span class="definition syntax"><em>[syntax]</em> <tt>(receive VALUEEXP)</tt>
<br /></span>
<p><a href="http://srfi.schemers.org/srfi-8/srfi-8.html" class="external">SRFI-8</a>. Syntactic sugar for <tt>call-with-values</tt>. Binds variables to the result values of <tt>VALUEEXP</tt> and evaluates <tt>BODY ...</tt>, similar <tt>define-values</tt> but lexically scoped.</p>
<p><tt>(receive VALUEEXP)</tt> is equivalent to <tt>(receive _ VALUEEXP _)</tt>. This shortened form is not described by SRFI-8.</p><a href="#set-values">
<h4 id="set-values">set!-values</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(set!-values (NAME ...) VALUEEXP)</tt>
<br /></span><span class="definition syntax"><em>[syntax]</em> <tt>(set!-values (NAME1 ... NAMEn . NAMEn+1) VALUEEXP)</tt>
<br /></span><span class="definition syntax"><em>[syntax]</em> <tt>(set!-values NAME VALUEEXP)</tt>
<br /></span>
<p>Assigns the result values of expression <tt>VALUEEXP</tt> to multiple variables, similar to <tt>define-values</tt>.</p><a href="#nth-value">
<h4 id="nth-value">nth-value</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(nth-value N EXP)</tt>
<br /></span>
<p>Returns the <tt>N</tt>th value (counting from zero) of the values returned by expression <tt>EXP</tt>.</p><a href="#parameters">
<h3 id="parameters">Parameters</h3></a>
<p>Parameters are CHICKEN's form of dynamic variables, except that they are procedures rather than actual variables.  A parameter is a procedure of zero or one arguments. To retrieve the value of a parameter call the parameter-procedure with zero arguments. To change the setting of the parameter, call the parameter-procedure with the new value as argument:</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> foo <span class="paren2">(<span class="default">make-parameter 123</span>)</span></span>)</span>
<span class="paren1">(<span class="default">foo</span>)</span>                             ==&gt; 123
<span class="paren1">(<span class="default">foo 99</span>)</span>
<span class="paren1">(<span class="default">foo</span>)</span>                             ==&gt; 99</tt></pre>
<p>Parameters are fully thread-local, each thread of execution owns a local copy of a parameters' value.</p>
<p>CHICKEN implements <a href="http://srfi.schemers.org/srfi-39/srfi-39.html" class="external">SRFI-39</a>, which is also standardized by R7RS.</p><a href="#parameterize">
<h4 id="parameterize">parameterize</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(parameterize ((PARAMETER1 X1) ...) BODY ...)</tt>
<br /></span>
<p>Binds the parameters <tt>PARAMETER1 ...</tt> dynamically to the values <tt>X1 ...</tt> during execution of <tt>BODY ...</tt>.  (see also: <tt>make-parameter</tt> in <a href="parameters" class="internal">Parameters</a>). Note that <tt>PARAMETER</tt> may be any expression that evaluates to a parameter procedure.</p>
<p>This special form is compatible with the definition from the R7RS <tt>(scheme base)</tt> library.</p><a href="#make-parameter">
<h4 id="make-parameter">make-parameter</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(make-parameter VALUE [GUARD])</tt>
<br /></span>
<p>Returns a procedure that accepts zero or one argument. Invoking the procedure with zero arguments returns <tt>VALUE</tt>. Invoking the procedure with one argument changes its value to the value of that argument and returns the new value (subsequent invocations with zero parameters return the new value). <tt>GUARD</tt> should be a procedure of a single argument. Any new values of the parameter (even the initial value) are passed to this procedure. The guard procedure should check the value and/or convert it to an appropriate form.</p>
<p>This special form is compatible with the definition from the R7RS <tt>(scheme base)</tt> library.</p><a href="#substitution-forms-and-macros">
<h3 id="substitution-forms-and-macros">Substitution forms and macros</h3></a><a href="#define-constant">
<h4 id="define-constant">define-constant</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(define-constant NAME CONST)</tt>
<br /></span>
<p>Defines a variable with a constant value, evaluated at compile-time. Any reference to such a constant should appear textually <b>after</b> its definition. This construct is equivalent to <tt>define</tt> when evaluated or interpreted.  Constant definitions should only appear at toplevel. Note that constants are local to the current compilation unit and are not available outside of the source file in which they are defined. Names of constants still exist in the Scheme namespace and can be lexically shadowed.  If the value is mutable, then the compiler is careful to preserve its identity.  <tt>CONST</tt> may be any constant expression, and may also refer to constants defined via <tt>define-constant</tt> previously, but it must be possible to evaluate the expression at compile-time.</p><a href="#define-inline">
<h4 id="define-inline">define-inline</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(define-inline (NAME VAR ...) BODY ...)</tt>
<br /></span><span class="definition syntax"><em>[syntax]</em> <tt>(define-inline (NAME VAR ... . VAR) BODY ...)</tt>
<br /></span><span class="definition syntax"><em>[syntax]</em> <tt>(define-inline NAME EXP)</tt>
<br /></span>
<p>Defines an inline procedure. Any occurrence of <tt>NAME</tt> will be replaced by <tt>EXP</tt> or <tt>(lambda (VAR ... [. VAR]) BODY ...)</tt>. This is similar to a macro, but variable names and scope are handled correctly.</p>
<p>Inline substitutions take place <b>after</b> macro-expansion, and any reference to <tt>NAME</tt> should appear textually <b>after</b> its definition. Inline procedures are local to the current compilation unit and are not available outside of the source file in which they are defined. Names of inline procedures still exist in the Scheme namespace and can be lexically shadowed. Inline definitions should only appear at the toplevel.</p>
<p>Note that the <tt>inline-limit</tt> compiler option does not affect inline procedure expansion, and self-referential inline procedures may cause the compiler to enter an infinite loop.</p>
<p>In the third form, <tt>EXP</tt> must be a lambda expression.</p>
<p>This construct is equivalent to <tt>define</tt> when evaluated or interpreted.</p><a href="#conditional-forms">
<h3 id="conditional-forms">Conditional forms</h3></a><a href="#unless">
<h4 id="unless">unless</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(unless TEST EXP1 EXP2 ...)</tt>
<br /></span>
<p>Equivalent to:</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default"><i><span class="symbol">if</span></i> <span class="paren2">(<span class="default">not TEST</span>)</span> <span class="paren2">(<span class="default">begin EXP1 EXP2 ...</span>)</span></span>)</span></tt></pre><a href="#when">
<h4 id="when">when</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(when TEST EXP1 EXP2 ...)</tt>
<br /></span>
<p>Equivalent to:</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default"><i><span class="symbol">if</span></i> TEST <span class="paren2">(<span class="default">begin EXP1 EXP2 ...</span>)</span></span>)</span></tt></pre><a href="#record-structures">
<h3 id="record-structures">Record structures</h3></a><a href="#define-record">
<h4 id="define-record">define-record</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(define-record NAME SLOTNAME ...)</tt>
<br /></span>
<p>Defines a record type. This defines a number of procedures for creating, accessing, and modifying record members.</p>
<p>Call <tt>make-NAME</tt> to create an instance of the structure (with one initialization-argument for each slot, in the listed order).</p>
<p><tt>(NAME? STRUCT)</tt> tests any object for being an instance of this structure.</p>
<p>Slots are accessed via <tt>(NAME-SLOTNAME STRUCT)</tt> and updated using <tt>(NAME-SLOTNAME-set!</tt> <tt>STRUCT</tt> <tt>VALUE)</tt>.</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default"><i><span class="symbol">define-record</span></i> point x y</span>)</span>
<span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> p1 <span class="paren2">(<span class="default">make-point 123 456</span>)</span></span>)</span>
<span class="paren1">(<span class="default">point? p1</span>)</span>                      ==&gt; #t
<span class="paren1">(<span class="default">point-x p1</span>)</span>                     ==&gt; 123
<span class="paren1">(<span class="default">point-y-set! p1 99</span>)</span>
<span class="paren1">(<span class="default">point-y p1</span>)</span>                     ==&gt; 99</tt></pre><a href="#srfi-17-setters">
<h5 id="srfi-17-setters">SRFI-17 setters</h5></a>
<p><tt>SLOTNAME</tt> may alternatively also be of the form</p>
<pre><tt> (setter SLOTNAME)</tt></pre>
<p>In this case the slot can be read with <tt>(NAME-SLOTNAME STRUCT)</tt> as usual, and modified with <tt>(set! (NAME-SLOTNAME STRUCT) VALUE)</tt> (the slot-accessor has an associated SRFI-17 &quot;setter&quot; procedure) instead of the usual <tt>(NAME-SLOTNAME-set!</tt> <tt>STRUCT</tt> <tt>VALUE)</tt>.</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default"><i><span class="symbol">define-record</span></i> point <span class="paren2">(<span class="default">setter x</span>)</span> <span class="paren2">(<span class="default">setter y</span>)</span></span>)</span>
<span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> p1 <span class="paren2">(<span class="default">make-point 123 456</span>)</span></span>)</span>
<span class="paren1">(<span class="default">point? p1</span>)</span>                      ==&gt; #t
<span class="paren1">(<span class="default">point-x p1</span>)</span>                     ==&gt; 123
<span class="paren1">(<span class="default">set! <span class="paren2">(<span class="default">point-y p1</span>)</span> 99</span>)</span>
<span class="paren1">(<span class="default">point-y p1</span>)</span>                     ==&gt; 99</tt></pre><a href="#define-record-type">
<h4 id="define-record-type">define-record-type</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(define-record-type NAME (CONSTRUCTOR TAG ...) PREDICATE (FIELD ACCESSOR [MODIFIER]) ...)</tt>
<br /></span>
<p>SRFI-9 record types. For more information see the documentation for <a href="http://srfi.schemers.org/srfi-9/srfi-9.html" class="external">SRFI-9</a>.</p>
<p>As an extension the <tt>MODIFIER</tt> may have the form <tt>(setter PROCEDURE)</tt>, which will define a SRFI-17 setter-procedure for the given <tt>PROCEDURE</tt> that sets the field value. Usually <tt>PROCEDURE</tt> has the same name is <tt>ACCESSOR</tt> (but it doesn't have to).</p>
<p>This special form is also compatible with the definition from the R7RS <tt>(scheme base)</tt> library.</p><a href="#record-printer">
<h4 id="record-printer">record-printer</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(record-printer NAME)</tt>
<br /></span>
<p>Returns the procedure used to print records of the type <tt>NAME</tt> if one has been set with <tt>set-record-printer!</tt>, <tt>#f</tt> otherwise.</p><a href="#set-record-printer">
<h4 id="set-record-printer">set-record-printer!</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(set-record-printer! NAME PROCEDURE)</tt>
<br /></span><span class="definition procedure"><em>[procedure]</em> <tt>(set! (record-printer NAME) PROCEDURE)</tt>
<br /></span>
<p>Defines a printing method for record of the type <tt>NAME</tt> by associating a procedure with the record type. When a record of this type is written using <tt>display, write</tt> or <tt>print</tt>, then the procedure is called with two arguments: the record to be printed and an output-port.</p>
<pre><tt class="highlight scheme-language"><span class="paren1">(<span class="default"><i><span class="symbol">define-record-type</span></i> foo <span class="paren2">(<span class="default">make-foo x y z</span>)</span> foo?
  <span class="paren2">(<span class="default">x foo-x</span>)</span>
  <span class="paren2">(<span class="default">y foo-y</span>)</span>
  <span class="paren2">(<span class="default">z foo-z</span>)</span></span>)</span>
<span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> f <span class="paren2">(<span class="default">make-foo 1 2 3</span>)</span></span>)</span>
<span class="paren1">(<span class="default">set-record-printer! foo
  <span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="default">x out</span>)</span>
    <span class="paren3">(<span class="default">fprintf out <span class="string">&quot;#,(foo ~S ~S ~S)&quot;</span>
             <span class="paren4">(<span class="default">foo-x x</span>)</span> <span class="paren4">(<span class="default">foo-y x</span>)</span> <span class="paren4">(<span class="default">foo-z x</span>)</span></span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="default"><i><span class="symbol">define-reader-ctor</span></i> 'foo make-foo</span>)</span>
<span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> s <span class="paren2">(<span class="default"><i><span class="symbol">with-output-to-string</span></i>
              <span class="paren3">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren4">(<span class="default"></span>)</span> <span class="paren4">(<span class="default">write f</span>)</span></span>)</span></span>)</span></span>)</span>
s                                   ==&gt; <span class="string">&quot;#,(foo 1 2 3)&quot;</span>
<span class="paren1">(<span class="default">equal? f <span class="paren2">(<span class="default"><i><span class="symbol">with-input-from-string</span></i>
              s read</span>)</span></span>)</span>)             ==&gt; #t</tt></pre><a href="#other-forms">
<h3 id="other-forms">Other forms</h3></a><a href="#include">
<h4 id="include">include</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(include STRING)</tt>
<br /></span>
<p>Include toplevel-expressions from the given source file in the currently compiled/interpreted program.  If the included file has the extension <tt>.scm</tt>, then it may be omitted. The file is searched for in the current directory and all directories specified by the <tt>-include-path</tt> option.</p><a href="#include-relative">
<h4 id="include-relative">include-relative</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(include-relative STRING)</tt>
<br /></span>
<p>Works like <tt>include</tt>, but the filename is searched for relative to the including file rather than the current directory.</p><a href="#making-extra-libraries-and-extensions-available">
<h3 id="making-extra-libraries-and-extensions-available">Making extra libraries and extensions available</h3></a><a href="#require-extension">
<h4 id="require-extension">require-extension</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(require-extension ID ...)</tt>
<br /></span>
<p>This is equivalent to <tt>(require-library ID ...)</tt> but performs an implicit <tt>import</tt>, if necessary. Since version 4.4.0, <tt>ID</tt> may also be an import specification (using <tt>rename</tt>, <tt>only</tt>, <tt>except</tt> or <tt>prefix</tt>).</p>
<p>To make long matters short - just use <tt>require-extension</tt> and it will normally figure everything out for dynamically loadable extensions and core library units.</p>
<p>This implementation of <tt>require-extension</tt> is compliant with <a href="http://srfi.schemers.org/srfi-55/srfi-55.html" class="external">SRFI-55</a> (see the <a href="http://srfi.schemers.org/srfi-55/srfi-55.html" class="external">SRFI-55</a> document for more information).</p><a href="#require-library">
<h4 id="require-library">require-library</h4></a><span class="definition syntax"><em>[syntax]</em> <tt>(require-library ID ...)</tt>
<br /></span>
<p>This form does all the necessary steps to make the libraries or extensions given in <tt>ID ...</tt> available. It loads syntactic extensions, if needed and generates code for loading/linking with core library modules or separately installed extensions.</p>
<p>During interpretation/evaluation <tt>require-library</tt> performs one of the following:</p>
<ul>
<li>If <tt>ID</tt> names a built-in feature, then nothing is done.</li>
<li>If <tt>ID</tt> names one of the syntactic extensions <tt>chicken-syntax chicken-ffi-syntax</tt>, then this extension will be loaded.</li>
<li>If <tt>ID</tt> names one of the core library units shipped with CHICKEN, then a <tt>(load-library 'ID)</tt> will be performed.</li>
<li>If <tt>ID</tt> names an installed extension with the <tt>syntax</tt> or <tt>require-at-runtime</tt> attribute, then the extensions is loaded at compile-time, probably doing a run-time <tt>(require ...)</tt> for any run-time requirements.</li>
<li>Otherwise, <tt>(require-library ID)</tt> is equivalent to <tt>(require 'ID)</tt>.</li></ul>
<p>During compilation, one of the following happens instead:</p>
<ul>
<li>If <tt>ID</tt> names a built-in feature, then nothing is done.</li>
<li>If <tt>ID</tt> names one of the syntactic extensions <tt>chicken-syntax chicken-ffi-syntax</tt>, then this extension will be loaded at compile-time, making the syntactic extensions available in compiled code.</li>
<li>If <tt>ID</tt> names one of the core library units shipped with CHICKEN, or if the option <tt>-uses ID</tt> has been passed to the compiler, then a <tt>(declare (uses ID))</tt> is generated.</li>
<li>If <tt>ID</tt> names an installed extension with the <tt>syntax</tt> or <tt>require-at-runtime</tt> attribute, then the extension is loaded at compile-time, and code is emitted to <tt>(require ...)</tt> any needed run-time requirements.</li>
<li>Otherwise <tt>(require-library ID)</tt> is equivalent to <tt>(require 'ID)</tt>.</li></ul>
<p><tt>ID</tt> should be a pure extension name and should not contain any path prefixes (for example <tt>dir/lib...</tt> is illegal).</p>
<p><tt>ID</tt> may also be a list that designates an extension-specifier. Currently the following extension specifiers are defined:</p>
<ul>
<li><tt>(srfi NUMBER ...)</tt> is required for SRFI-55 compatibility and is fully implemented</li>
<li><tt>(version ID NUMBER)</tt> is equivalent to <tt>ID</tt>, but checks at compile-time whether the extension named <tt>ID</tt> is installed and whether its version is equal or higher than <tt>NUMBER</tt>. <tt>NUMBER</tt> may be a string or a number, the comparison is done lexicographically (using <tt>string&gt;=?</tt>).</li></ul><a href="#process-shutdown">
<h3 id="process-shutdown">Process shutdown</h3></a><a href="#emergency-exit">
<h4 id="emergency-exit">emergency-exit</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(emergency-exit [CODE])</tt>
<br /></span>
<p>Exits the current process without flushing any buffered output (using the C function <tt>_exit</tt>).  Note that the <tt>exit-handler</tt> is not called when this procedure is invoked. The optional exit status code <tt>CODE</tt> defaults to <tt>0</tt>.</p><a href="#exit">
<h4 id="exit">exit</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(exit [CODE])</tt>
<br /></span>
<p>Exit the running process and return exit-code, which defaults to 0 (Invokes <tt>exit-handler</tt>).</p>
<p>Note that pending <tt>dynamic-wind</tt> thunks are <i>not</i> invoked when exiting your program in this way.</p><a href="#exit-handler">
<h3 id="exit-handler">exit-handler</h3></a><span class="definition parameter"><em>[parameter]</em> <tt>(exit-handler)</tt>
<br /></span>
<p>A procedure of a single optional argument. When <tt>exit</tt> is called, then this procedure will be invoked with the exit-code as argument. The default behavior is to terminate the program.</p>
<p>Note that this handler is <i>not</i> invoked when <tt>emergency-exit</tt> is used.</p><a href="#implicit-exit-handler">
<h3 id="implicit-exit-handler">implicit-exit-handler</h3></a><span class="definition parameter"><em>[parameter]</em> <tt>(implicit-exit-handler)</tt>
<br /></span>
<p>A procedure of no arguments. When the last toplevel expression of the program has executed, then the value of this parameter is called. The default behaviour is to invoke all pending finalizers.</p><a href="#on-exit">
<h4 id="on-exit">on-exit</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(on-exit THUNK)</tt>
<br /></span>
<p>Schedules the zero-argument procedures <tt>THUNK</tt> to be executed before the process exits, either explicitly via <tt>exit</tt> or implicitly after execution of the last top-level form. Note that finalizers for unreferenced finalized data are run before exit procedures.</p><a href="#system-interface">
<h3 id="system-interface">System interface</h3></a><a href="#sleep">
<h4 id="sleep">sleep</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(sleep SECONDS)</tt>
<br /></span>
<p>Puts the program to sleep for <tt>SECONDS</tt>. If the scheduler is loaded (for example when srfi-18 is in use) then only the calling thread is put to sleep and other threads may continue executing. Otherwise, the whole process is put to sleep.</p><a href="#ports">
<h3 id="ports">Ports</h3></a><a href="#string-ports">
<h4 id="string-ports">String ports</h4></a><a href="#get-output-string">
<h5 id="get-output-string">get-output-string</h5></a><span class="definition procedure"><em>[procedure]</em> <tt>(get-output-string PORT)</tt>
<br /></span>
<p>Returns accumulated output of a port created with <tt>(open-output-string)</tt>.</p><a href="#open-input-string">
<h5 id="open-input-string">open-input-string</h5></a><span class="definition procedure"><em>[procedure]</em> <tt>(open-input-string STRING)</tt>
<br /></span>
<p>Returns a port for reading from <tt>STRING</tt>.</p><a href="#open-output-string">
<h5 id="open-output-string">open-output-string</h5></a><span class="definition procedure"><em>[procedure]</em> <tt>(open-output-string)</tt>
<br /></span>
<p>Returns a port for accumulating output in a string.</p><a href="#file-inputoutput">
<h3 id="file-inputoutput">File Input/Output</h3></a><a href="#flush-output">
<h4 id="flush-output">flush-output</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(flush-output [PORT])</tt>
<br /></span>
<p>Write buffered output to the given output-port. <tt>PORT</tt> defaults to the value of <tt>(current-output-port)</tt>.</p><a href="#port-predicates">
<h3 id="port-predicates">Port predicates</h3></a><a href="#input-port-open">
<h4 id="input-port-open">input-port-open?</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(input-port-open? PORT)</tt>
<br /></span>
<p>Is the given <tt>PORT</tt> open for input?</p><span class="definition procedure"><em>[procedure]</em> <tt>(output-port-open? PORT)</tt>
<br /></span>
<p>Is the given <tt>PORT</tt> open for output?</p><a href="#port-closed">
<h4 id="port-closed">port-closed?</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(port-closed? PORT)</tt>
<br /></span>
<p>Is the given <tt>PORT</tt> closed (in all directions)?</p><a href="#port">
<h4 id="port">port?</h4></a><span class="definition procedure"><em>[procedure]</em> <tt>(port? X)</tt>
<br /></span>
<p>Returns <tt>#t</tt> if <tt>X</tt> is a port object or <tt>#f</tt> otherwise.</p><a href="#built-in-parameters">
<h3 id="built-in-parameters">Built-in parameters</h3></a>
<p>Certain behavior of the interpreter and compiled programs can be customized via the following built-in parameters:</p><a href="#case-sensitive">
<h4 id="case-sensitive">case-sensitive</h4></a><span class="definition parameter"><em>[parameter]</em> <tt>(case-sensitive)</tt>
<br /></span>
<p>If true, then <tt>read</tt> reads symbols and identifiers in case-sensitive mode and uppercase characters in symbols are printed escaped. Defaults to <tt>#t</tt>.</p><a href="#keyword-style">
<h4 id="keyword-style">keyword-style</h4></a><span class="definition parameter"><em>[parameter]</em> <tt>(keyword-style)</tt>
<br /></span>
<p>Enables alternative keyword syntax, where <tt>STYLE</tt> may be either <tt>#:prefix</tt> (as in Common Lisp), which recognizes symbols beginning with a colon as keywords, or <tt>#:suffix</tt> (as in DSSSL), which recognizes symbols ending with a colon as keywords. Any other value disables the alternative syntaxes.  In the interpreter the default is <tt>#:suffix</tt>.</p><a href="#parentheses-synonyms">
<h4 id="parentheses-synonyms">parentheses-synonyms</h4></a><span class="definition parameter"><em>[parameter]</em> <tt>(parentheses-synonyms)</tt>
<br /></span>
<p>If true, then the list delimiter synonyms <tt>#\[</tt> <tt>#\]</tt> and <tt>#\{</tt> <tt>#\</tt>} are enabled. Defaults to <tt>#t</tt>.</p><a href="#symbol-escape">
<h4 id="symbol-escape">symbol-escape</h4></a><span class="definition parameter"><em>[parameter]</em> <tt>(symbol-escape)</tt>
<br /></span>
<p>If true, then the symbol escape <tt>#\|</tt> <tt>#\|</tt> is enabled. Defaults to <tt>#t</tt>.</p>
<hr />
<p>Previous: <a href="Module srfi-4" class="internal">Module srfi-4</a></p>
<p>Next: <a href="Module (chicken bitwise)" class="internal">Module (chicken bitwise)</a></p></div></body></html>