<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Foreign type specifiers - The CHICKEN Scheme wiki</title>
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel="stylesheet" type="text/css" href="/chicken.css" />
<meta name="viewport" content="width=device-width, initial-scale=1" /></head>
<body>
<div id="menu">
<ul>
<li><a href="/" class="internal">Wiki</a></li>
<li><a href="//code.call-cc.org/" class="external">Download</a></li>
<li><a href="/manual/index" class="internal">Manual</a></li>
<li><a href="//eggs.call-cc.org" class="external">Eggs</a></li>
<li><a href="//api.call-cc.org/5/doc/" class="external">API</a></li>
<li><a href="//tests.call-cc.org/" class="external">Tests</a></li>
<li><a href="//bugs.call-cc.org/" class="external">Bugs</a></li></ul></div>
<ul id="page-specific-links">
<li><a href="?action=show">show</a></li>
<li><a href="?action=edit" rel="nofollow">edit</a></li>
<li><a href="?action=history">history</a></li></ul>
<div id="content">
<ul class="tags">
<li>manual</li></ul>
<div id="toc">
<ol>
<li><a href="#foreign-type-specifiers">Foreign type specifiers</a>
<ol>
<li><a href="#void">Void</a></li>
<li><a href="#boolean">Boolean</a></li>
<li><a href="#characters">Characters</a></li>
<li><a href="#integers">Integers</a></li>
<li><a href="#floating-point">Floating-point</a></li>
<li><a href="#strings">Strings</a></li>
<li><a href="#bytevectors">Bytevectors</a></li>
<li><a href="#pointers">Pointers</a></li>
<li><a href="#scheme-objects">Scheme objects</a></li>
<li><a href="#user-defined-c-types">User-defined C types</a></li>
<li><a href="#c-types">C++ types</a></li>
<li><a href="#type-qualifiers">Type qualifiers</a></li>
<li><a href="#map-of-foreign-types-to-c-types">Map of foreign types to C types</a></li></ol></li></ol></div><a href="#foreign-type-specifiers">
<h2 id="foreign-type-specifiers">Foreign type specifiers</h2></a>
<p>Here is a list of valid foreign type specifiers for use in <a href="Accessing external objects" class="internal">accessing external objects</a>.</p><a href="#void">
<h3 id="void">Void</h3></a><span class="definition type"><em>[type]</em> <tt>void</tt>
<br /></span>
<p>Specifies an undefined return value.  Not allowed as argument type.</p><a href="#boolean">
<h3 id="boolean">Boolean</h3></a><span class="definition type"><em>[type]</em> <tt>bool</tt>
<br /></span>
<p>As argument: any value (<tt>#f</tt> is false (zero), anything else is true (non-zero).</p>
<p>As result: anything different from 0 and the <tt>NULL</tt> pointer is <tt>#t</tt>.</p>
<p>This type maps to <tt>int</tt> in both C and C++.</p><a href="#characters">
<h3 id="characters">Characters</h3></a><span class="definition type"><em>[type]</em> <tt>char</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>unsigned-char</tt>
<br /></span>
<p>A signed or unsigned character.</p>
<p>As an argument, the input Scheme character is cast to C <tt>char</tt> or <tt>unsigned char</tt>, resulting in an 8-bit value.  A Scheme character with an integer value outside 0-127 (signed) or 0-255 (unsigned) will be silently truncated to fit; in other words, don't feed it UTF-8 data.</p>
<p>As a return type, accepts any valid Unicode code point; the return type is treated as a C int, and converted to a Scheme character.</p><a href="#integers">
<h3 id="integers">Integers</h3></a><span class="definition type"><em>[type]</em> <tt>byte</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>unsigned-byte</tt>
<br /></span>
<p>An 8-bit integer value in range -128 - 127 (byte) or 0 - 255 (unsigned byte).  Values are cast to and from C <tt>char</tt> or <tt>unsigned char</tt> type, so values outside this 8-bit range will be unceremoniously truncated.</p><span class="definition type"><em>[type]</em> <tt>short</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>unsigned-short</tt>
<br /></span>
<p>A short integer number in 16-bit range.  Maps to C <tt>short</tt> or <tt>unsigned short</tt>.</p><span class="definition type"><em>[type]</em> <tt>int</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>unsigned-int</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>int32</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>unsigned-int32</tt>
<br /></span>
<p>An integer number in fixnum range (-1073741824 to 1073741823, i.e. 31 bit signed).  <tt>unsigned-int</tt> further restricts this range to 30 bit unsigned (0 to 1073741823).  <tt>int</tt> maps to C type <tt>int</tt> and <tt>int32</tt> maps to <tt>int32_t</tt>.</p>
<p>As an argument type, these expect a fixnum value, and as a return type they return a fixnum.  Values outside the ranges prescribed above are silently truncated; you should use e.g. <tt>integer</tt> if you need the full 32-bit range.  Note: <tt>int32</tt> is not recognized as an argument type prior to CHICKEN 4.7.2.</p>
<p>Notes for 64-bit architectures:</p>
<ul>
<li>C's <tt>int</tt> is 32 bits on most 64-bit systems (<a href="https://en.wikipedia.org/wiki/64-bit_computing#64-bit_data_models" class="external">LP64</a>), so <tt>int</tt> and <tt>int32</tt> are functionally (if not semantically) equivalent.</li>
<li>The fixnum type is larger than 32 bits and consequently the entire signed or unsigned 32-bit range is available for this type on 64-bit systems.  However, for compatibility with 32-bit systems it is probably unwise to rely on this.  If you need a 32-bit range, you should use (unsigned) <tt>integer</tt> or <tt>integer32</tt>.</li></ul><span class="definition type"><em>[type]</em> <tt>integer</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>unsigned-integer</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>integer32</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>unsigned-integer32</tt>
<br /></span>
<p>A fixnum or bignum, mapping to <tt>int</tt> or <tt>int32_t</tt> or their unsigned variants.  When outside of fixnum range the value will overflow into a bignum. Prior to CHICKEN 5, the value would overflow into a flonum.</p>
<p>C's <tt>int</tt> is 32 bits on most 64-bit systems (<a href="https://en.wikipedia.org/wiki/64-bit_computing#64-bit_data_models" class="external">LP64</a>), so <tt>integer</tt> and <tt>integer32</tt> are functionally (if not semantically) equivalent.</p><span class="definition type"><em>[type]</em> <tt>integer64</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>unsigned-integer64</tt>
<br /></span>
<p>A fixnum or bignum, mapping to <tt>int64_t</tt> or <tt>uint64_t</tt>. When outside of fixnum range the value will overflow into a bignum. Prior to CHICKEN 5, the value would overflow into a flonum.</p><span class="definition type"><em>[type]</em> <tt>long</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>unsigned-long</tt>
<br /></span>
<p>A fixnum or bignum, mapping to <tt>long</tt> or <tt>unsigned long</tt>. Similar to <tt>integer32</tt> on 32-bit systems or <tt>integer64</tt> on 64-bit.</p><span class="definition type"><em>[type]</em> <tt>size_t</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>ssize_t</tt>
<br /></span>
<p>A direct mapping to C's <tt>size_t</tt> and <tt>ssize_t</tt>.</p><a href="#floating-point">
<h3 id="floating-point">Floating-point</h3></a><span class="definition type"><em>[type]</em> <tt>float</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>double</tt>
<br /></span>
<p>A floating-point number. If an exact integer is passed as an argument, then it is automatically converted to a float.</p><span class="definition type"><em>[type]</em> <tt>number</tt>
<br /></span>
<p>A floating-point number. Similar to <tt>double</tt>, but when used as a result type, then either an exact integer or a floating-point number is returned, depending on whether the result fits into an exact integer or not.</p><a href="#strings">
<h3 id="strings">Strings</h3></a><span class="definition type"><em>[type]</em> <tt>c-string</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>nonnull-c-string</tt>
<br /></span>
<p>A zero-terminated C string. The argument value <tt>#f</tt> is allowed and is passed as a <tt>NULL</tt> pointer; similarly, a NULL pointer is returned as <tt>#f</tt>.  Note that the string contents are copied into (automatically managed) temporary storage with a zero byte appended when passed as an argument. Also, a return value of this type is copied into garbage collected memory using <tt>strcpy(3)</tt>.</p>
<p>For the <tt>nonnull-</tt> variant, passing <tt>#f</tt> will raise an exception, and returning a NULL pointer will result in undefined behavior (e.g. a segfault).</p><span class="definition type"><em>[type]</em> <tt>c-string*</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>nonnull-c-string*</tt>
<br /></span>
<p>Similar to <tt>c-string</tt> and <tt>nonnull-c-string</tt>, but if used as a result type, the pointer returned by the foreign code will be freed (using the C library's <tt>free(3)</tt>) after copying. This type specifier is not valid as a result type for callbacks defined with <tt>define-external</tt>.</p><span class="definition type"><em>[type]</em> <tt>unsigned-c-string</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>nonnull-unsigned-c-string</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>unsigned-c-string*</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>nonnull-unsigned-c-string*</tt>
<br /></span>
<p>Same as <tt>c-string</tt>, <tt>nonnull-c-string</tt>, etc. but mapping to C's <tt>unsigned char *</tt> type.</p><span class="definition type"><em>[type]</em> <tt>c-string-list</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>c-string-list*</tt>
<br /></span>
<p>Takes a pointer to an array of C strings terminated by a <tt>NULL</tt> pointer and returns a list of strings.  The starred version <tt>c-string-list*</tt> also releases the storage of each string and the pointer array afterward using <tt>free(1)</tt>.</p>
<p>Only valid as a result type, and can only be used with non-callback functions.</p><span class="definition type"><em>[type]</em> <tt>symbol</tt>
<br /></span>
<p>A symbol, which will be passed to foreign code as a zero-terminated string.</p>
<p>When declared as the result of foreign code, the result should be a string and a symbol with the same name will be interned in the symbol table (and returned to the caller).  Attempting to return a NULL string will raise an exception.</p><a href="#bytevectors">
<h3 id="bytevectors">Bytevectors</h3></a><span class="definition type"><em>[type]</em> <tt>blob</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>nonnull-blob</tt>
<br /></span>
<p>A blob object, passed as a pointer to its contents.  Permitted only as argument type, not return type.</p>
<p>Arguments of type <tt>blob</tt> may optionally be <tt>#f</tt>, which is passed as a NULL pointer.  For the <tt>nonnull-</tt> variant, passing a <tt>#f</tt> value will raise an exception.</p><span class="definition type"><em>[type]</em> <tt>u8vector</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>u16vector</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>u32vector</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>u64vector</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>s8vector</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>s16vector</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>s32vector</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>s64vector</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>f32vector</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>f64vector</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>nonnull-u8vector </tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>nonnull-u16vector </tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>nonnull-u32vector </tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>nonnull-u64vector </tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>nonnull-s8vector </tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>nonnull-s16vector</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>nonnull-s32vector</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>nonnull-s64vector</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>nonnull-f32vector</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>nonnull-f64vector</tt>
<br /></span>
<p>A <a href="Module srfi-4" class="internal">SRFI-4</a> number-vector object, passed as a pointer to its contents. These are allowed only as argument types, not as return types.</p>
<p>The value <tt>#f</tt> is also allowed and is passed to C as a NULL pointer. For the <tt>nonnull-</tt> variants, passing <tt>#f</tt> will raise an exception.</p><a href="#pointers">
<h3 id="pointers">Pointers</h3></a><span class="definition type"><em>[type]</em> <tt>c-pointer</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>(c-pointer TYPE)</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>nonnull-c-pointer</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>(nonnull-c-pointer TYPE)</tt>
<br /></span>
<p>An operating-system pointer or a locative.  <tt>c-pointer</tt> is untyped, whereas <tt>(c-pointer TYPE)</tt> points to an object of foreign type TYPE.</p>
<p>The value <tt>#f</tt> is allowed and is passed to C as a <tt>NULL</tt> pointer; similarly, NULL is returned as <tt>#f</tt>.  For the two <tt>nonnull-</tt> variants, passing <tt>#f</tt> will raise an exception, and returning NULL will result in a null <tt>pointer</tt> object.</p>
<p>(Note: It is still possible to deliberately pass a null pointer through a <tt>nonnull-c-pointer</tt> by manually creating a null pointer object, e.g. via <tt>(address-&gt;pointer 0)</tt>.)</p><span class="definition type"><em>[type]</em> <tt>pointer-vector</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>nonnull-pointer-vector</tt>
<br /></span>
<p>A vector of foreign pointer objects; see <a href="/man/5/Module (chicken memory)#pointer-vectors" class="internal">Pointer vectors</a>. Permitted only as an argument type, not as return type.  This type was introduced in CHICKEN 4.6.3.</p>
<p>A pointer vector contains a C array of void pointers, and the argument is passed as a <tt>void **</tt> pointer to these contents.  Just as for bytevector types, you must somehow communicate the length of this array to the callee; there is no sentinel node or NULL terminator.</p>
<p><tt>#f</tt> is allowed and passed as a <tt>NULL</tt> pointer.  For the <tt>nonnull-</tt> variant, passing a <tt>#f</tt> value will raise an exception.</p><span class="definition type"><em>[type]</em> <tt>(ref TYPE)</tt>
<br /></span>
<p>A C++ reference type. Reference types are handled the same way as pointers inside Scheme code.</p><span class="definition type"><em>[type]</em> <tt>(function RESULTTYPE (ARGUMENTTYPE1 ... [...]) [CALLCONV])</tt>
<br /></span>
<p>A function pointer. <tt>CALLCONV</tt> specifies an optional calling convention and should be a string. The meaning of this string is entirely platform dependent. The value <tt>#f</tt> is also allowed and is passed as a <tt>NULL</tt> pointer.</p><a href="#scheme-objects">
<h3 id="scheme-objects">Scheme objects</h3></a><span class="definition type"><em>[type]</em> <tt>scheme-object</tt>
<br /></span>
<p>An arbitrary, raw Scheme data object (immediate or non-immediate).  A <tt>scheme-object</tt> is passed or returned as a <tt>C_word</tt>, the internal CHICKEN type for objects.  Typically, this consists of an object header and tag bits.  It is up to you to build or take apart such objects using the core library routines in <tt>chicken.h</tt> and <tt>runtime.c</tt>.</p>
<p>More information on object structure can be found in <a href="Data representation" class="internal">Data representation</a>.</p><span class="definition type"><em>[type]</em> <tt>scheme-pointer</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>(scheme-pointer TYPE)</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>nonnull-scheme-pointer</tt>
<br /></span><span class="definition type"><em>[type]</em> <tt>(nonnull-scheme-pointer TYPE)</tt>
<br /></span>
<p>An untyped pointer to the <i>contents</i> of a non-immediate Scheme object; for example, the raw byte contents of a string. Only allowed as an argument type, not a return type.</p>
<p>The optional element type <tt>TYPE</tt> may be used to specify what C type should be used in the generated code. This avoids the need to cast the argument.</p>
<p>The value <tt>#f</tt> is also allowed and is passed as a <tt>NULL</tt> pointer. For the <tt>nonnull-</tt> variant, passing <tt>#f</tt> will raise an exception.</p>
<p>Don't confuse this type with <tt>(c-pointer ...)</tt> which means something different (a machine-pointer object).</p>
<p><tt>scheme-pointer</tt> is typically used to get a pointer to the raw byte content of strings and blobs.  But if you pass in a SRFI-4 vector, you will get a pointer to a blob object header (<i>not</i> the blob's contents), which is almost certainly wrong.  Instead, convert to a blob beforehand, or use a SRFI-4 specific type.</p><a href="#user-defined-c-types">
<h3 id="user-defined-c-types">User-defined C types</h3></a><span class="definition type"><em>[type]</em> <tt>(struct NAME)</tt>
<br /></span>
<p>A struct of the name <tt>NAME</tt>, which should be a string.</p>
<p>Structs cannot be directly passed as arguments to foreign functions, nor can they be result values.  However, pointers to structs are allowed.</p><span class="definition type"><em>[type]</em> <tt>(union NAME)</tt>
<br /></span>
<p>A union of the name <tt>NAME</tt>, which should be a string.</p>
<p>Unions cannot be directly passed as arguments to foreign functions, nor can they be result values. However, pointers to unions are allowed.</p><span class="definition type"><em>[type]</em> <tt>(enum NAME)</tt>
<br /></span>
<p>An enumeration type. Handled internally as an <tt>integer</tt>.</p><a href="#c-types">
<h3 id="c-types">C++ types</h3></a><span class="definition type"><em>[type]</em> <tt>(instance CNAME SCHEMECLASS)</tt>
<br /></span>
<p>A pointer to a C++ class instance wrapped into a Scheme object instance. <tt>CNAME</tt> should designate the name of the C++ class, and <tt>SCHEMECLASS</tt> should be the class that wraps the instance pointer.</p>
<p>To use this, an extension will be required that provides an object-creation- and access-interface compatible to <a href="/eggref/4/coops" class="internal">coops</a> or <a href="/eggref/4/tinyclos" class="internal">tinyclos</a>. Specifically, it should provide the following operations:</p>
<pre><tt> (make SCHEMECLASS 'this POINTER)
 (slot-ref INSTANCE 'this)</tt></pre><span class="definition type"><em>[type]</em> <tt>(instance-ref CNAME SCHEMECLASS)</tt>
<br /></span>
<p>A reference to a C++ class instance.</p><span class="definition type"><em>[type]</em> <tt>(template TYPE ARGTYPE ...)</tt>
<br /></span>
<p>A C++ template type. For example <tt>vector&lt;int&gt;</tt> would be specified as <tt>(template &quot;vector&quot; int)</tt>.</p>
<p>Template types cannot be directly passed as arguments or returned as results. However, pointers to template types are allowed.</p><a href="#type-qualifiers">
<h3 id="type-qualifiers">Type qualifiers</h3></a><span class="definition type"><em>[type]</em> <tt>(const TYPE)</tt>
<br /></span>
<p>The foreign type <tt>TYPE</tt> with an additional <tt>const</tt> qualifier.</p><a href="#map-of-foreign-types-to-c-types">
<h3 id="map-of-foreign-types-to-c-types">Map of foreign types to C types</h3></a>
<table>
<tr>
<th>Foreign type</th>
<th>C type</th></tr>

<tr>
<td><tt>bool</tt></td>
<td><tt>int</tt></td></tr>

<tr>
<td><tt>[unsigned-]char</tt></td>
<td><tt>[unsigned] char</tt></td></tr>

<tr>
<td><tt>[unsigned-]byte</tt></td>
<td><tt>[unsigned] char</tt></td></tr>

<tr>
<td><tt>[unsigned-]short</tt></td>
<td><tt>[unsigned] short</tt></td></tr>

<tr>
<td><tt>[unsigned-]int</tt></td>
<td><tt>[unsigned] int</tt></td></tr>

<tr>
<td><tt>[unsigned-]int32</tt></td>
<td><tt>[unsigned] int32_t</tt></td></tr>

<tr>
<td><tt>[unsigned-]integer</tt></td>
<td><tt>[unsigned] int</tt></td></tr>

<tr>
<td><tt>[unsigned-]integer32</tt></td>
<td><tt>[unsigned] int32_t</tt></td></tr>

<tr>
<td><tt>[unsigned-]integer64</tt></td>
<td><tt>[unsigned] int64_t</tt></td></tr>

<tr>
<td><tt>[unsigned-]long</tt></td>
<td><tt>[unsigned] long</tt></td></tr>

<tr>
<td><tt>size_t</tt></td>
<td><tt>size_t</tt></td></tr>

<tr>
<td><tt>ssize_t</tt></td>
<td><tt>ssize_t</tt></td></tr>

<tr>
<td><tt>float</tt></td>
<td><tt>float</tt></td></tr>

<tr>
<td><tt>double</tt></td>
<td><tt>double</tt></td></tr>

<tr>
<td><tt>number</tt></td>
<td><tt>double</tt></td></tr>

<tr>
<td><tt>[nonnull-]c-pointer</tt></td>
<td><tt>void *</tt></td></tr>

<tr>
<td><tt>[nonnull-]pointer-vector</tt></td>
<td><tt>void **</tt></td></tr>

<tr>
<td><tt>[nonnull-]blob</tt></td>
<td><tt>unsigned char *</tt></td></tr>

<tr>
<td><tt>[nonnull-]u8vector</tt></td>
<td><tt>unsigned char *</tt></td></tr>

<tr>
<td><tt>[nonnull-]s8vector</tt></td>
<td><tt>char *</tt></td></tr>

<tr>
<td><tt>[nonnull-]u16vector</tt></td>
<td><tt>unsigned short *</tt></td></tr>

<tr>
<td><tt>[nonnull-]s16vector</tt></td>
<td><tt>short *</tt></td></tr>

<tr>
<td><tt>[nonnull-]u32vector</tt></td>
<td><tt>uint32_t *</tt></td></tr>

<tr>
<td><tt>[nonnull-]s32vector</tt></td>
<td><tt>int32_t *</tt></td></tr>

<tr>
<td><tt>[nonnull-]u64vector</tt></td>
<td><tt>uint64_t *</tt></td></tr>

<tr>
<td><tt>[nonnull-]s64vector</tt></td>
<td><tt>int64_t *</tt></td></tr>

<tr>
<td><tt>[nonnull-]f32vector</tt></td>
<td><tt>float *</tt></td></tr>

<tr>
<td><tt>[nonnull-]f64vector</tt></td>
<td><tt>double *</tt></td></tr>

<tr>
<td><tt>[nonnull-]c-string</tt></td>
<td><tt>char *</tt></td></tr>

<tr>
<td><tt>[nonnull-]unsigned-c-string</tt></td>
<td><tt>unsigned char *</tt></td></tr>

<tr>
<td><tt>c-string-list</tt></td>
<td><tt>char **</tt></td></tr>

<tr>
<td><tt>symbol</tt></td>
<td><tt>char *</tt></td></tr>

<tr>
<td><tt>void</tt></td>
<td><tt>void</tt></td></tr>

<tr>
<td><tt>([nonnull-]c-pointer TYPE)</tt></td>
<td><tt>TYPE *</tt></td></tr>

<tr>
<td><tt>([nonnull-]scheme-pointer TYPE)</tt></td>
<td><tt>TYPE *</tt></td></tr>

<tr>
<td><tt>(enum NAME)</tt></td>
<td><tt>enum NAME</tt></td></tr>

<tr>
<td><tt>(struct NAME)</tt></td>
<td><tt>struct NAME</tt></td></tr>

<tr>
<td><tt>(ref TYPE)</tt></td>
<td><tt>TYPE &amp;</tt></td></tr>

<tr>
<td><tt>(template T1 T2 ...)</tt></td>
<td><tt>T1&lt;T2, ...&gt;</tt></td></tr>

<tr>
<td><tt>(union NAME)</tt></td>
<td><tt>union NAME</tt></td></tr>

<tr>
<td><tt>(function RTYPE (ATYPE ...) [CALLCONV])</tt></td>
<td><tt>[CALLCONV] RTYPE (*)(ATYPE, ...)</tt></td></tr>

<tr>
<td><tt>(instance CNAME SNAME)</tt></td>
<td><tt>CNAME *</tt></td></tr>

<tr>
<td><tt>(instance-ref CNAME SNAME)</tt></td>
<td><tt>CNAME &amp;</tt></td></tr></table>
<hr />
<p>Previous: <a href="Accessing external objects" class="internal">Accessing external objects</a></p>
<p>Next: <a href="Embedding" class="internal">Embedding</a></p></div></body></html>