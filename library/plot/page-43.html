<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>PLOT: Protocol Definition</title></head><body><banner><center><h1>Programming Language for Old Timers</h1><br>by David A. Moon<br>February 2006 .. September 2008<br></center><br>Comments and criticisms to dave underscore moon atsign alum dot mit dot edu.<br><hr><br><P align=center><A HREF="page-42.html">Previous page</A>&nbsp;&nbsp;&nbsp;<A HREF="index.html">Table of Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="page-44.html">Next page</A></P><BR><h2>Protocol Definition</h2><P>A protocol is simply a named type.  Its semantics, if any, comes fromthe methods and method requirements that have parameters of that type.<P>A method requirement is like a method definition with no body.  It assertsthat when the function is called with arguments of the specified number andtypes, there will be an applicable method (not necessarily always the samemethod).  If a method requirement specifies a result type or types, theapplicable method must declare result type(s) that are the same orsubtypes.  This is useful documentation of the intended meaning of afunction.<P>If a compiler can infer that this assertion can be unsatisfied,it should issue a warning that a method that is intended to be available isknown to be missing.  This is a warning, not an error, because the missingmethod could always be dynamically created before it is needed.<P>Typically some of the parameter types of a method requirement are protocols,although this is not required.<P>If a parameter type in a method requirement is <TT>something</TT>, thatparameter type is disregarded when checking whether there is a method that satisfiesthe method requirement.  There are no objects that are members of <TT>something</TT>.The difference between <TT>something</TT> and <TT>anything</TT> is that<TT>something</TT> requires a method to exist that is applicable to some objectin that argument position, while <TT>anything</TT> requires a method to existthat is applicable to every object in that argument position.<P>A result type in a method requirement cannot usefully be <TT>something</TT>since that type has no subtypes.<P>For convenience, a single defprotocol statement can both define a protocoltype and specify a series of method requirements.  It is good practice, butnot required, for each method requirement to have at least one parameter orresult that is restricted to the protocol type.<P>The syntax of the defprotocol statement is:<P><PRE>defmacro defprotocol ?:name [ ?=is { ?superprotocol is name &amp; ~^ , }+ ]                     { ^ ?:method-head }* =&gt; ...</PRE><P>Example:<P><PRE>defprotocol sequence  start-iteration(x is sequence, result: state is anything)  end?(x is sequence, state is something, result: end? is boolean)  next(x is sequence, state is something, result: element)  advance(x is sequence, state is something, result: new-state)</PRE><P>The syntax of the require statement is:<P><PRE>defmacro require ?:method-head =&gt; ...</PRE><P>Example of a standalone method requirement: suppose every object were requiredto have a to-string method, but there is no default method specialized to<TT>anything</TT>.  This can be asserted by:<P><PRE>require to-string(x is anything, result: string)</PRE><P><P><BR><P align=center><A HREF="page-42.html">Previous page</A>&nbsp;&nbsp;&nbsp;<A HREF="index.html">Table of Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="page-44.html">Next page</A></P><BR><br></body></html>