<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>PLOT: Control Statements</title></head><body><banner><center><h1>Programming Language for Old Timers</h1><br>by David A. Moon<br>February 2006 .. September 2008<br></center><br>Comments and criticisms to dave underscore moon atsign alum dot mit dot edu.<br><hr><br><P align=center><A HREF="page-32.html">Previous page</A>&nbsp;&nbsp;&nbsp;<A HREF="index.html">Table of Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="page-34.html">Next page</A></P><BR><h2>Control Statements</h2><P>The standard control statements in PLOT, with their syntax, are as follows:<P><PRE>defmacro do ?:body =&gt; ...</PRE><P>Evaluate a sequence of expressions in order. The last expression suppliesthe result(s) returned by the do statement.  The preceding expressionsare executed for effect.<P>If the keyword result: appears before one of the expressions, thatexpression supplies the result(s) and the other expressions are executedfor effect.  This allows the result(s) to come from other than the lastexpression in the body.<P>The body expressions can be followed by the keyword cleanup: and anotherbody.  The cleanup body is executed whenever control leaves the dostatement, whether normally or abnormally.  An abnormal exit can be dueto a non-local transfer of controlperformed by calling an exit function established at an outer level.The result(s) of the cleanup body are discarded.  The cleanup body isits own block so any definitions in it are not visible outside.<P>Note that the cleanup: keyword must be exdented at least one space relativeto the body.  Otherwise the keyword will be interpreted as an (invalid)expression in the body rather than as introducing a cleanup body.Fundamentally, this is because of the LL(1) parsing.<P>All statements that have bodies evaluate their bodies in this same wayand accept these same keywords.<P><PRE>defmacro block ?:block =&gt; ...</PRE><P>Similar to do but defines a local scope.<P>In addition, the body expressions can be preceded by the keyword exit: and a name.This defines the name to be a function which when called returnsimmediately from the block statement without executing the rest of thebody.  Any intervening function calls are terminated.  The arguments tothe exit function become the results of the block statement.  The exitfunction cannot be called once control has left the block statement.<P>All statements that contain embedded blocks evaluate those blocks in thissame way and accept these same keywords.<P><PRE>defmacro if { ?test [then] ?then is block &amp; elseif }+            [ else ?else is block ] =&gt; ...</PRE><P>Conditional.  Evaluate the tests one by one.  The first test whose value isnot false executes the corresponding then block and returns its values asthe results of the if statement.  The remaining tests are not evaluated.  Ifevery test is false, the else block is executed and its values are returned,or if there is no else block the result is false.<P>Example:<PRE>        if x &lt; 10          f(x)          g(x - 1)        elseif x &lt; 100          f(x, x * 2)        else          f(x / 1000)</PRE><P>Any definition in a test expression is defined in the enclosing block,so its scope includes the entire conditional statement including allthe tests and all the bodies, and also extends outside the if statement.It is considered poor style to access such a definition outside the if statement.Each then or else clause is itself a block.<P>Example:<PRE>        if def temp = f(x)          g(temp)        else          g(x)</PRE><P>Note that by PLOT newline rules you can write<PRE>if f(x) then g(x) else e(x)</PRE>and you can write<PRE>if f(x) then g(x)else e(x)</PRE>and you can write<PRE>if f(x)  g(x)  h(x)else e(x)</PRE>but you cannot write<PRE>if f(x) then g(x)             h(x)else e(x)</PRE>A multi-line body must start and end on a new line.  This applies to allstatements containing bodies or blocks, not just <TT>if</TT>.<P><PRE>defmacro case ?object { ?value \=&gt; ?:block }*                      [ default: ?default is block ] =&gt; ...</PRE><P>Case dispatch.  Evaluate the object expression once and save the value.  Thenevaluate the value expressions one by one.  The first value that is = to theobject executes the corresponding block and returns its value(s) as the result(s)of the case statement.  The remaining values are not evaluated.  If no valuematches, the default block is executed and its values are returned, or if thereis no default block the result is false.<P>Example:<PRE>        case color          #red    =&gt; f("magenta")          #blue   =&gt; f("cyan")          #green  =&gt; f("jade")          selected-color =&gt; f(0)          default: f(1)</PRE><P><PRE>defmacro with-slots ?object ?:block =&gt; ...</PRE><P>Slot access abbreviation.  Evaluate the object expression once and save thevalue.  For each slot in the compile-time class of the object, locallydefine a macro whose name is the slot and whose expansion isobject.slotname.  Execute the block in the scope of those macros and returnits values as the result(s) of the with-slots statement.  The slot macrosare only visible in the body block.<P>Example:<PRE>        with-slots point          (x - x1) ^ 2 + (y - y1) ^2</PRE>is the same as<PRE>        (point.x - x1) ^ 2 + (point.y - y1) ^2</PRE>assuming that the compile-time type of point is a class that has slotsnamed x and y.<P>Example of early exit:<PRE>        block exit: yield          for x in sequence            if f(x) yield(x + 1)</PRE><P>Example of cleanup:<PRE>        do          open-gate()          go-through()         cleanup:          close-gate()</PRE><P>All of these statements use the syntactic types body and block.  Thesyntax of body and implementation of its parser are:<PRE>defparser body { ^ [ result: ??result ] ?expr }+               [ cleanup: ?cleanup is block ] =&gt;  ;; Construct the main body  def body := if length(expr) &gt; 1                collation@compiler(expr...)              else expr[0]  ;; Adjust it if the result: keyword is used  if def pos = position(true, result)    if (for x in result count x) &gt; 1      error("The result: keyword can only be used once in a body")    body := collation-first@compiler(expr[pos : expr.length - 1]...)    if pos &gt; 0      body := collation@compiler(expr[0 : pos - 1]..., body)  ;; Wrap it in a cleanup if necessary  if cleanup    body := sanitation@compiler(body, cleanup)  ;; Return the P-expression  body</PRE><P>Note that the implementation of the syntactic type body only allows theresult: keyword to appear at most once even though the syntax patternallows multiple occurrences.<P>The syntactic type block encloses a body in a block thus locally scopingany definitions in the body.  It also allows an exit function to bespecified before the body.  The implementation looks like:<PRE>def parse-block(token-stream, error?)  with-source-location source-location(token-stream)    with-new-compiler-scope      def scope = get-local-compiler-scope()      ;; Handle the optional exit: keyword      def exit = match?(#exit:, token-stream) and                 parse-name(token-stream, true)      if exit        constant-definition(scope, exit, exit-function(name))      ;; Parse the body      def body := parse-body(token-stream, error? or exit)      ;; Wrap the body in an exit if necessary      if exit        body := exitation@compiler(scope, exit, body)      ;; If nothing was parsed, return false (error? must be false)      ;; Otherwise return the body, wrapped in a block if necessary      if not body false      else if empty?(scope) body      else scopation@compiler(scope, body)</PRE>Note that it not sufficient just to enclose the body in a scopation,the scope must be set up before parsing any definitions that may be in thebody.<P><P><BR><P align=center><A HREF="page-32.html">Previous page</A>&nbsp;&nbsp;&nbsp;<A HREF="index.html">Table of Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="page-34.html">Next page</A></P><BR><br></body></html>