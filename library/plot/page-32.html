<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>PLOT: Definition Statements</title></head><body><banner><center><h1>Programming Language for Old Timers</h1><br>by David A. Moon<br>February 2006 .. September 2008<br></center><br>Comments and criticisms to dave underscore moon atsign alum dot mit dot edu.<br><hr><br><P align=center><A HREF="page-31.html">Previous page</A>&nbsp;&nbsp;&nbsp;<A HREF="index.html">Table of Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="page-33.html">Next page</A></P><BR><h2>Definition Statements</h2><P>This is a summary of the standard definition statements in PLOT.  Theirdetailed syntax is given in later sections.<P><TABLE cellspacing="20"><col width="25%" align="left" valign="top"/><col/><TR><TD align="left" valign="top"><tt>def</tt></TD><TD>defines a value or a method.  A value definition specifies a name,optionally a type, an = or := sign, and an expression.  The name becomesdefined to the value of the expression.  Using = creates a fixed definition.Using := creates an assignable definition.  All definitions otherthan assignable value definitions are fixed.  Multiple names separated bycommas can be listed on the left-hand side; they are defined to multiplevalues returned by the right-hand side.<P>A method definition specifies a function name, a parameter list inparentheses, and a body.  A method with the specified parameters and body isadded to the function that is the definition of the name.  If a definitionof the name does not already exist in the current scope (not inherited froman enclosing scope), a new function definition is created.  Theparenthesized parameter list can be followed by := and one more parameterto define a setter function.  A call to a prefix or infix operator oroperator macro can be used in place of the function name and parameterlist.<P>When re-executing a method definition after editing it to change itsparameter list, it is the responsibility of the development environmentto distinguish between adding a new method and replacing a method whilechanging its parameters.</TD></TR><TR><TD align="left" valign="top"><tt>defmacro</tt></TD><TD>defines a macro, which is a syntax extension.  It specifies aname, one or more syntax patterns, and for each pattern an expression thatreturns the expansion of the macro.</TD></TR><TR><TD align="left" valign="top"><tt>defsyntax</tt></TD><TD>defines a syntactic type, with one or more patterns for parsing it.  Thiscan be invoked from other syntax patterns.</TD></TR><TR><TD align="left" valign="top"><tt>defparser</tt></TD><TD>defines one or more syntax patterns that can be invoked as a kind ofsubroutine from other syntax patterns.</TD></TR><TR><TD align="left" valign="top"><tt>defoperator</tt></TD><TD>defines an operator, which can be invoked with prefix orinfix syntax.  It specifies the name of the operator, some attributes suchas its precedence, and optionally macros to parse the prefix and/or infixforms of invocations of the operator.</TD></TR><TR><TD align="left" valign="top"><tt>defmodule</tt></TD><TD>defines a module, specifying its name, exports, and from whichother modules it imports definitions.</TD></TR><TR><TD align="left" valign="top"><tt>defclass</tt></TD><TD>defines a class of objects.  It specifies a constructor andinitializer parameter list, inheritance from another class and from zeroor more protocols, and a set of slots which have values in each instanceof the class.</TD></TR><TR><TD align="left" valign="top"><tt>defprotocol</tt></TD><TD>defines a protocol type and a set of related method requirements.A method requirement asserts that the function will always have a method for aspecific set of argument types.  A protocol is a type whose semantics comefrom the methods and method requirements that have parameters of that type.</TD></TR><TR><TD align="left" valign="top"><tt>require</tt></TD><TD>specifies a method requirement.  This does not define any name.</TD></TR></TABLE><P>All definition statements work in the global scope or in a local scope. Ifthe name being defined is a name-in-context whose context is a module, the definition statementmust be in the global scope anddefines a global definition in the specified module. Otherwise, adefinition statement in the global scope defines a global definition in thecurrent module, while a definition statement in a local scope defines alocal definition in that scope. Local defmacro and defoperator work becausea known definition is recorded immediately before parsing the rest of theblock.  Local defmodule, defclass, and defprotocol are permitted but areprobably useless.<P>Examples:<PRE>def pi = 3.14159def x1, y1 = transform(x, y)def state := #Alabamadef factorial(n) if n &lt; 2 then 1 else n * factorial(n - 1)defmacro exch(?a, ?b) =&gt;  `block     def temp = ?a     ?b := ?a     ?a := temp`defclass point(x, y)  x = x  y = y;; The above can be abbreviated todefclass point  x  y</PRE><P><P><BR><P align=center><A HREF="page-31.html">Previous page</A>&nbsp;&nbsp;&nbsp;<A HREF="index.html">Table of Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="page-33.html">Next page</A></P><BR><br></body></html>