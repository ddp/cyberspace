<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>PLOT: Sequence Iteration Protocol</title></head><body><banner><center><h1>Programming Language for Old Timers</h1><br>by David A. Moon<br>February 2006 .. September 2008<br></center><br>Comments and criticisms to dave underscore moon atsign alum dot mit dot edu.<br><hr><br><P align=center><A HREF="page-7.html">Previous page</A>&nbsp;&nbsp;&nbsp;<A HREF="index.html">Table of Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="page-9.html">Next page</A></P><BR><h2>Sequence Iteration Protocol</h2><P>Perhaps the most fundamental protocol is sequence.  Any object thatimplements the sequence protocol possesses a series of elements thatcan be accessed one at a time through iteration.  The order in whichiteration visits the elements is meaningful for most sequences, butit is not required to be meaningful nor repeatable if multiple iterationsare done over the same sequence.<P>Iteration uses a current state object whose type is completely dependenton the type of the sequence object.<P>The following method requirements constitute the sequence protocol:<PRE>defprotocol sequence  start-iteration(x is sequence, result: state is anything)  end?(x is sequence, state is something, result: end? is boolean)  next(x is sequence, state is something, result: element)  advance(x is sequence, state is something, result: new-state)</PRE><P>start-iteration returns the initial state.<P>end? checks whether a state is the ending state, i.e. advanced past allelements.<P>next returns the element associated with the current state.  If the endhas been reached, the result is undefined.<P>advance returns the next state.  If called when the end has been reached,advance returns a valid state which is still at the end.<P>A subprotocol is assignable-sequence, which adds this method requirement:<PRE>defprotocol assignable-sequence is sequence  next:=(x is sequence, state is something, new-element)</PRE><P>which replaces the element associated with the current state.  If the endhas been reached an error occurs.  Like allassignment methods this method returns its last argument.<P>Another subprotocol is keyed-sequence, which adds these method requirements:<PRE>defprotocol keyed-sequence is sequence  next-key(x is keyed-sequence, state is something, result: key)  (x is keyed-sequence)[key is something], result: element</PRE><P>next-key returns a key associated with the current state.  If the endhas been reached, the result is undefined.  This can be usedwith the <TT>[]</TT> macro to access the element associated with the current state.<P><PRE>defprotocol assignable-keyed-sequence is keyed-sequence  (x is keyed-sequence)[key is something] := new-element</PRE><P><P><BR><P align=center><A HREF="page-7.html">Previous page</A>&nbsp;&nbsp;&nbsp;<A HREF="index.html">Table of Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="page-9.html">Next page</A></P><BR><br></body></html>