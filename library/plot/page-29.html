<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>PLOT: Summary Of Built-Ins</title></head><body><banner><center><h1>Programming Language for Old Timers</h1><br>by David A. Moon<br>February 2006 .. September 2008<br></center><br>Comments and criticisms to dave underscore moon atsign alum dot mit dot edu.<br><hr><br><P align=center><A HREF="page-28.html">Previous page</A>&nbsp;&nbsp;&nbsp;<A HREF="index.html">Table of Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="page-30.html">Next page</A></P><BR><h2>Summary Of Built-Ins</h2><P>This section is the equivalent of explaining all the constructs built into thecompiler in other languages.  But here these are simply definitions exported bythe PLOT module.  You can import them into your own module or not as you prefer.Most of these constructs have straightforward definitions within the language.A few of them involve intrinsic methods that are known to the compiler.<P>Standard operators:<P><TABLE cellspacing="20"><col width="25%" align="left" valign="top"/><col/><TR><TD align="left" valign="top"><tt>+</tt></TD><TD>addition, array concatenation</TD></TR><TR><TD align="left" valign="top"><tt>-</tt></TD><TD>subtraction</TD></TR><TR><TD align="left" valign="top"><tt>*</tt></TD><TD>multiplication</TD></TR><TR><TD align="left" valign="top"><tt>/</tt></TD><TD>division</TD></TR><TR><TD align="left" valign="top"><tt>mod</tt></TD><TD>modulo</TD></TR><TR><TD align="left" valign="top"><tt>=</tt></TD><TD>equality</TD></TR><TR><TD align="left" valign="top"><tt>&lt;</tt></TD><TD>less than</TD></TR><TR><TD align="left" valign="top"><tt>&gt;</tt></TD><TD>greater than</TD></TR><TR><TD align="left" valign="top"><tt>&lt;=</tt></TD><TD>less than or equal</TD></TR><TR><TD align="left" valign="top"><tt>&gt;=</tt></TD><TD>greater than or equal</TD></TR><TR><TD align="left" valign="top"><tt>~=</tt></TD><TD>not equal</TD></TR><TR><TD align="left" valign="top"><tt>eq</tt></TD><TD>same object</TD></TR><TR><TD align="left" valign="top"><tt>~eq</tt></TD><TD>not same object</TD></TR><TR><TD align="left" valign="top"><tt>:=</tt></TD><TD>assignment</TD></TR><TR><TD align="left" valign="top"><tt><&lt;</tt></TD><TD>left shift</TD></TR><TR><TD align="left" valign="top"><tt>&gt;&gt;</tt></TD><TD>right shift</TD></TR><TR><TD align="left" valign="top"><tt>is</tt></TD><TD>instance of</TD></TR><TR><TD align="left" valign="top"><tt>:</tt></TD><TD>range given start and end</TD></TR><TR><TD align="left" valign="top"><tt>:+</tt></TD><TD>range given start and length</TD></TR><TR><TD align="left" valign="top"><tt>&amp;</tt></TD><TD>bitwise and</TD></TR><TR><TD align="left" valign="top"><tt>|</tt></TD><TD>bitwise or</TD></TR><TR><TD align="left" valign="top"><tt>~</tt></TD><TD>bitwise complement</TD></TR><TR><TD align="left" valign="top"><tt>and</tt></TD><TD>logical and</TD></TR><TR><TD align="left" valign="top"><tt>or</tt></TD><TD>logical or</TD></TR><TR><TD align="left" valign="top"><tt>not</tt></TD><TD>logical not</TD></TR></TABLE><P>Standard prefix macros:<P><TABLE cellspacing="20"><col width="25%" align="left" valign="top"/><col/><TR><TD align="left" valign="top"><tt>( expression )</tt></TD><TD>grouping</TD></TR><TR><TD align="left" valign="top"><tt>[ parameter-list =&gt; body ]</tt></TD><TD>function constructor</TD></TR><TR><TD align="left" valign="top"><tt># data</tt></TD><TD>quoted data</TD></TR><TR><TD align="left" valign="top"><tt>` template `</tt></TD><TD>token sequence constructor from template</TD></TR></TABLE><P>Standard prefix macros considered statements:  (explained below)<P><TABLE cellspacing="20"><col width="25%" align="left" valign="top"/><col/><TR><TD align="left" valign="top">if <I>test</I> [then] <I>body</I> else <I>body</I></TD><TD>conditional (also allows elseif)</TD></TR><TR><TD align="left" valign="top">do <I>body</I></TD><TD>grouping</TD></TR><TR><TD align="left" valign="top">do <I>body</I> cleanup: <I>body</I></TD><TD>cleanup on exit</TD></TR><TR><TD align="left" valign="top">block <I>body</I></TD><TD>grouping and scoping</TD></TR><TR><TD align="left" valign="top">block exit: <I>name</I> <I>body</I></TD><TD>permit early exit</TD></TR><TR><TD align="left" valign="top">block <I>body</I> cleanup: <I>body</I></TD><TD>cleanup on exit</TD></TR><TR><TD align="left" valign="top">while <I>test</I> <I>body</I></TD><TD>iteration</TD></TR><TR><TD align="left" valign="top">until <I>test</I> <I>body</I></TD><TD>iteration</TD></TR><TR><TD align="left" valign="top">for ... <I>body</I></TD><TD>complex iteration</TD></TR><TR><TD align="left" valign="top">case ....</TD><TD>case dispatch</TD></TR><TR><TD align="left" valign="top">with-slots ....</TD><TD>abbreviated syntax for slot references</TD></TR><TR><TD align="left" valign="top">def</TD><TD>variable or method definition</TD></TR><TR><TD align="left" valign="top">defoperator</TD><TD>operator definition</TD></TR><TR><TD align="left" valign="top">defmacro</TD><TD>macro definition</TD></TR><TR><TD align="left" valign="top">defparser</TD><TD>parser definition</TD></TR><TR><TD align="left" valign="top">defsyntax</TD><TD>parser definition, accepts already-parsed form</TD></TR><TR><TD align="left" valign="top">defmodule</TD><TD>module definition</TD></TR><TR><TD align="left" valign="top">defclass</TD><TD>class definition</TD></TR><TR><TD align="left" valign="top">defprotocol</TD><TD>protocol definition</TD></TR><TR><TD align="left" valign="top">require</TD><TD>method requirement</TD></TR></TABLE><P>Standard infix macros:<P><TABLE cellspacing="20"><col width="25%" align="left" valign="top"/><col/><TR><TD align="left" valign="top"><I>function</I> ( <I>arguments</I> )</TD><TD>call</TD></TR><TR><TD align="left" valign="top"><I>collection</I> [ <I>subscripts</I> ]</TD><TD>subscripting</TD></TR><TR><TD align="left" valign="top"><I>object</I> . <I>slot-name</I></TD><TD>single-valued slot access</TD></TR><TR><TD align="left" valign="top"><I>object</I> . <I>slot-name</I> [ <I>subscript</I> ]</TD><TD>multi-valued slot access</TD></TR><TR><TD align="left" valign="top"><I>object</I> . <I>slot-name</I> . length</TD><TD>multi-valued slot length</TD></TR></TABLE><P>Particles Used by Standard Macros:<P><TABLE cellspacing="20"><col width="25%" align="left" valign="top"/><col/><TR><TD align="left" valign="top"><tt>,</tt></TD><TD>list element separator</TD></TR><TR><TD align="left" valign="top"><tt>=&gt;</tt></TD><TD>input/output separator</TD></TR><TR><TD align="left" valign="top"><tt>\</tt></TD><TD>denaturer, prevents next token from being special</TD></TR><TR><TD align="left" valign="top"><tt>#</tt></TD><TD>quote</TD></TR><TR><TD align="left" valign="top"><tt>=</tt></TD><TD>separates name and value</TD></TR><TR><TD align="left" valign="top"><tt>:=</tt></TD><TD>separates name and value, is assignable</TD></TR><TR><TD align="left" valign="top"><tt>?</tt></TD><TD>pattern/template variable</TD></TR><TR><TD align="left" valign="top"><tt>?:</tt></TD><TD>pattern/template variable, syntactic type same as name</TD></TR><TR><TD align="left" valign="top"><tt>?=</tt></TD><TD>bound particle in pattern, anaphoric name in template</TD></TR><TR><TD align="left" valign="top"><tt>{ }</tt></TD><TD>pattern grouping</TD></TR><TR><TD align="left" valign="top"><tt>[ ]</tt></TD><TD>pattern optional</TD></TR><TR><TD align="left" valign="top"><tt>^</tt></TD><TD>pattern linebreak</TD></TR><TR><TD align="left" valign="top"><tt>~^</tt></TD><TD>pattern not linebreak</TD></TR><TR><TD align="left" valign="top"><tt>|</tt></TD><TD>pattern alternative separator</TD></TR><TR><TD align="left" valign="top"><tt>&amp;</tt></TD><TD>pattern suffix separator</TD></TR><TR><TD align="left" valign="top"><tt>{ }*</tt></TD><TD>pattern repeat zero or more times</TD></TR><TR><TD align="left" valign="top"><tt>{ }+</tt></TD><TD>pattern repeat one or more times</TD></TR><TR><TD align="left" valign="top"><tt>[ ]*</tt></TD><TD>each alternative appears at most once, in any order</TD></TR><TR><TD align="left" valign="top"><tt>[ ]+</tt></TD><TD>same but at least one alternative must appear</TD></TR><TR><TD align="left" valign="top"><tt>is</tt></TD><TD>type restriction (bound)</TD></TR><TR><TD align="left" valign="top"><tt>then</tt></TD><TD></TD></TR><TR><TD align="left" valign="top"><tt>else</tt></TD><TD></TD></TR><TR><TD align="left" valign="top"><tt>in</tt></TD><TD></TD></TR><TR><TD align="left" valign="top"><tt>from</tt></TD><TD></TD></TR><TR><TD align="left" valign="top"><tt>downfrom</tt></TD><TD></TD></TR><TR><TD align="left" valign="top"><tt>above</tt></TD><TD></TD></TR><TR><TD align="left" valign="top"><tt>below</tt></TD><TD></TD></TR><TR><TD align="left" valign="top"><tt>by</tt></TD><TD></TD></TR><TR><TD align="left" valign="top"><tt>while</tt></TD><TD></TD></TR><TR><TD align="left" valign="top"><tt>until</tt></TD><TD></TD></TR></TABLE><P><P><BR><P align=center><A HREF="page-28.html">Previous page</A>&nbsp;&nbsp;&nbsp;<A HREF="index.html">Table of Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="page-30.html">Next page</A></P><BR><br></body></html>