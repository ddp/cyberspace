<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>PLOT: Template Syntax</title></head><body><banner><center><h1>Programming Language for Old Timers</h1><br>by David A. Moon<br>February 2006 .. September 2008<br></center><br>Comments and criticisms to dave underscore moon atsign alum dot mit dot edu.<br><hr><br><P align=center><A HREF="page-24.html">Previous page</A>&nbsp;&nbsp;&nbsp;<A HREF="index.html">Table of Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="page-26.html">Next page</A></P><BR><h2>Template Syntax</h2><P>You can construct a P-expression any way you want.One way is to construct the objects directly by calling constructorfunctions.  Another way is to construct a sequence of tokens, wrap it ina token-stream, then feed that to parse-expression.  An easy way to dothe latter is using a template.  A template can construct any sequenceof tokens to be parsed.  The <TT>`</TT> macro accepts a templateenclosed in a pair of <TT>`</TT> characters, expands the template into asequence of tokens, and returns the sequence.  The sequence can then bewrapped in a token-stream and fed to any parse function to produce anexpression or other desired object.  Typically, the token sequence isreturned as the result of a macro's parse function.  The macro expanderwill wrap it in a token-stream and pass it to parse-expression.<P>Most macros use templates to construct the P-expressionthat will be the expansion of the macro.<P>Note that the <TT>`</TT> macro is not typically used to produce thedirect result of a defparser or defsyntax, since that result is usuallyexpected to be a P-expression, not a sequence of tokenswaiting to be parsed.  Typically the body of a defsyntax will call theconstructor function for a P-expression.  But it couldalso use the <TT>`</TT> macro to construct a sequence of tokens, wrap itin a token-stream, and pass it to a parser function.<P>In a template the following have special meaning, while other tokens merelyinsert themselves.  A newline in a template inserts a newline.  Indentationand source-locations in templates are preserved as explained below.<P><TABLE cellspacing="20"><col width="25%" align="left" valign="top"/><col/><TR><TD align="left" valign="top"><tt>{ ... }*</tt></TD><TD>repeat the "..." subtemplate zero or more times</TD></TR><TR><TD align="left" valign="top"><tt>{ ... }+</tt></TD><TD>repeat the "..." subtemplate one or more times</TD></TR><TR><TD align="left" valign="top"><tt>&amp;</tt></TD><TD>delimits the separator part of a repeated subtemplate; higherbinding power than { }.  If an additional repeat will occur,insert the separator first.  Otherwise skip the separator.</TD></TR><TR><TD align="left" valign="top"><tt>^</tt></TD><TD>line break -- insert a newline.</TD></TR><TR><TD align="left" valign="top"><tt>?</tt></TD><TD>followed by a name.  Insert the definition of that name.</TD></TR><TR><TD align="left" valign="top"><tt>?=</tt></TD><TD>followed by a name.  Insert a name-in-context with thatspelling in the previous context, which is obtainedby calling <TT>get-previous-context</TT>.</TD></TR><TR><TD align="left" valign="top"><tt>`</tt></TD><TD>not valid in a template, so the template ends here.</TD></TR><TR><TD align="left" valign="top"><tt>\</tt></TD><TD>prevents the next token from being recognized as one ofthe special ones listed here.  Also causes assignment ofa context to the next token to be delayed.</TD></TR></TABLE><P>When a value inserted by ? is false, nothing is inserted, whichmight not be what you want.  You can use def var2 = var or default,and use ?var2 rather than ?var in the template.<P>When a value inserted by ? is a sequence, each element of the sequenceis inserted in turn.  If the sequence is empty, nothing is inserted.  Inthe case of nested sequences, this flattening process is recursive.<P>When ? appears inside of a repeat, then if the value is a sequence eachrepetition uses one element of the sequence, otherwise each repetition uses thesame value.  When repeats are nested, sequences are nested to the same number oflevels.  A repetition repeats as many times as necessary to exhaust all thesequences used with ? inside it.  If one sequence is smaller than another, thesmaller sequence is treated as an empty sequence once it has been exhausted.  If all? values are sequences and all sequences are empty, then the * or + following the }takes effect and controls whether there are no repetitions or one.<P>A simple-name in a template becomes a name-in-context in the expansionof the template.  The context is the context of the macro definition,not the context of the macro call.  This applies to punctuation as well.Each expansion of a macro creates a new context.  A template does notitself create a new context, it depends on having a visible definitionof the name macro-context.  The defmacro macro provides that definition.<P>Every occurrence of a given spelling in templates during a given macroexpansion is a name in the same context.  But each expansion of a macrocreates a new context.  You can also create a new context explicitly usingthe unique-macro-context function and locally define macro-context to it.You can also call the name-in-context constructor with a string and acontext.<P>A template only converts a simple-name to a name-in-context in themacro-context context.  When a name-in-context appears in a template,it retains its existing context.  This makes macro-defining macros work.<P>A name-in-context produced by a template will be reduced to asimple-name with the same spelling if it is parsed in a syntacticposition that requires an absolute particle or literal data rather thanrequiring a name that identifies a definition.  (See the Names,Particles, and Tokens section for the definition of particle.)<P>To create a visible name in a template, use name(spelling,get-previous-context()) to create a name that will be visible to the macro'scaller.  Define a local variable to be that name object, then substituteit into a template via ?. As an abbreviation, you can use ?=name in atemplate to do the same thing.  This works when the macro's caller is atemplate, where a name in the correct context is required.<P>The \ is especially useful when using a <TT>`</TT> template to constructa <TT>`</TT> template.  It allows special tokens such as ? to be insertedinto the constructed template.  It also allows names to be inserted withthe macro context of the inner template rather than the macro context ofthe outer template.<P>The code generated by the <TT>`</TT> macro expands the template to asequence of tokens.<P>The indentation for each newline token in a template expansion depends onthe origin of that token:<P><UL><LI> if the token came from a newline directly in the template, use the indentation  of the newline token in the template.</LI><LI> if the token came from an ^ in the template, use the indentation of the  current line, i.e. the same indentation as the previous newline.</LI><LI> if the token came from a value inserted by ?, use the indentation  of the original newline token, plus the indentation of the current line,  plus 1 if the ? was not the first token on the current line.</LI></UL><P>The source-location for each token in a template expansion depends onthe origin of that token:<P><UL><LI> if the token came directly from the template, use the source-location  of the token in the template.</LI><LI> if the token came from a value inserted by ?, and the value is a compound  expression, or anything else that implements the source-locator protocol,  use the source-location of the token.</LI><LI> otherwise, use the source-location of the ? in the template.</LI></UL><P>When the source-location in a template expansion changes, and the nexttoken does not implement the source-locator protocol, the templateinserts a special source-location-marker object that implements thesource-locator protocol.  A token-stream skips oversource-location-marker objects, only using them to update its currentsource-location.<P><P><BR><P align=center><A HREF="page-24.html">Previous page</A>&nbsp;&nbsp;&nbsp;<A HREF="index.html">Table of Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="page-26.html">Next page</A></P><BR><br></body></html>