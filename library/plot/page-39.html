<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>PLOT: Type Specifiers</title></head><body><banner><center><h1>Programming Language for Old Timers</h1><br>by David A. Moon<br>February 2006 .. September 2008<br></center><br>Comments and criticisms to dave underscore moon atsign alum dot mit dot edu.<br><hr><br><P align=center><A HREF="page-38.html">Previous page</A>&nbsp;&nbsp;&nbsp;<A HREF="index.html">Table of Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="page-40.html">Next page</A></P><BR><h2>Type Specifiers</h2><P>The program syntax includes "type specifiers," which are used in situationswhere a type is required, for example after "is".  To minimize verbosity,type specifiers are distinct from ordinary expressions, but are translatableto ordinary expressions by applying a simple naming convention.<P>A type specifier has exactly the same syntax as an ordinary expression exceptthat every name in a type specifier automatically has a $ prefix added to it.The simplest type specifier is thus just the name of a class or protocol.The following operators are designed to be used in type specifiers:<P><TABLE cellspacing="20"><col width="25%" align="left" valign="top"/><col/><TR><TD align="left" valign="top">$or</TD><TD>This infix operator returns the type union of its arguments.  Unlikeordinary or, it is not a macro and both arguments are evaluatedunconditionally.  $or is also a function taking any number ofarguments and is the pseudo-constructor for type unions (the 0-argumentand 1-argument cases return $something and the argument respectively).</TD></TR><TR><TD align="left" valign="top">$(</TD><TD>As a prefix operator this is similar to the ordinary prefix leftparenthesis macro, except that it encloses a type specifier insteadof an ordinary expression.  As an infix operator this is identical to theordinary infix left parenthesis macro, which allows type specifiersto contain function calls.  The arguments in such a function call areordinary expressions, not type specifiers, and do not have $ prefixesadded to them.</TD></TR><TR><TD align="left" valign="top">$bits</TD><TD>This postfix operator (an infix operator macro that parses no right-handside) returns the range of signed, two's complement integers that fitin the number of bits given as the left-hand side.  Normally the left-handside will be a literal integer but any expression that fits the$ prefix convention can be used.</TD></TR></TABLE><P><P>Note that, as in ordinary expressions, these infix and postfixoperators cannot be the first token on a line.<P>A type-specifier parses into a P-expression which, when evaluated at run time,will yield a type.  A type is a run-time object that represents a binarypartition of all run-time objects into those that are instances of that typeand those that are not.<P>A type object (a class, protocol, range, or type union) can also be used asa type specifier.  It will be quoted.  This can be useful in macros.<P>type-specifier is a syntactic type so you can use it in patterns.<P>When a type specifier is used in a def statement or in an optional or keyparameter specifier, it can be followed by = or :=.  So long as $= and $:=are not defined as infix operators there is no ambiguity.<P>A type-specifier "my-class or false" translates to the expression"\$or($my-class, $false)" which evaluates to the type union that includesall instances of my-class and also the false object (the only instanceof the false class), assuming the definitionsof $or and $false in the PLOT module are in scope.  This is a very common idiom.<P>A type-specifier such as "32 bits" translates to the expression"range(-1 <&lt; 31, (1 <&lt; 31) - 1)" or something equivalent, whichevaluates to the type of all 32-bit signed integers, assumingthe definition of $bits in the PLOT module is in scope.<P>To specify other integer ranges, use the following functions.These functions are designed to be used in type specifiers.  Theirarguments are ordinary expressions and are not subject to $ prefixing.<PRE>$integer-below(x is integer)</PRE>returns a range of all integers strictly less than x.<PRE>$integer-above(x is integer)</PRE>returns a range of all integers strictly greater than x.<PRE>$integer-between(start is integer, end is integer, optional: stride is integer = 1)</PRE>returns a range of all integers greater than or equal to <TT>start</TT> andless than or equal to <TT>end</TT>.  If <TT>stride</TT> is specified, it is the intervalbetween consecutive elements of the range.<P><P><BR><P align=center><A HREF="page-38.html">Previous page</A>&nbsp;&nbsp;&nbsp;<A HREF="index.html">Table of Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="page-40.html">Next page</A></P><BR><br></body></html>