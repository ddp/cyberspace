<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>PLOT: Definitions At Macro Expansion Time</title></head><body><banner><center><h1>Programming Language for Old Timers</h1><br>by David A. Moon<br>February 2006 .. September 2008<br></center><br>Comments and criticisms to dave underscore moon atsign alum dot mit dot edu.<br><hr><br><P align=center><A HREF="page-50.html">Previous page</A>&nbsp;&nbsp;&nbsp;<A HREF="index.html">Table of Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="page-52.html">Next page</A></P><BR><h2>Definitions At Macro Expansion Time</h2><P>It is sometimes necessary to deal explicitly with local scopes inmacros.  For example, the <TT>block</TT> macro must establish a newscope before parsing its body, so that local definitions of macros inthe body get recorded in the correct scope and can assist in the parsingof expressions later in the body.<P>The following macro and functions provide the necessary programminginterface to the compiler's internal data structures.  These should onlybe called at compile time, not at run time.  These names are in thecompiler module.<P><PRE>defmacro with-new-compiler-scope ?:block =&gt; ...</PRE>Establishes a new local scope while evaluating the block.  This is a localscope for parsing that occurs while evaluating the block.  Thus it is a scopefor compiling code produced by the block, not for compiling the block itself.The new scope is nested inside the compiler's current local scope.<P><PRE>def get-local-compiler-scope() ...</PRE>Returns the current local scope established by <TT>with-new-compiler-scope</TT>or by the compiler itself.<P><PRE>def known-definition(name is name) ...</PRE>Returns the value of the known definition of the specified name that is visiblein the current local scope, or false if there is no definition or the definitiondoes not have a known value because it is not a constant-definition.  defclass,defmacro, defmodule, and defoperator create constant-definitions.<P><PRE>def lookup(scope is scope, name is name, result: x is definition or false) ...</PRE>Returns the definition of the specified name that is visible in the specifiedscope, or false if there is no visible definition.<P><PRE>def add-definition(scope is scope, name is name, definition is definition,                   result: definition) ...</PRE>Adds the specified definition to the specified scope under the specified name.Returns its third argument.  Usually this is called implicitly by theconstructor of a definition.<P>Anaphoric macros require access to the context of the macro's caller.This is defined to be the context of the name of the macro in the macro call.For a macro call that appears directly in source code, this context is <TT>false</TT>.For a macro call produced by macro expansion, this context is the context of the first macro.The following macro and function provide the necessary programminginterface to the compiler's internal data structures.  These should onlybe called at compile time, not at run time.  These names are in thecompiler module.<P><PRE>defmacro with-previous-context ?context ?:block =&gt; ...</PRE>Establishes a new previous context while evaluating the block.  The macro expanderinside of <TT>parse-expression</TT> uses this to make the context of the macro'sname in a macro call available to the macro in case the macro uses anaphora.<P><PRE>def get-previous-context() ...</PRE>Returns the previous context dynamically established by <TT>with-previous-context</TT>.Anaphoric macros call this, either directly or by using the <TT>?=</TT> template syntax.<P><P><P><P><BR><P align=center><A HREF="page-50.html">Previous page</A>&nbsp;&nbsp;&nbsp;<A HREF="index.html">Table of Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="page-52.html">Next page</A></P><BR><br></body></html>