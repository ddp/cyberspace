<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>PLOT: Def Statement</title></head><body><banner><center><h1>Programming Language for Old Timers</h1><br>by David A. Moon<br>February 2006 .. September 2008<br></center><br>Comments and criticisms to dave underscore moon atsign alum dot mit dot edu.<br><hr><br><P align=center><A HREF="page-40.html">Previous page</A>&nbsp;&nbsp;&nbsp;<A HREF="index.html">Table of Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="page-42.html">Next page</A></P><BR><h2>Def Statement</h2><P>The def statement is the most commonly used defining statement in PLOT,hence an abbreviated name is justified.  It can define a method, a variable,or multiple variables.  Variables can be fixed or assignable.  Variables canhave declared types.  The definition can be in a local scope or in the globalscope, whichever is the current scope.<P>The term "variable" is used for traditional reasons, although mostdefinitions are fixed, so the "variable" cannot actually vary.<P>When defining one or more variables, the def statement evaluates an initialvalue expression and gives successive values of the expression to successivevariables.  If the expression does not return sufficient values, the initialvalues for the remaining variables are false.  If the initial valueexpression is preceded by =, the variable definitions are fixed.  If theinitial value expression is preceded by :=, the variable definitions areassignable.<P>When defining a method, the def statement first defines a function, unless the nameis already defined in the current scope.  Note that if the current scope is a localscope, this definition must be directly in the current scope, not inherited from anenclosing scope.  The name must be defined as a function or an operator.  Next, thedef statement creates a method and adds it to the function or operator.<P>The syntax of the def statement is as follows.  This has been simplified to make itmore readable at the cost of not being LL(1).<P><PRE>defmacro def  ;; variable definition form  { ?:typed-variable &amp; ~^ , }+ ~^ { = | := } ?value =&gt; ...  ;; method definition form  ?:method-head [ { first: | last: | next: ?n is name } |                  sealed: | subsumptive: | intrinsic: ?i is name ]*                ?:block =&gt; ...</PRE><P>In reality, the syntax of a def statement is disambiguated as follows:  If thefirst token after <TT>def</TT> is a name with a known definition as an operatoror a macro (including left parenthesis), then the statement is a method definitionand begins with a method-head.  Otherwise the statement begins with atyped-variable.  If the next token after the typed-variable is a comma, thestatement is a multiple variable definition.  If the next token after thetyped-variable is = or :=, the statement is a single token definition.Otherwise, the statement is a method definition and the typed-variable isthe beginning of a method-head.  If the typed-variable is followed by a leftparenthesis, it is a syntax error if a type was specified since method-headdoes not allow a type there.<P>Note that the method-head cannot use the infix-operator form with operators= and := unless the left-hand-side argument to the operator isparenthesized, because of syntactic ambiguity.  If present following a typed-variablethese particles will be parsed as indications of thevariable definition form.<P>The method option keywords between the method-head and the body block have thefollowing meanings:<P><TABLE cellspacing="20"><col width="25%" align="left" valign="top"/><col/><TR><TD align="left" valign="top">first:</TD><TD>Dispatch to this method before the main method andbefore any first methods that are less specific.</TD></TR><TR><TD align="left" valign="top">last:</TD><TD>Dispatch to this method after the main method andafter any last methods that are less specific.</TD></TR><TR><TD align="left" valign="top">next: name</TD><TD>In the body of this method, the specified name will be definedto be a function that can be called to invoke the next mostspecific applicable main method.  By convention, a methodusually passes its own arguments unchanged when calling thenext method this way, but any arguments can be passed.An error occurs if the next method is not applicable tothose arguments.</TD></TR><TR><TD align="left" valign="top">sealed:</TD><TD>This method must always be the most specific when applicable.The compiler can optimize based on the knowledge that thismethod cannot be overridden by a more specific method.</TD></TR><TR><TD align="left" valign="top">subsumptive:</TD><TD>This method has equivalent effect to any more specific methodwhen both are applicable.  This enables certain special casesof compiler optimization.</TD></TR><TR><TD align="left" valign="top">intrinsic: name</TD><TD>The compiler has special knowledge of this method under thespecified name.</TD></TR></TABLE><P>If neither first: nor last: is present, this is a main method.<P>An example usage of subsumptive methods:<PRE>def (x is simple-name) = (y is anything) subsumptive: x eq ydef (x is anything) = (y is simple-name) subsumptive: x eq y</PRE>This says that = on simple-names is always eq, and nothing other than asimple-name can be = to a simple-name, without considering what othermethods might be defined for =.<P><P><BR><P align=center><A HREF="page-40.html">Previous page</A>&nbsp;&nbsp;&nbsp;<A HREF="index.html">Table of Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="page-42.html">Next page</A></P><BR><br></body></html>