<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>PLOT: Parsing Helper Functions</title></head><body><banner><center><h1>Programming Language for Old Timers</h1><br>by David A. Moon<br>February 2006 .. September 2008<br></center><br>Comments and criticisms to dave underscore moon atsign alum dot mit dot edu.<br><hr><br><P align=center><A HREF="page-45.html">Previous page</A>&nbsp;&nbsp;&nbsp;<A HREF="index.html">Table of Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="page-47.html">Next page</A></P><BR><h2>Parsing Helper Functions</h2><P>The following methods are useful helpers for parsing.  Their names arein the compiler module (except for <TT>=</TT>).<P><PRE>(x is name) = (y is name)</PRE>Two names are equal if they must refer to the same definition when used inthe same scope.  In other words, their spellings are the same and theircontexts are eq.  If either name is a simple-name, = is the same as eq.<P><PRE>same-spelling?(x is name, y is name)</PRE>True if the two names' spellings are the same, ignoring alphabetic case.Use this to compare absolute particles.<P><PRE>punctuation?(x is name)</PRE>True if x is punctuation.<P><PRE>match?(x is name, ts is token-stream, key: skip-newline = true,       result: match? is boolean)</PRE>If skip-newline is true and the next token is a newline, look at the token after that, otherwiselook at the next token.  If this token is a name and matches x usingsame-spelling?, advance the token-stream past this token and returntrue, else false.  There are analogous methods for keywords and literalsthat compare with =.<P><PRE>match!(x is name, ts is token-stream, key: skip-newline = true,       result: match? is boolean)</PRE>If skip-newline is true and the next token is a newline, look at the token after that, otherwiselook at the next token.  If this token is a name and matches x usingsame-spelling?, advance the token-stream past this token and returntrue, else call <TT>wrong-token-error</TT>.There are analogous methods for keywords and literalsthat compare with =.<P><PRE>match(x, ts is token-stream, error? is boolean, key: skip-newline = true,      result: match? is boolean)</PRE>Call match? or match! depending on error?.<P><PRE>match-bound-particle?(value, ts is token-stream, key: skip-newline = true,                      result: match? is boolean)</PRE>If skip-newline is true and the next token is a newline, look at the token after that, otherwiselook at the next token.  If this token is a name and has a known definition of value,advance the token-stream past this token and returntrue, else false.  This is how you match an optional bound particle.<P><PRE>match-bound-particle!(name, value, ts is token-stream, key: skip-newline = true,                      result: match? is boolean)</PRE>If skip-newline is true and the next token is a newline, look at the token after that, otherwiselook at the next token.  If this token is a name and has a known definition of value,advance the token-stream past this token and returntrue, else call <TT>wrong-token-error</TT>.This is how you match a required bound particle.<P><PRE>match-bound-particle(name, value, ts is token-stream, error? is boolean, key: skip-newline = true,                     result: match? is boolean)</PRE>Call match-bound-particle? or match-bound-particle! depending on error?.<P><PRE>begin-line-group?(ts is token-stream,                  result: previous-indentation? is integer or boolean)</PRE>Implement pattern matching rules for the start of a line group.The result is the previous indentation if the match succeeds or falseif the match fails.The result is 1's complemented if there was no newline.<P><PRE>continue-line-group?(ts is token-stream, previous-indentation is integer,                     result: match? is boolean)</PRE>Implement pattern matching rules for the next repetition of a line group.<P><PRE>end-line-group(ts is token-stream, previous-indentation is integer)</PRE>Leave a line group during pattern matching.  This restores the previouscurrent-indentation.  When the line-group began on a new line, it mustend on a new line that is not a continuation line.<P><PRE>match-line-group?(ts is token-stream, previous-indentation,                  error? is boolean, repeat? is boolean,                  result: previous-indentation? is integer or boolean)</PRE>Call begin-line-group? or continue-line-group? depending on repeat? anddeal with failure to match according to error?.If repeat? is false, the result is the previous indentation if it matchesor false if it does not match.If repeat? is true, the result is true if it matches or false if it doesn't.This implements the line-break pattern element <TT>^</TT>.<P><PRE>wrong-token-error(ts is token-stream, expected is anything)</PRE>Signal a parsing error.  The error message indicates that<TT>expected</TT> was expected but <TT>next-after-newline(ts)</TT> was seen.The <TT>expected</TT> argument can be a string or a collection of names or strings.The <TT>ts</TT> argument also supplies the source-location.<P><BR><P align=center><A HREF="page-45.html">Previous page</A>&nbsp;&nbsp;&nbsp;<A HREF="index.html">Table of Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="page-47.html">Next page</A></P><BR><br></body></html>