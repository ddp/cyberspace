<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>PLOT: Modules</title></head><body><banner><center><h1>Programming Language for Old Timers</h1><br>by David A. Moon<br>February 2006 .. September 2008<br></center><br>Comments and criticisms to dave underscore moon atsign alum dot mit dot edu.<br><hr><br><P align=center><A HREF="page-47.html">Previous page</A>&nbsp;&nbsp;&nbsp;<A HREF="index.html">Table of Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="page-49.html">Next page</A></P><BR><h2>Modules</h2><P>A module maps names to definitions, which can be fixed or assignable.  Mostdefinition statements create fixed definitions.  def name := value createsan assignable definition.<P>defmodule creates a definition whose name is the module name prefixed by @.Generally references to a module omit the @.  Unless the module namecontains an embedded @, this definition is defined in the current module.When the module name has only a trailing @, the definition is in the root module.<P>An embedded @ within a name indicates a name-in-module.  It is rightassociative.  a@b means variable a in the module that is the value of @b inthe current module.  a@b@c means variable a in the module that is the value ofvariable @b in the module that is the value of variable @c in the currentmodule.  A trailing @ means the root module; it does not mean the module thatis the value of the variable @ in the current module.  Thus @a@ means thevariable @a in the root module.<P>This idea avoids a separate naming system for modules (they are just namedby definitions), but avoids name conflicts by using the @ prefix convention.Name conflicts in the root module can be minimized by using hierarchicalmodule naming.<P>The standard module PLOT contains all the standard definitions of thelanguage, including definitions of standard modules such as PLOT andCOMPILER.  Unless overridden, a module created by defmodule imports all thedefinitions exported by PLOT and thus has the standard definitions of thelanguage directly available to it and can refer to xyz in the compilermodule by xyz@compiler rather than xyz@compiler@.<P>A module object remembers its name.  When doing separate compilation,references to the module are written into the fasl file using this name.When the fasl file is loaded, the corresponding runtime module object canbe located as the definition of this name.<P>When doing separate compilation, the compiler can create a substitute rootmodule which is populated with a copy of the basic definitions needed.  Thiscan prevent definitions in the program being compiled from clobberingdefinitions used by the compiler.<P>A program can contain the token module: and an expression evaluated in thecurrent module whose value is the module containing the rest of the program.The expression can be a defmodule or a module name (with the @ prefix).Prior to the first module: token in a program, the current module is a"default user" module that imports all the definitions exported by PLOT.<P>A module can export definitions and can import definitions from othermodules, maybe with renaming.  A set of exports can be specified as a stringpattern and all definitions whose name matches the pattern will be exported.Imports are resolved dynamically so new exports can be added at any timeand will be available as imports in dependent modules for future parsing or linking.<P>A program can contain the token export: and any module-level definitionsnamed or defined by the following expression will be exported fromthe current module.  This may bepreferable to listing exports individually in defmodule.<P><P><BR><P align=center><A HREF="page-47.html">Previous page</A>&nbsp;&nbsp;&nbsp;<A HREF="index.html">Table of Contents</A>&nbsp;&nbsp;&nbsp;<A HREF="page-49.html">Next page</A></P><BR><br></body></html>